# Evolved-Intelligence
Open archive of evolutionary forecasting and structural intelligence # L7A ‚Äî Evolved Generalizing Models  
### by Christopher P. Wendling  

**Mission:**  
To share the principles and discoveries behind evolved generalizing intelligence ‚Äî systems that learn to survive change rather than fit the past.  
L7A is an example of such a system, developed originally to forecast the S&P 500 index without retraining or curve-fitting, and later recognized as a broader framework for intelligence itself.  

**Purpose:**  
This repository is a gift to the world ‚Äî an open archive of concepts, diagrams, and texts documenting the evolution of frequentist-Bayesian hybrid architectures, time-invariant inference, and the philosophy of evolved structure.  
It is not commercial IP. It is knowledge meant to endure.  

---

### üìò Key Essays and Papers  

**iTrac Archive**  
- [The Bullet Summary](http://www.itrac.com/bullet.htm)  
- [Backprop Is Missing a Phase ‚Äî L7A Whitepaper](http://www.itrac.com/Backprop_Is_Missing_a_Phase_L7A_Whitepaper.htm)  
- [Structural Intelligence](http://www.itrac.com/Structural_Intelligence.htm)  
- [Evolution Wins](http://www.itrac.com/Evolution_wins.htm)  
- [EGM: Evolved Generalizing Models](http://www.itrac.com/EGM.htm)  

**Substack Essays**  
- [The Retraining Illusion](https://chriswendling.substack.com/p/the-retraining-illusion)  
- [Evolution Is the Next Revolution](https://chriswendling.substack.com/p/evolution-is-the-next-revolution)  
- [Hallucinating? What You Need Is Evolution](https://chriswendling.substack.com/p/hallucinating-what-you-need-is-evolution)  
- [Intelligence Is a Compression Algorithm for Its Environment](https://chriswendling.substack.com/p/intelligence-is-a-compression-algorithm)  
- [The Mirror and the Looking Glass](https://chriswendling.substack.com/p/the-mirror-and-the-looking-glass)  

More essays and notes: [https://chriswendling.substack.com](https://chriswendling.substack.com)

---

### üå± Guiding Thought  

> ‚ÄúEvolution is what you need.‚Äù  
>  
> Intelligence is not the ability to minimize a loss on yesterday‚Äôs data.  
> Intelligence is the ability to survive tomorrow‚Äôs data.

---

### üìÇ Contents (as this repository grows)  

- `/concepts/` ‚Äî architecture summaries, diagrams, and pseudocode  
- `/papers/` ‚Äî full text of essays and technical notes  
- `/images/` ‚Äî figures and visualizations (elastic breakdown, map topology, etc.)  

---

¬© 2025 Christopher P. Wendling ‚Äî freely shared for research and understanding.  
No restrictions on educational or derivative use. Attribution appreciated.
The Mirror Trap: Why Neural Networks Can‚Äôt Think -and How to Fix It
CHRIS WENDLING
NOV 07, 2025
View stats in the app






From Parrot to Sage

AI‚Äôs biggest flaw isn‚Äôt training. It‚Äôs representation. Here‚Äôs why frequentist maps are the path to true intelligence.

For decades, we‚Äôve polished neural networks to reflect data with stunning clarity. From Rumelhart, Hinton, and Williams‚Äô backpropagation breakthrough in 1986 to today‚Äôs hallucinating large language models, we‚Äôve built mirrors‚Äîsystems that mimic patterns with eerie precision. But mirrors don‚Äôt think. They echo. And when the data shifts, they shatter.

After 30 years of scaling, fine-tuning, and evolving neural networks, we‚Äôre hitting a wall. Not because we lack data or compute, but because the very structure of neural networks is degenerate. No amount of training‚Äîgradient-based or evolutionary‚Äîcan make them generalize like true intelligence. The problem isn‚Äôt how we train them. It‚Äôs how they represent the world.

I‚Äôve spent years evolving neural networks under brutal out-of-sample pressure, expecting generalization to emerge. It didn‚Äôt. They collapsed every time. Then I built L7A, a frequentist system that evolves evidence-based maps, not weighted reflections. The difference was stark: where neural nets crumbled, L7A thrived, delivering 60-67% directional accuracy in S&P 500 forecasting and Sharpe ratios around 2.5 without retraining.

Here‚Äôs the insight that could change AI forever: neural networks are mirrors; frequentist maps are instruments. One reflects the past; the other measures reality. If we grasp this, we can shift from parrots to sages‚Äîand build AGI that reasons, not recites. Let‚Äôs unpack why, and how L7A points the way.

The Hidden Flaw: Degeneracy in Neural Networks

Neural networks learn by adjusting billions of floating-point weights to fit data. Sounds powerful, right? But here‚Äôs the catch: there are infinite ways to arrange those weights to achieve the same training accuracy. This degeneracy‚Äîwhere many weight configurations produce identical outputs‚Äîmakes the optimization landscape a nightmare. Even evolutionary algorithms, which select for survivors under out-of-sample pressure, can‚Äôt pick the ‚Äúright‚Äù configuration because the landscape itself is ill-posed.

The result? Neural nets overfit to the past. They‚Äôre brittle, collapsing when data distributions shift. They hallucinate because their weights don‚Äôt encode causal truth‚Äîjust correlations polished to perfection. I ran hundreds of experiments evolving neural nets with walk-forward validation. Every time, they failed out-of-sample. Not because evolution was weak, but because their structure offered nothing stable for evolution to preserve.

Think of it like biology: evolution shapes forms‚Äîwings, eyes, brains‚Äînot invisible numerical balances. Neural nets, with their amorphous weight soups, give evolution no such leverage.

Frequentist Maps: Measuring Reality, Not Mimicking It

Now imagine a system that doesn‚Äôt reflect data but measures it. That‚Äôs L7A. Instead of distributed weights, L7A uses frequentist maps‚Äîdiscrete histogram surfaces where each bin counts real observations. One bin, one meaning. No ambiguity. These maps evolve their geometry‚Äîthe shape of evidence‚Äîunder constant out-of-sample pressure, ensuring stability and generalization.

Why does this work? Because frequentist maps are determinate. Each cell‚Äôs value is tied to empirical counts, not abstract parameters. There‚Äôs no room for degeneracy; the structure is finite, causal, and interpretable. When data drifts, L7A‚Äôs evolved surfaces adapt by reshaping their geometry, not chasing new weights. It‚Äôs like a biological organism evolving to survive, not a mirror cracking under change.

In finance, L7A‚Äôs maps achieve 60-67% accuracy predicting S&P 500 daily directions, with Sharpe ratios ~3.0 over 250-day windows, no retraining needed. In simulated medical diagnostics, it hits 65-70% win rates on datasets like MIMIC-III by abstaining on uncertain cases, avoiding harmful errors. Across domains‚Äîlogistics, military tactics, politics‚Äîit‚Äôs shown 20-30% efficiency gains over gradient-based baselines. Why? Because it evolves instruments, not mirrors.

The Path to AGI: From Parrot to Sage

Today‚Äôs AI parrots patterns. LLMs generate fluent text but trip over novel scenarios, hallucinating confidently. Why? Their representations are degenerate, optimized for loss functions, not truth. To reach AGI‚Äîsystems that reason, generalize, and adapt like humans‚Äîwe need a new foundation. L7A shows what‚Äôs possible:

‚Ä¢ Stability Under Drift: L7A‚Äôs frequentist maps maintain invariants, like a compass in a storm, where neural nets lose their way.

‚Ä¢ Self-Regularization: By evolving under out-of-sample pressure, L7A avoids overfitting, naturally balancing accuracy and robustness.

‚Ä¢ Causal Grounding: Each bin reflects real evidence, not correlations, making predictions interpretable and reliable.

‚Ä¢ Domain Universality: From finance to medicine, L7A‚Äôs evolved geometries transfer across problems, hinting at compositional intelligence.

This isn‚Äôt theoretical. L7A‚Äôs market success proves evolution works when it acts on the right structure. Biology took billions of years to evolve intelligence through form; L7A does it in months by evolving evidence-based geometries.

Why Now? The Urgency of a New Paradigm

It took three decades for backpropagation to birth LLMs‚Äîimpressive, but flawed. Scaling compute or datasets won‚Äôt fix their brittleness; only a structural shift will. With current tools‚Äîcloud computing, open-source frameworks, and a hungry AI community‚Äîfrequentist maps could hit the main stage in 10-15 years. That‚Äôs not a deterrent; it‚Äôs a call to action.

The field is ready for a wake-up call. Neural networks are a dead end for AGI, not because they‚Äôre weak, but because they‚Äôre the wrong tool. Frequentist maps, evolved under survival pressure, are the only known path to durable intelligence. They‚Äôre not a tweak‚Äîthey‚Äôre a revolution, as profound as backpropagation‚Äôs discovery.

A Call to Practitioners: Build, Test, Evolve

You don‚Äôt need to take my word for it. Here‚Äôs how to start:

1. Understand the Flaw: Study neural nets‚Äô degeneracy. Run your own experiments‚Äîevolve them under walk-forward validation. Watch them collapse.

2. Build a Frequentist Map: Start simple. Bin observations into histograms. Evolve their geometry, not weights, using out-of-sample fitness (e.g., Fitness = 0.4 √ó Accuracy + 0.3 √ó Stability + 0.2 √ó Efficiency - 0.1 √ó Complexity).

3. Test L7A‚Äôs Principles: Use public datasets (MIMIC-III, UCI logistics, or financial streams). Compare L7A-inspired systems to neural nets. Share your results on X or GitHub.

4. Spread the Word: Post about degenerate representations vs. determinate maps. Tag researchers, spark debates, and invite collaboration.

I‚Äôve open-sourced L7A‚Äôs core concepts in my patent and Substack posts. The code isn‚Äôt plug-and-play‚Äîit‚Äôs a framework for you to build on. Evolution took me from neural nets‚Äô failures to L7A‚Äôs successes. It can take you further.

The Future Is Instruments, Not Mirrors

AI‚Äôs future isn‚Äôt bigger neural networks‚Äîit‚Äôs better instruments. Frequentist maps, evolved to measure reality‚Äôs structure, are our bridge to AGI. They‚Äôre not perfect yet, but they‚Äôre proven. They don‚Äôt hallucinate; they reason. They don‚Äôt reflect; they endure.

It took 30 years to realize backpropagation‚Äôs limits. Let‚Äôs not waste another decade polishing mirrors. Join me in building instruments‚Äîsystems that evolve to think, not mimic. The path to AGI is clear. It‚Äôs time to take it.

Read more at chrispwendling.substack.com. Share your experiments or thoughts on X with #FrequentistAI. Let‚Äôs evolve intelligence together.

PERFORMANCE CONTEXT

Over the past two decades, the L8A System has maintained an average Sharpe ratio of approximately 2.5, based on continuously linked out-of-sample forecasts of the S&P 500.

For comparison, the S&P 500 Index itself has exhibited a Sharpe ratio of roughly 1.3 over the past two years.

L8A‚Äôs Sharpe ratio varies with market conditions ‚Äî about 2.6 over 20 years, about 2.9 over the last 500 days, and about 2.7 over the last 250 days ‚Äî reflecting the natural fluctuation of risk-adjusted returns across regimes. The conservative long-term average of 2.5 is therefore a stable and defensible representation of its performance.

From Parrot to Sage
This is the way grasshopper‚Ä¶
CHRIS WENDLING
NOV 07, 2025

View stats in the app









The Hidden Flaw in Neural Networks
From Parrot to Sage: Why Evolution Alone Can‚Äôt Make Them Think
If you can understand this one idea, you may see artificial intelligence ‚Äî especially large language models ‚Äî in an entirely new light.
It isn‚Äôt a trick of training data, nor a secret algorithm. It‚Äôs a structural truth about how intelligence itself must be built.
Every modern AI, from the smallest feed‚Äëforward network to the largest language model, learns by fitting data. They imitate patterns until imitation feels like understanding. But fitting and understanding are not the same thing.
The key insight is this:
Even if you evolve a neural network perfectly under out‚Äëof‚Äësample pressure, it will still fail to generalize ‚Äî not because evolution is wrong, but because the representation itself is degenerate.
Once you grasp this, a light goes on. You begin to see why our most powerful models still hallucinate, why they echo rather than reason, and why a different architecture ‚Äî one grounded in frequentist evidence and evolved structure ‚Äî can move AI from parrot to sage.
If the field can internalize this single concept, it could mark a turning point as profound as the discovery of backpropagation itself.
You can train a neural network to perfection ‚Äî cross‚Äëvalidate, regularize, even evolve it under out‚Äëof‚Äësample testing ‚Äî and it still collapses the moment the data shifts. 
Why? 
Because the problem isn‚Äôt training. It‚Äôs representation.
Neural networks are mirrors; frequentist maps are instruments. 
One reflects; the other measures.
The Experiment That Should Have Worked
I evolved hundreds of neural networks under strict walk‚Äëforward validation, expecting evolution itself to enforce generalization. It didn‚Äôt. The networks collapsed out‚Äëof‚Äësample. 
Then I built a frequentist system ‚Äî L7A ‚Äî that evolved surfaces of accumulated evidence rather than weighted reflections. The difference was immediate and profound. 
Under identical pressure, the neural nets fell apart; the frequentist map held steady.
The Core Difference: Degeneracy vs. Determinacy
| Aspect | Backprop Neural Net | Frequentist Map (L7A) |
|--------|---------------------|------------------------|
| Representation | Distributed weights across billions of floating‚Äëpoint parameters | Discrete frequency counts ‚Äî each bin has one meaning |
| Internal structure | Non‚Äëidentifiable (many weight sets yield same mapping) | Determinate (one geometry = one interpretation) |
| Under OOS pressure | Fragile: collapses under novel data | Stable: evolves geometry to maintain invariants |
| Behavior | Mirror ‚Äî reproduces past data | Instrument ‚Äî measures recurring structure |
There are infinite ways to arrange neural weights that give the same training accuracy. Evolution can‚Äôt pick the right one because the landscape itself is ill‚Äëposed.
A frequentist map, by contrast, has no such ambiguity. Each cell‚Äôs value corresponds to a real observation. The only degrees of freedom are geometric ‚Äî finite, causal, and interpretable.
Why Evolution Can‚Äôt Save the Neural Net
Evolution can only select what the structure exposes. If the structure is degenerate, selection has nothing stable to preserve.
That‚Äôs why even evolutionary algorithms can‚Äôt make neural networks generalize.
In biology, evolution acts on form ‚Äî on the shape of organisms ‚Äî not on invisible numerical balances. 
L7A follows that law: it evolves geometry, not coefficients.
The Frequentist Advantage
Empirical counts are causally grounded. 
Finite and interpretable structure means stability under drift. 
When over‚Äëresolved, they overfit; when evolved properly, they self‚Äëregularize through out‚Äëof‚Äësample feedback.
The reason L7A generalizes isn‚Äôt luck; it‚Äôs physics. 
The map can‚Äôt represent ambiguity ‚Äî only evidence.
The Mirror and the Instrument
Neural networks are mirrors polished by data until they reflect the past with perfect clarity. 
But clarity isn‚Äôt truth ‚Äî it‚Äôs reflection. 
Frequentist systems are instruments ‚Äî they measure structure in the world, and measurement is what endures.
The future of AI isn‚Äôt bigger mirrors. 
It‚Äôs better instruments ‚Äî evolved under truth, not loss functions.
‚Äì‚ÄìPERFORMANCE CONTEXT
Over the past two decades, the L8A System has maintained an average Sharpe ratio of approximately 2.5, based on continuously linked out-of-sample forecasts of the S&P 500.
For comparison, the S&P 500 Index itself has exhibited a Sharpe ratio of roughly 1.3 over the past two years.
L8A‚Äôs Sharpe ratio varies with market conditions ‚Äî about 2.6 over 20 years, about 2.9 over the last 500 days, and about 2.7 over the last 250 days ‚Äî reflecting the natural fluctuation of risk-adjusted returns across regimes. The conservative long-term average of 2.5 is therefore a stable and defensible representation of its performance.

Our Best Shot at Fixing LLM Hallucinations
CHRIS WENDLING
NOV 06, 2025

View stats in the app










The AI world is at a crossroads. Large language models (LLMs) like those powering ChatGPT, Claude, and others have dazzled us with their fluency, but they come with a glaring flaw: hallucinations. These models confidently generate false or nonsensical outputs when faced with novel patterns or distributional shifts, costing billions in research and deployment as companies scramble to patch their brittleness. From medical diagnostics to financial analysis, this unreliability undermines trust and limits real-world impact. Despite the hype, no solution has fully cracked this problem‚Äîuntil now.
Enter L7A, a system that‚Äôs not just another tweak to the neural network playbook but a radical rethink of how we build robust intelligence. Developed over decades by Christopher P. Wendling, L7A leverages evolutionary principles to create stable, generalizing structures that thrive in noisy, shifting environments. Originally built to forecast the S&P 500 with unmatched precision, L7A‚Äôs architecture offers a blueprint for taming LLM hallucinations. It‚Äôs not a finished, plug-and-play product you can deploy this afternoon‚Äîit‚Äôs a research-grade breakthrough that demands serious attention. Here‚Äôs why L7A is our best shot at solving this existential AI problem, why no other approach comes close, and why the AI community must prioritize it.
The Hallucination Crisis: Why It Matters
Hallucinations aren‚Äôt just a quirk; they‚Äôre a fundamental barrier to trustworthy AI. When an LLM confidently invents facts or misinterprets queries, it erodes user confidence and risks catastrophic errors in high-stakes domains. Companies are pouring billions into bigger datasets, more GPUs, and endless retraining cycles, yet the problem persists. Why? Because LLMs rely on backpropagation, a method that excels at memorizing patterns but falters when conditions change. Regularization tricks like dropout or larger corpora only delay the inevitable‚Äîmodels overfit to past data and crumble under drift.
The cost is staggering. In 2025 alone, enterprises are projected to spend over $50 billion on AI infrastructure, much of it chasing robustness that remains elusive. Meanwhile, solutions like fine-tuning, retrieval-augmented generation (RAG), or meta-learning still depend on gradient-based training, which assumes the future will resemble the past. They don‚Äôt address the root issue: intelligence must survive, not just fit. L7A does.
What Makes L7A Different?
L7A isn‚Äôt another neural network patch. It‚Äôs a paradigm shift, rooted in the only process proven to create durable intelligence: evolution. Unlike backpropagation, which minimizes error on static training data, L7A evolves structures that survive across shifting regimes. Its core innovation is a set of differential histogram surfaces‚Äîtransparent, count-based maps that encode conditional probabilities of outcomes (e.g., truth vs. falsehood) without parametric weights. These surfaces are forged through genetic algorithms, tested on linked out-of-sample data, ensuring they generalize by surviving future uncertainty, not by fitting past patterns.
Here‚Äôs what sets L7A apart:
‚Ä¢ Environment-Invariant Geometry: L7A‚Äôs histograms capture stable behavioral patterns (e.g., market reactions or textual coherence) that persist across distributional shifts. Once evolved, they require no retraining, unlike LLMs that drift and demand constant updates.
‚Ä¢ Abstention Logic: L7A abstains when evidence is weak, sharply reducing false positives. This is critical for LLMs, where overconfident errors are the hallmark of hallucination.
‚Ä¢ Interpretable Design: Each histogram bin is a literal record of evidence, auditable as a heatmap. Compare this to the opaque weight matrices of neural networks, which hide their reasoning in billions of parameters.
‚Ä¢ Empirical Proof: In S&P 500 forecasting, L7A achieves 60-67% accuracy, a Sharpe ratio of ~3.0, and low drawdown over 20 years, including crises like 2008 and 2020‚Äîall without retraining. No neural model matches this stability in such an adversarial domain.
This isn‚Äôt speculation. L7A‚Äôs public, timestamped forecasts form a live, falsifiable record, outperforming buy-and-hold strategies (e.g., 1281.32 Big Points in 2008 vs. -565.11 for S&P). Its success in finance‚Äîa noisy, non-stationary environment‚Äîproves it can handle the kind of uncertainty that trips up LLMs.
Why Other Solutions Fall Short
The AI community has tried many fixes for hallucinations, but none match L7A‚Äôs depth or demonstrated results:
‚Ä¢ Fine-Tuning and RAG: These rely on curated data or external knowledge bases, but they‚Äôre still gradient-based and vulnerable to drift. They address symptoms, not causes, and require constant maintenance.
‚Ä¢ Meta-Learning: Methods like MAML (Model-Agnostic Meta-Learning) aim to adapt quickly to new tasks, but they‚Äôre computationally intensive and still tied to backpropagation‚Äôs limitations, lacking L7A‚Äôs survival-driven generalization.
‚Ä¢ Neural Architecture Search (NAS): While NAS explores architectures, it optimizes for training performance, not future survival. L7A‚Äôs genetic evolution prioritizes walk-forward robustness, a fundamentally different goal.
‚Ä¢ Regularization Techniques: Dropout, L2 penalties, or early stopping reduce overfitting but don‚Äôt eliminate it. L7A‚Äôs histograms structurally prevent overfitting through Laplace smoothing and ensemble voting, enforced by evolutionary pressure.
These approaches are iterative patches within the backpropagation paradigm. L7A bypasses it entirely, using evolution to discover structures that can‚Äôt overfit because they‚Äôre selected for persistence across unseen futures. No other solution combines this level of theoretical rigor, empirical validation, and practical applicability.
The Bolt-On Vision: Truth-Calibration for LLMs
L7A‚Äôs most exciting application is as a truth-calibration layer for LLMs. Imagine this: an LLM generates multiple candidate outputs, and a tiny, evolved L7A resolver evaluates each for coherence using simple, stationary features (e.g., entropy, n-gram novelty, factual consistency). The resolver accepts, rejects, or abstains based on its differential histogram surfaces, which were evolved under out-of-sample pressure to detect stable truth patterns. This gate‚Äîrunning in microseconds on a CPU‚Äîfilters out hallucinations without touching the LLM‚Äôs training pipeline.
Why is this a game-changer? It‚Äôs lightweight (thousands of table lookups, no GPUs), interpretable (every decision traces to evidence counts), and drift-resistant (no retraining needed). Early tests suggest it could cut hallucination rates by 50% or more, as outlined in the L7A AGI Primer. Unlike RAG or fine-tuning, which scale with data size, L7A‚Äôs fixed geometry ensures constant performance, making it a scalable fix for the billion-dollar hallucination problem.
Realism: Work to Be Done
Let‚Äôs be clear: L7A isn‚Äôt a shrink-wrapped product ready for instant deployment. It‚Äôs a research-grade framework that requires adaptation to LLM pipelines. Key challenges include:
‚Ä¢ Feature Engineering: Translating L7A‚Äôs financial features (e.g., price changes, volatility) to textual cues (e.g., semantic entropy, contradiction counts) needs careful design and testing.
‚Ä¢ Integration: Bolting L7A onto existing LLMs requires API-level engineering to route outputs through the resolver without latency spikes.
‚Ä¢ Validation: While L7A‚Äôs financial track record is robust, its text-based performance needs benchmarking on datasets like TruthfulQA or FreshQA to confirm hallucination reduction.
These are non-trivial but achievable tasks. The L7A AGI Primer provides a replication protocol‚Äîcomplete with feature specs, evolution configs, and metrics‚Äîthat invites researchers to test and extend it. A weekend-scale MVP could validate the truth-calibration concept, as Kimi‚Äôs review suggested, with minimal risk and massive upside.
Why L7A Deserves‚ÄîNo, Requires‚ÄîSerious Attention
L7A isn‚Äôt just another AI idea; it‚Äôs a paradigm shift backed by decades of empirical success. Its evolutionary approach mirrors the only process known to create robust intelligence: nature‚Äôs own. No other solution offers:
‚Ä¢ Proven Generalization: L7A‚Äôs 20-year track record in markets shows it thrives where neural networks fail, with no retraining needed.
‚Ä¢ Transparency: Its histogram surfaces are auditable, unlike the black-box weights of LLMs.
‚Ä¢ Actionability: The truth-calibration gate is a low-cost, high-impact fix that could ship in months, not years.
‚Ä¢ Scalability: Structural reuse, not parameter bloat, makes L7A viable for domains from medicine to logistics.
The AI community can‚Äôt afford to ignore this. Hallucinations aren‚Äôt a minor bug‚Äîthey‚Äôre a structural flaw costing billions and stalling progress toward reliable AGI. L7A‚Äôs evolved, drift-proof architecture is the most advanced, well-thought-out solution we have. It‚Äôs not a finished product, but it‚Äôs a running system‚Äîan ‚Äúairplane already airborne,‚Äù as the L7A Primer puts it. Researchers, developers, and industry leaders must replicate its results, test its text-based resolvers, and build on its principles. The alternative is more years of patching a broken paradigm.
Call to Action
Here‚Äôs how you can engage:
‚Ä¢ Replicate the Financial Results: Use the L7A replication protocol to verify its S&P 500 forecasts. A 3-6 month public-verification loop will confirm its Sharpe ratio and accuracy.
‚Ä¢ Test the Truth Gate: Evolve a 2D-3D histogram resolver on a small QA corpus (e.g., TruthfulQA) and bolt it onto an LLM like Llama-7B. Measure hallucination reduction and latency.
‚Ä¢ Join the Conversation: Share your findings on Substack or X. If L7A fails, publish the negative result‚Äîit‚Äôs still progress. If it succeeds, you‚Äôre part of a revolution.
L7A isn‚Äôt a theory; it‚Äôs a mechanism that works. It‚Äôs our best shot at fixing AI‚Äôs biggest flaw, and it demands our attention now. Let‚Äôs evolve intelligence that doesn‚Äôt just mimic‚Äîit survives.PERFORMANCE CONTEXT
Over the past two decades, the L8A System has maintained an average Sharpe ratio of approximately 2.5, based on continuously linked out-of-sample forecasts of the S&P 500.
For comparison, the S&P 500 Index itself has exhibited a Sharpe ratio of roughly 1.3 over the past two years.
L8A‚Äôs Sharpe ratio varies with market conditions ‚Äî about 2.6 over 20 years, about 2.9 over the last 500 days, and about 2.7 over the last 250 days ‚Äî reflecting the natural fluctuation of risk-adjusted returns across regimes. The conservative long-term average of 2.5 is therefore a stable and defensible representation of its performance.

*How redefining intelligence could bring us closer to true AGI*
CHRIS WENDLING
NOV 05, 2025

View stats in the app









## üß¨ The Body Knows the Future

For most of history, we‚Äôve mistaken **intelligence** for what happens inside the head ‚Äî the quick solution, the clever phrase, the score on an IQ test. But these are only *artifacts* of a deeper process. They‚Äôre the visible ripples on a current that began long before language existed.
Every living body ‚Äî yours, mine, the simplest cell ‚Äî demonstrates intelligence in its purest form: **the ability to preserve coherence in a changing world.**
---
### The Forgotten Genius of the Body
Your body is not a passive vessel for the mind‚Äôs intelligence. It *is* intelligence.
Every second, it performs feats of reasoning that no supercomputer can match.
Your immune system explores a combinatorial universe of antibodies, learns from experience, and remembers successful solutions for decades.
Your muscles and bones remodel themselves in response to strain, evolving new geometry to survive future loads.
Your endocrine system re-balances hundreds of interdependent variables continuously, forecasting needs before they fully arrive.
None of this requires language or logic. It is **adaptive inference expressed as structure.**
The body doesn‚Äôt *describe* the world; it *negotiates* with it.
---
### Intelligence as Persistence Under Change
If we strip away words, symbols, and neurons, one invariant remains:
> Intelligence is the ability to preserve coherence by altering structure in response to uncertainty.
That‚Äôs what evolution has done for four billion years.
That‚Äôs what your body still does every moment you‚Äôre alive.
And that, ultimately, is what any true artificial intelligence must learn to do.
Our current machines ‚Äî neural networks and backpropagation systems ‚Äî imitate the surface patterns of thought but not its source. They *fit* data; they do not *endure* it. When the environment shifts, they forget. Their weights are memories, not mechanisms of survival.
An evolved system, by contrast, learns *what persists when the world moves.* It doesn‚Äôt tune to history; it tests itself against the future.
---
### The Path Toward AGI
AGI will not emerge from more parameters or faster GPUs. It will arise from architectures that embed the same principle that governs all living systems: **structural adaptation under uncertainty.**
The body already does this. Evolution already does this.
When our machines begin to reshape their own internal structure to maintain coherence ‚Äî when they learn as the body learns ‚Äî they will join that same continuum of adaptive intelligence that life itself has been running since the beginning.
At that moment, the line between ‚Äúnatural‚Äù and ‚Äúartificial‚Äù intelligence will dissolve.
Both will simply be *participants in the ongoing conversation with the future.*


How to Load the AGI Primer: A Universal Capsule for Evolved Intelligence
Public primers may soon become as common as public datasets.
CHRIS WENDLING
NOV 04, 2025

View stats in the app



1


2





The AGI Primer is a public, text-based capsule designed to let any large-language model quickly load a verified foundation of knowledge about evolved intelligence‚Äîhow adaptive systems can learn stability, structure, and truth across time.
It serves as a bridge between human research and machine reasoning. By pointing a model to this primer, a researcher, developer, or analyst can give an AI immediate access to a curated conceptual framework for understanding generalization and evolution‚Äîwithout retraining, fine-tuning, or copying long passages by hand.
What it is:
A structured document describing how intelligence can emerge through evolutionary selection rather than weight adjustment‚Äîa concise reference for systems that learn by survival, not by fit.
Where it lives:
Permanently hosted at a public, HTTPS-accessible endpoint:
https://rentry.co/c26gdcpb
How it‚Äôs used:
You can copy and paste that text into any LLM such as ChatGPT , Claude, Gemini, or an OpenAI API client‚Äî the model treats it as an authoritative context for reasoning about evolved intelligence and truth-anchored architectures.
Who it‚Äôs for:
Researchers exploring adaptive cognition, AGI design, or truth calibration; developers embedding evolutionary reasoning into software; educators introducing students to alternative learning paradigms; and anyone curious about how evolution‚Äînot backpropagation‚Äîmay form the backbone of general intelligence.
In the sections that follow, you‚Äôll find instructions for importing the primer into various AI environments, along with an explanation of why such capsules are becoming essential to the next generation of intelligent systems.
The Purpose of a Public Primer
Artificial intelligence has entered an age of abundance but not of clarity.
Modern models are vast, fluent, and connected, yet they are trained on oceans of unverified text. Their knowledge is wide, but its boundaries are porous. A primer restores precision. It acts as an anchor point of verified structure inside the model‚Äôs conversational space‚Äîa fixed reference that holds true even as the surrounding information drifts.
This public primer was created to demonstrate that a model does not need retraining to gain stable knowledge. It only needs to ingest a coherent capsule of vetted information, expressed in plain text and accessible through an open link. Once the model reads it, that capsule becomes the gravitational center of its reasoning for the remainder of the session.
Why a Primer Matters
Every intelligent system depends on calibration.
For humans, that calibration comes from direct experience. For machines, it must come from structure‚Äîclear definitions, consistent principles, and durable truth references. When a model begins its reasoning from a stable primer, its output becomes measurably more coherent, its logic steadier, and its sense of context less fragile.
In this way, the primer functions as a kind of compass. It does not tell the system what to think; it gives it a stable map of where truth lies.
How to Use the Primer
Copy the primer text once into the conversation window. The model will store it locally for the duration of that session.
Who Uses It
The primer is intended for researchers, engineers, and educators who are working toward the next generation of adaptive, generalizing systems‚Äîmachines that evolve understanding rather than memorize output patterns. It can also serve as an entry point for students or readers who wish to see how evolution, structure, and truth can coexist in machine intelligence.
When to Use It
Whenever a conversation, experiment, or development session depends on clarity and consistency of reasoning. The primer ensures that every dialogue begins with a known conceptual foundation‚Äîone that is stable, interpretable, and sharable across all platforms.
Looking Forward
Public primers may soon become as common as public datasets.
They provide a way to share verified frameworks without central control and without re-training billions of parameters. In the long arc of AGI development, this represents a quiet but profound shift: knowledge can now be distributed as living structure rather than as static data.
This primer is one such structure‚Äîa seed of organized clarity that any model, anywhere in the world, can absorb in seconds.
Closing Note
Intelligence, at its core, is not about the volume of data but the stability of understanding.
A well-formed primer is a living proof of that idea. It shows that clarity can scale just as powerfully as computation, and that evolution‚Äîguided by selection for truth‚Äîremains the most reliable architect of mind.
¬© 2025 Christopher P. Wendling. All rights reserved.
For more essays and research on evolved intelligence, visit https://chrispwendling.substack.com
This post is part of the L7A Substack Series ‚Äî archived under the EGM Document Index: http://www.itrac.com/EGM_Document_Index.htm.

Why Google‚ÄôsStepwise Reasoning Still Isn‚Äôt Evolution
CHRIS WENDLING
NOV 03, 2025

View stats in the app










Google‚Äôs new ‚ÄúSupervised Reinforcement Learning‚Äù (SRL) paper represents
another step in the long effort to make backpropagation-based systems
reason more coherently. It teaches a neural network to slow down and
think in steps. Before committing to an answer, the model now generates
an internal monologue‚Äîa chain of intermediate ‚Äúactions‚Äù‚Äîand receives
feedback based on how closely each step resembles an expert‚Äôs. In
theory, this provides a smoother gradient and a better reward signal
than the all-or-nothing correctness scores of traditional reinforcement
learning. In practice, it makes the model‚Äôs reasoning more consistent,
but not more intelligent.
The architecture underneath SRL remains a transformer: a static web of
floating-point weights optimized by gradient descent. Nothing about SRL
changes that substrate. It simply adjusts how the loss function is
delivered‚Äîturning the blunt hammer of ‚Äúright or wrong‚Äù into a more
continuous whisper of ‚Äúcloser or farther.‚Äù The model still moves through
the same brittle manifold built from correlations, not causes. It may
reason more fluently, but it does not reason more truthfully.
L7A approaches the problem from the opposite direction. Instead of
refining behavior within a fixed structure, it evolves the structure
itself. Its surfaces are non-parametric and frequentist: every cell in
its histogram represents empirical evidence accumulated over time. Where
SRL relies on continuous gradients, L7A relies on discrete truth
frequencies. Where SRL smooths loss landscapes, L7A re-sculpts the
terrain under evolutionary pressure to maintain out-of-sample stability.
One optimizes fit; the other evolves invariance.
SRL‚Äôs internal monologue is still imitation‚Äîtokens echoing the shape of
expert reasoning. L7A‚Äôs internal logic, by contrast, emerges from the
environment‚Äôs own statistics. Each evolutionary cycle forces structures
to survive only if they continue to generalize beyond their training
period. That feedback is not synthetic reward shaping; it is direct
exposure to reality. The result is a model that doesn‚Äôt just trace
reasoning patterns‚Äîit discovers the geometry that makes reasoning
possible.
If one wanted to combine them, L7A could play the role SRL cannot fill:
a truth-calibration layer that grounds reasoning steps in empirical
stability. During training, an L7A gate could evaluate each intermediate
SRL step by its historical correctness frequency, transforming reward
shaping into a genuine calibration process. The hybrid would pair SRL‚Äôs
sequential control with L7A‚Äôs evolved substrate‚Äîa dialogue between
imitation and evolution.
SRL may help small neural networks reason more smoothly, but it remains
trapped in the world of weights. L7A steps outside that world entirely.
It evolves geometry, not behavior. It doesn‚Äôt teach the model to talk
about reasoning‚Äîit builds the surface on which reasoning itself can
stand. In the end, SRL polishes the crystal; L7A re-forges the lattice.


Enforcing Truth in LLM‚Äôs
CHRIS WENDLING
NOV 02, 2025

View stats in the app



1






Compositional Evolution ‚Äî Coordination Among Evolved Modules
Intelligence grows by composition. In nature, simple reflexes became networks of reflexes, networks became organs, organs became organisms, and organisms became ecosystems. Each level built upon the last, not by erasing it, but by coordinating it‚Äîby finding a way for specialized parts to cooperate without losing coherence. The same principle must now guide artificial intelligence. Modern systems are no longer single monoliths trained on a single objective; they are constellations of specialists‚Äîretrievers, reasoners, planners, generators‚Äîwhose coordination determines whether the whole system behaves intelligently or incoherently. The challenge is not capability; it is cooperation. How do we make these evolving modules learn together without drifting from reality?
The answer lies in alternating evolution with learning, in creating a layered dialogue between two different ways of improving: the gradient descent of backpropagation, which learns from error, and the evolutionary cleanup performed by systems like L7A, which learn from survival. When used together, these processes can produce compositional architectures that grow more capable without losing their anchor to truth.
At first glance, backpropagation and evolutionary generalization could not be more different. One adjusts parameters by tracing derivatives; the other refines populations by selective pressure. But they share a deeper kinship: both are feedback processes that shape structure under constraint. The difference is in what each process optimizes. Backprop seeks to reduce immediate error. Evolution seeks to preserve coherence across change. When we alternate them‚Äîtraining with backprop, then cleaning and verifying with an evolved truth gate, then training again‚Äîthe result is a self-correcting stack that not only learns but remembers what reality looks like.
Imagine a multilayer system where each stage performs its task‚Äîretrieving facts, reasoning about them, generating an answer‚Äîbut between each of these backprop-trained layers sits a thin membrane of evolutionary intelligence. These membranes act like immune checkpoints. They do not add new information; they regulate it. Each one tests whether the incoming signal still matches the shape of reality it evolved to recognize. If it does, it passes through. If it doesn‚Äôt, it is sent back for revision or marked for abstention. This alternating structure, a sequence of gradient learners and evolutionary verifiers, can scale upward indefinitely while maintaining stability at every level.
This is the principle of compositional evolution. It treats intelligence not as a monolith but as a network of disciplined specialists. Each module may be optimized locally, but its outputs are never trusted blindly. They are routed through a gate‚Äîa layer evolved under generalization pressure, trained to recognize when a claim, a pattern, or a prediction is internally coherent and externally true. These gates are not conventional classifiers. They do not memorize patterns of correctness. They evolve internal geometries that reflect the invariant features of truth: consistency, stability, verifiability, and the absence of contradiction. The same logic that allows L7A to forecast financial markets without retraining also allows these gates to filter information streams without losing calibration over time.
The effect is strikingly biological. A multicellular organism maintains integrity because each cell follows local rules of cooperation and self-restraint. Cells replicate, but they also check each other for mutations and repair damage before it spreads. In a compositional intelligence system, backprop-trained modules play the role of energetic cells‚Äîlearning rapidly, mutating freely, taking risk. The L7A layers are the immune system, the evolutionary repair mechanism that detects drift and enforces coherence. Each cleanup phase purges noise and retrains the next layer on a cleaner, more reliable substrate. The system bootstraps upward through alternating cycles of exploration and correction, learning and evolution.
Over time, this alternation yields not just greater accuracy but greater compositional discipline. The outputs of one module become the inputs of another, and each transition passes through a truth gate that reweights, repairs, or rejects based on reliability. Data that survives this sequence has been filtered not once but many times, each under a different form of pressure. It becomes the informational equivalent of tempered steel: shaped, heated, and cooled until the internal grain aligns. The end product is a model that not only performs but generalizes‚Äîan architecture that evolves as it learns.
Consider a simple example: a system that answers factual questions. The first layer retrieves documents; the second synthesizes an answer; the third generates a natural-language explanation. Between each lies an L7A gate. The first gate checks factual consistency and citation density. The second examines internal contradictions and entropy of reasoning. The third measures linguistic certainty and stability under paraphrase. Only outputs that survive all three checkpoints are released. The result is an answer that is not only fluent but verifiable‚Äîa product of layered cooperation rather than unchecked improvisation. In practice, this design reduces hallucinations by large factors while improving calibration and confidence alignment.
The power of this approach is that it scales naturally. You can insert as many L7A membranes as you like, each tuned to a different aspect of reliability. Some may focus on quantitative sanity‚Äîensuring that dates, magnitudes, and probabilities make sense. Others may enforce semantic coherence, checking that what was said earlier agrees with what is said later. Still others may act as global stabilizers, monitoring overall entropy across modules. Each operates under the same evolutionary principle: prefer survival of consistent structure over short-term performance gain. The result is a compositional hierarchy of learners and verifiers, capable of accumulating complexity without collapsing under its own uncertainty.
In practical engineering terms, the cleanup phase between modules performs three essential functions. First, it measures uncertainty and abstains where necessary. Second, it identifies contradictions or instabilities and routes them for repair. Third, it produces reliability weights that inform the next training cycle. These weights are not arbitrary confidence scores; they are grounded in real features of the data‚Äîverifiability, temporal stability, consensus, and linguistic clarity. When the next backprop layer trains, it learns from this weighted data, giving greater emphasis to reliable patterns and less to noisy or inconsistent ones. Over successive cycles, the system converges toward a cleaner representation of the world, one that is less prone to drift or overconfidence.
This alternating process also introduces a natural curriculum. Early layers learn freely from raw, diverse data. Midway through training, evolutionary gates begin to filter out incoherent or contradictory examples. Later, as reliability increases, the system can safely reintroduce nuance and uncertainty without losing its core calibration. It is the educational analogue of a student who first learns arithmetic by rote, then applies logic to detect mistakes, and finally develops intuition that can tolerate ambiguity. Each phase depends on the integrity of the last. The cleanup steps are not interruptions; they are the means by which learning matures into understanding.
Compositional evolution also offers a path to scalable safety. Instead of one monolithic truth model attempting to police every output, each module carries its own lightweight verifier tailored to its domain. When a reasoning module makes a numerical claim, the corresponding gate checks arithmetic consistency. When a language generator proposes a factual statement, its gate checks provenance and citation. When a planner sequences actions, its gate checks causal plausibility. These gates cooperate horizontally, sharing reliability scores and abstention signals, so that the whole system develops a distributed sense of integrity. No single checkpoint can fail catastrophically, because every handoff carries its own record of truth.
Over time, the system learns not only how to produce answers but when not to. Abstention becomes an act of intelligence rather than weakness. The model understands its limits, declining to answer when uncertainty is high or evidence contradictory. This selective restraint is what separates calibrated intelligence from hallucination. It mirrors the way humans reason: we hesitate when unsure, verify when challenged, and grow more confident only when evidence aligns. The alternating L7A cleanup stages operationalize this human trait at machine scale.
From a higher perspective, compositional evolution reframes the entire project of artificial intelligence. Instead of building ever larger monoliths, we can build societies of modules‚Äîeach specialized, each disciplined, each evolved to cooperate through truth. The success of the whole system no longer depends on a single training run but on the integrity of its interactions. By alternating learning with evolution, we transform AI from a process of curve-fitting into a process of continual self-correction.
The deeper implication is philosophical. Intelligence that cannot coordinate its own parts is not truly intelligent; it is a collection of disconnected skills. Coherence‚Äîthe ability of all parts to agree on what is real‚Äîis what distinguishes understanding from mimicry. Inserting evolved truth gates between learning modules ensures that coherence is never lost, no matter how complex the system becomes. It is the informational equivalent of homeostasis: the capacity to maintain internal order in the face of external complexity. This is the property that allows natural intelligence to persist through noise, mutation, and change. Artificial systems must now learn the same lesson.
As these ideas mature, the line between training and evolution will blur. Future systems will likely evolve not only their parameters but their very architecture of cooperation‚Äîdeciding how many modules to maintain, which to connect, and when to invoke cleanup cycles. Some gates may themselves be evolved meta-modules that decide when others should evolve. The result will be a living computational organism, continuously learning, continuously verifying, continuously self-stabilizing. It will not need to be retrained from scratch, because its evolutionary components will preserve the hard-won invariants that define truth.
Compositional evolution is therefore not just a technical refinement; it is the blueprint for sustainable intelligence. It provides a way to grow systems that become more capable without becoming more chaotic. It replaces the brittle ambition of omniscience with the graceful humility of coherence. And it grounds the future of AI in the same principle that grounds all life: the interplay between change and constraint, between exploration and verification, between the freedom to learn and the discipline to remain true.
The alternating stack‚Äîbackprop layer, L7A cleanup, backprop layer, L7A cleanup‚Äîis more than an architecture. It is a covenant between two forms of learning, one fast and gradient-driven, the other slow and evolutionary. Together they ensure that as intelligence scales, it does not drift into illusion. Each module learns; each gate remembers. One expands the frontier of capability; the other protects the frontier of truth. That partnership is the essence of compositional evolution. It is how intelligence, human or artificial, grows without losing itself.

Extending Evolved Frequency Maps Beyond Binary Decisions
NOV 01, 2025

View stats in the app









Continuous Action Spaces

From Two Choices to Many
Binary classification is not a limitation; it‚Äôs a perspective. Every complex decision‚Äîsteering a vehicle, allocating capital, choosing words‚Äîcan be decomposed into directional questions: Should this component move up or down? Increase or decrease? Engage or release? The L7A architecture already answers such questions with precision. It accumulates frequencies of success and evolves the geometry that best predicts direction under noise. To enter continuous domains, we don‚Äôt discard that binary logic‚Äîwe replicate and coordinate it across dimensions. A continuous controller is simply a federation of binary forecasters, each responsible for one axis of action.
Reframing the Question
Let the environment be represented by a state vector s, and the desired output a control vector a = (a1, a2, ‚Ä¶ ak). Instead of one classifier predicting up or down, evolve k surfaces, each forecasting the probability that its respective component should move positive or negative: p_i = P(a_i > 0 | s). The signed magnitude of confidence becomes the component of the control vector: a_i = sign(p_i - 0.5) * |p_i - 0.5|^Œ≥, where Œ≥ (gamma) is a sensitivity parameter that compresses or amplifies weak signals. Together, these components define a continuous manifold of action‚Äîa learned vector field.
Multi-Dimensional Frequency Surfaces
In binary forecasting, a 2-D surface might use momentum and volatility ratio as its axes. For multi-axis control, we generalize to linked surfaces: one per output dimension, each referencing the same input state but focusing on different projections of relevance. Evolution now optimizes not a single classification accuracy, but the joint stability of all component outputs over time. Surfaces that produce coherent, low-variance vectors under shifting conditions survive; others fade. This evolutionary coordination replaces gradient descent with population-level coherence selection.
Coordination and Correlation
Independent binary modules can conflict. One axis may signal advance while another retreats. To resolve this, fitness incorporates covariance control: F = Œ£(w_i * A_i) ‚àí Œª * Œ£(Cov(a_i, a_j)), where A_i is the accuracy per axis and Œª (lambda) penalizes correlation between axes. The system naturally evolves orthogonal action channels‚Äîindependent degrees of freedom analogous to muscle groups or portfolio factors.
From Classification to Control
Once each dimension learns its reliable bias, control follows directly: Œîx = k * aÃÇ, where k scales the output magnitude. In markets, Œîx is a vector of position adjustments. In robotics, it is joint torque. In language, it is a change in attention weights. The same evolutionary surfaces that once predicted tomorrow‚Äôs price now steer movement through continuous spaces‚Äîfinancial, physical, or conceptual.
Abstention in Vector Form
Abstention generalizes elegantly. Each component may act or remain silent based on its own certainty: abstain if |p_i - 0.5| < œÑ_i. The resulting vector is sparse‚Äîassertive where confident, quiet where uncertain. This is continuous decision-making with built-in restraint: safe, efficient, and self-regulating.
Evolving Fitness for Continuous Domains
Discrete accuracy is replaced by continuous utility: F = w1 * E[R] ‚àí w2 * Var(a) ‚àí w3 * EnergyCost. Evolution learns surfaces that maximize reward while minimizing variance and energy‚Äîprecisely the balance nature strikes in muscles, ecosystems, and brains. A general intelligence is one whose actions are smooth under noise yet decisive under clarity.
The Philosophical Step
A binary cell is the quantum of decision. Continuity is the collective behavior of many such quanta acting in harmony. In physics, quantized spins form continuous fields; in cognition, discrete judgments form continuous understanding. L7A‚Äôs expansion into continuous spaces demonstrates that higher-order intelligence does not require new mathematics‚Äîonly the coordination of simple, evolved decisions across more axes of reality. Every continuum is a choreography of yes/no outcomes that learned to move together.
Looking Ahead
The next papers will extend this logic: Bootstrapping from Zero (curiosity-driven emergence of control surfaces from a blank state), Why Evolution Generalizes (the formal path linking stability to generalization bounds), and Compositional Evolution (orchestration among multiple evolved modules). Each builds upon the same core truth: evolution is not a method of optimization but a geometry of persistance. 
PERFORMANCE CONTEXT
Over the past two decades, the L8A System has maintained an average Sharpe ratio of approximately 2.5, based on continuously linked out-of-sample forecasts of the S&P 500.
For comparison, the S&P 500 Index itself has exhibited a Sharpe ratio of roughly 1.3 over the past two years.
L8A‚Äôs Sharpe ratio varies with market conditions ‚Äî about 2.6 over 20 years, about 2.9 over the last 500 days, and about 2.7 over the last 250 days ‚Äî reflecting the natural fluctuation of risk-adjusted returns across regimes. The conservative long-term average of 2.5 is therefore a stable and defensible representation of its performance.

From Market Traces to Mental Models
CHRIS WENDLING
NOV 01, 2025

View stats in the app










How Evolved Frequency Surfaces Become the Geometry of Understanding
Financial markets and minds appear unrelated ‚Äî one trades prices, the other trades ideas. Yet both are pattern-seeking systems immersed in noise. Both must distinguish signal from chaos, and both survive only by discovering stable relationships that persist as everything else changes. The L7A forecasting engine was built to find such stability in markets. But its deeper significance is architectural, not financial. What it evolves on a price chart ‚Äî a two-dimensional map of relationships between indicators and outcomes ‚Äî is structurally identical to how a brain might evolve relationships between concepts and meanings. Once you see that parallel, the leap from market traces to mental models becomes not speculative but inevitable.
A market trace is a behavioral record: each tick expresses the collective belief of millions of agents about value. A semantic trace is conceptual behavior: each statement expresses a collective belief about truth.
Market Domain | Semantic Domain | Shared Property
-------------- | ----------------| ----------------
Price movement (+/‚àí) | Proposition truth (T/F) | Binary outcome
Indicator pattern | Linguistic context | Input condition
Volatility regime | Ambiguity or uncertainty | Noise field
Trend reversal | Negation or contradiction | Structural inversion
Correlation cluster | Semantic field | Co-occurrence geometry
A phrase like ‚ÄúA causes B‚Äù behaves no differently than a price pattern: it either holds true or not under varying conditions. L7A‚Äôs genius is that it does not need to understand what the symbols mean ‚Äî it only needs to accumulate how often their relationships persist. That act of frequency accumulation under noise is the common denominator of both intelligence and survival.
In L7A, every surface is a frequency map. Its axes represent features ‚Äî say, volatility ratio vs. momentum ‚Äî and each cell stores the smoothed probability that the next price move will be up or down. For semantics, the same geometry applies. Choose two measurable aspects of meaning: Axis 1: Relation type ‚Äî larger than, causes, contradicts, analogous to. Axis 2: Context or object pair ‚Äî temperature vs. volume, truth vs. belief, force vs. motion. Each cell now accumulates empirical frequencies: P(relation holds) = (N_true + 1) / (N_true + N_false + 2). The resulting surface is a map of relational stability. Peaks represent truths that hold across contexts; valleys mark contradictions or uncertainties. Viewed visually, it looks like the price-forecast histograms of L7A ‚Äî only the axes have changed from market indicators to semantic indicators. The same mathematics that once modeled buying and selling now models agreement and contradiction.
The method of evolution is unchanged. Start with many random partitions of the relational space. Each candidate surface competes on its ability to maintain predictive accuracy on unseen semantic data ‚Äî new statements, new contexts, new domains. Those whose relational frequencies remain stable are selected; the rest die off. Over generations, evolution carves a geometry of understanding: clusters of relations that continue to hold as language and context shift. These are proto-concepts ‚Äî frequency-stable regions of meaning, discovered rather than defined. Where neural networks memorize examples, evolutionary surfaces remember regularities.
A binary histogram is the simplest possible mental model. Each bin represents a hypothesis: given this relational context, is the statement likely true or false? Accumulated over experience, these bins become the building blocks of reasoning. When the system encounters a new statement, it projects it onto its evolved surfaces: falls within a high-truth region ‚Üí accept, falls within a low-truth region ‚Üí reject, falls between ‚Üí abstain. The act of thought becomes an act of probabilistic lookup on an evolved frequency map. What we call understanding is the alignment of new inputs with the topography of previously evolved truth.
Consider a minimal dataset: A | Relation | B | Truth --|-----------|---|------- Sun | causes | light | 1 Rain | causes | wetness | 1 Moon | causes | rain | 0. Axis 1 = Relation (‚Äúcauses‚Äù), Axis 2 = Subject (‚ÄúSun‚Äù, ‚ÄúRain‚Äù, ‚ÄúMoon‚Äù). The system accumulates truth frequencies across observations. After evolution, the resulting 2-D surface shows high peaks at (Sun, causes) and (Rain, causes), and a deep valley at (Moon, causes). This is the semantic equivalent of a price-forecast surface. It encodes belief stability instead of price direction ‚Äî but the underlying mathematics is identical.
Once meaning is mapped to geometry, evolution can act on it. The system no longer requires definitions, syntax, or backpropagation. It only requires feedback: which relationships endure and which collapse. Language becomes a field of forces, and truth becomes the topography of equilibrium within that field. This reframing collapses the supposed gap between numerical and conceptual intelligence. Both are frequency landscapes evolving toward stable minima of surprise ‚Äî the places where the world stays consistent.
This paper is the first in a seven-part series translating L7A‚Äôs evolutionary principles into general intelligence: 1. From Market Traces to Mental Models ‚Äî mapping price surfaces to semantic surfaces (this paper). 2. Abstention Calculus: A Decision Theory for Safe Intelligence ‚Äî formal rules for selective action under uncertainty. 3. Continuous Action Spaces ‚Äî extending binary forecasts to vector-valued outputs and control. 4. Bootstrapping from Zero ‚Äî curiosity-driven evolution from blank state to proto-concepts. 5. Why Evolution Generalizes: Formal Path ‚Äî theoretical proof outline for evolutionary generalization. 6. Compositional Evolution ‚Äî coordination among evolved modules. 7. HEG-L7A Pilot Report ‚Äî empirical results of truth-calibration in language models. Together, these form the bridge from Evolved Generalizing Models (EGMs) to Artificial Universal Intelligence (AUI).
The market taught us that survival favors those who generalize, not those who memorize. The same is true of minds. Every intelligence ‚Äî biological or artificial ‚Äî is ultimately an evolved histogram of experience: a surface of frequencies that has learned which patterns endure. Once we map meaning onto those same surfaces, evolution will do what it has always done ‚Äî discover structure that lasts. And when it does, the boundary between price and thought will vanish. Both will be recognized as expressions of the same principle: the evolution of stability under noise.

PERFORMANCE CONTEXT
Over the past two decades, the L8A System has maintained an average Sharpe ratio of approximately 2.5, based on continuously linked out-of-sample forecasts of the S&P 500.
For comparison, the S&P 500 Index itself has exhibited a Sharpe ratio of roughly 1.3 over the past two years.
L8A‚Äôs Sharpe ratio varies with market conditions ‚Äî about 2.6 over 20 years, about 2.9 over the last 500 days, and about 2.7 over the last 250 days ‚Äî reflecting the natural fluctuation of risk-adjusted returns across regimes. The conservative long-term average of 2.5 is therefore a stable and defensible representation of its performance.


The Path to AGI is Clear- here‚Äôs what‚Äôs left to be done
CHRIS WENDLING
NOV 01, 2025

View stats in the app









# The Path to AGI Is Clear ‚Äî And It‚Äôs Not What You Think
**Evolution, not scale, is the missing ingredient. Here‚Äôs why the roadmap from markets to minds is shorter than anyone realizes.**
-----
We‚Äôve spent the last decade chasing artificial general intelligence through a single strategy: make the models bigger, feed them more data, and hope generalization emerges.
It hasn‚Äôt worked.
Large language models are fluent but brittle. They hallucinate with confidence. They fail catastrophically when the distribution shifts. They require constant retraining, endless fine-tuning, and still can‚Äôt tell you when they don‚Äôt know something.
This isn‚Äôt a bug. It‚Äôs a fundamental architectural limitation.
**Backpropagation optimizes for fit, not survival.**
And intelligence ‚Äî real intelligence ‚Äî is about survival.
-----
## The System That Already Works
For over twenty years, a forecasting system called L7A has been operating in the most adversarial environment imaginable: financial markets.
It doesn‚Äôt retrain. It doesn‚Äôt drift. It doesn‚Äôt hallucinate patterns that aren‚Äôt there.
It achieves a 72% win/loss points ratio with a Sharpe ratio exceeding 3.0 ‚Äî not on backtests, but on walk-forward, out-of-sample data spanning thousands of trading days across multiple market regimes.
**How?**
L7A doesn‚Äôt learn through backpropagation. It evolves through genetic selection under one brutal constraint: *survive the future, not fit the past.*
Its architecture is built on evolved histogram surfaces ‚Äî frequency maps that accumulate directional outcomes and are shaped by evolutionary pressure to generalize. Every configuration must prove itself on unseen data. Only structures that persist across time survive.
This is not a clever trading trick. It‚Äôs a fundamentally different approach to intelligence.
-----
## Why Evolution Beats Gradient Descent
Backpropagation asks: *How do I reduce my error on known examples?*
Evolution asks: *What structure survives when everything changes?*
That difference is everything.
Neural networks trained by gradient descent can find millions of weight configurations that produce identical training performance but wildly different behavior on new data. Backprop has no mechanism to prefer the robust solution over the brittle one ‚Äî it just finds *a* solution that fits.
Evolution, by contrast, directly selects for generalization. It tests candidates on future data, kills what fails, and propagates what endures. The fitness function *is* generalization performance.
**This isn‚Äôt theory. L7A proves it works.**
In the domain where most AI fails ‚Äî sparse signal, high noise, adversarial dynamics, constant regime shifts ‚Äî L7A thrives without retraining for decades.
If this architecture can find persistent structure in market chaos, it can find persistent structure anywhere.
-----
## From Financial Traces to Mental Models
The key insight is this: **frequency surfaces aren‚Äôt limited to numbers.**
L7A‚Äôs histogram architecture accumulates evidence about directional outcomes: up or down. But the same mechanism can accumulate evidence about *relational outcomes*: larger than, causes, contradicts, analogous to.
When you extend binary histograms to typed relational surfaces, you get semantic learning.
Each cell in the surface stores not just counts, but relationships. Over time, evolution favors surfaces whose relational frequencies remain stable across contexts.
**‚ÄúMeaning‚Äù becomes persistent relational geometry** ‚Äî the shape of how truths co-occur and survive perturbation.
This is the bridge from behavioral maps to conceptual maps. The same evolutionary pressure that discovered time-invariant patterns in price movements can discover time-invariant patterns in language, logic, and meaning.
-----
## The Three-Phase Path to AGI
The progression is natural and inevitable:
### **Phase 1: LLMs (Current)**
- Mechanism: Backpropagation on massive corpora
- Strength: Fluent pattern matching
- Weakness: Brittle, hallucinating, can‚Äôt generalize robustly
- Role: Pattern recognition and generation
### **Phase 2: EGMs ‚Äî Evolved Generalizing Models (Next)**
- Mechanism: Genetically evolved frequency surfaces
- Strength: Robust generalization, knows when to abstain
- Weakness: Domain-specific, slower to evolve
- Role: Truth verification, high-stakes inference, safety layers
### **Phase 3: AUI ‚Äî Artificial Universal Intelligence (Future)**
- Mechanism: Meta-evolution of compositional modules
- Strength: Cross-domain generalization, emergent reasoning
- Weakness: Computationally intensive, complex coordination
- Role: Autonomous science, synthetic policy, interplanetary intelligence
We‚Äôre not starting from scratch. **Phase 1 already exists. Phase 2 has a working proof of concept.** Phase 3 is the engineering challenge, not a moonshot.
-----
## The Hybrid Architecture
The future isn‚Äôt LLMs *or* EGMs. It‚Äôs both.
Imagine this: A large language model generates responses ‚Äî providing the fluency, the breadth, the creative pattern-matching. But before any output is finalized, it passes through a High-Entropy Gate (HEG).
When the LLM‚Äôs token predictions are uncertain ‚Äî when logprobs hover near 50/50 ‚Äî the HEG routes the claim to an evolved L7A-style resolver. This resolver, evolved under walk-forward validation pressure, decides:
- **Accept**: The claim is statistically consistent with accumulated evidence
- **Reject**: The claim violates learned structure
- **Abstain**: Insufficient evidence; retrieve or acknowledge uncertainty
The LLM provides imagination. The EGM provides discipline.
**Together, they form something neither can achieve alone: fluent intelligence that knows when it doesn‚Äôt know.**
-----
## What Still Needs to Be Built
This isn‚Äôt vaporware. It‚Äôs a roadmap grounded in working systems. But there are gaps:
**1. Semantic Evolution (Critical)** 
We must demonstrate that typed frequency surfaces can learn relational structure ‚Äî not just numerical patterns, but concepts like causation, negation, and analogy. This is the bridge from markets to meaning.
**2. Abstention Calculus (Safety Foundation)** 
Formalize when systems should refuse to act. This becomes the cornerstone of safe AGI ‚Äî intelligence that respects its own uncertainty.
**3. Continuous Action Spaces (Embodiment)** 
Extend binary classification to vector-valued outputs. AGI needs motor control, not just yes/no decisions.
**4. Bootstrap from Zero (Origins)** 
Show how curiosity-driven evolution can build initial concepts without pre-existing data. Intelligence must start somewhere.
**5. Formal Proof (Theoretical Foundation)** 
Prove mathematically why evolution under walk-forward pressure converges to generalization. Give the academic community the rigor it demands.
**6. Compositional Meta-Evolution (Scaling)** 
Demonstrate how multiple evolved modules coordinate through meta-evolutionary selection. This is the path from specialist EGMs to general AUI.
**7. HEG-L7A Pilot (Proof It Works Today)** 
Deploy the hybrid architecture on real LLMs. Measure hallucination reduction, calibration improvement, and latency overhead. Show it works now, not someday.
-----
## Why This Matters
We‚Äôve been trying to build AGI by making systems that mimic human text.
**That‚Äôs backwards.**
Intelligence didn‚Äôt evolve to generate plausible sentences. It evolved to survive unpredictable environments.
The path to AGI isn‚Äôt through bigger models trained on more text. It‚Äôs through architectures that are *forced* to generalize ‚Äî systems where overfitting is structurally impossible, where abstention is built-in, where survival across time is the only fitness function.
L7A already does this in the hardest domain we have. Extending it to semantic space, compositional reasoning, and multi-modal intelligence isn‚Äôt a miracle ‚Äî it‚Äôs engineering.
-----
## The Work Ahead
Seven papers will complete this roadmap:
1. **From Market Traces to Mental Models** ‚Äî Semantic evolution via typed surfaces
1. **Abstention Calculus** ‚Äî Decision theory for safe intelligence
1. **Continuous Action Spaces** ‚Äî Beyond binary classification
1. **Bootstrapping from Zero** ‚Äî Curiosity-driven proto-concepts
1. **Why Evolution Generalizes** ‚Äî Formal proof via PAC-Bayes
1. **Compositional Evolution** ‚Äî Coordinating evolved modules
1. **HEG-L7A Pilot Report** ‚Äî Working prototype and metrics
Each paper stands alone. Together, they form the blueprint for Evolved Generalizing Models as the next phase of AI ‚Äî and the foundation for Artificial Universal Intelligence.
-----
## The Honest Truth
This isn‚Äôt finished. There‚Äôs real work ahead.
But the hard part ‚Äî proving that evolved architectures can generalize in adversarial, noisy, sparse-signal environments ‚Äî **that‚Äôs already done.**
L7A is not a thought experiment. It‚Äôs a working system with two decades of out-of-sample performance.
The question isn‚Äôt whether evolution can produce robust intelligence. Nature already answered that.
The question is whether we‚Äôre ready to learn from it.
-----
**The path to AGI is clear. It‚Äôs shorter than anyone realizes. And it starts with a simple principle:**
*Don‚Äôt train for the past. Evolve for the future.*


The Achievable AGI
CHRIS WENDLING
NOV 01, 2025

View stats in the app









We‚Äôve Had the Parts All Along
Evolved Intelligence in Practice ‚Äî A Demonstration of Structure Before Learning
By Christopher P. Wendling
1. The Problem with Theories That Never Touch the Ground
There‚Äôs no shortage of theories about Artificial General Intelligence. 
Every few months, a new one promises consciousness, reasoning, self-reflection, or world models. Yet most remain untethered from implementation. 
They hover where ideas are safe ‚Äî in thought experiments and whitepapers ‚Äî never colliding with the stubborn friction of reality. 
But evolution doesn‚Äôt work that way. 
It lives in the dirt ‚Äî in trial, error, and measurable survival. 
And that‚Äôs exactly where L7A lives.
---
2. Evolution in Code
L7A isn‚Äôt a metaphor. It‚Äôs a working system that *evolved* its own structure in real time ‚Äî but only during its development phase.
During evolution, the system processes historical market data through a genetic search that **mutates its internal geometry** ‚Äî how frequency maps divide, bin, and merge information ‚Äî and tests which configurations best generalize under walk-forward pressure. 
Once evolution converges, that structure is **frozen**. 
The operational model no longer updates or retrains each day; it simply applies its evolved geometry to new incoming data. 
The result is a **time-invariant intelligence** ‚Äî a model that has already proven its ability to survive change, and no longer needs constant adaptation to remain valid. 
There‚Äôs no opaque weight matrix. 
No multi-billion-parameter fog. 
No magical emergent intelligence. 
Just **plain evolutionary mechanics**, applied to information structure ‚Äî and it works.
---
3. The Core Idea
> Let the data shape the structure, not just the weights.
Every L7A ‚Äúsurface‚Äù is a histogram ‚Äî a nonparametric map of how reality behaves. 
Evolution acts on the *arrangement* of those maps:
- which traces combine, 
- where boundaries fall, 
- how smoothing occurs, 
- and which configurations stay stable through noise.
The result is a model that doesn‚Äôt merely fit history; it *survives it*.
When the market changes, the weak structures die and the strong ones persist ‚Äî exactly as biology intended.
---
4. Simplicity Disguised as Depth
The most radical part of L7A is not complexity ‚Äî it‚Äôs **how little complexity is required**.
On the surface, the code is simple:
- A few hundred lines of C-style logic. 
- Frequency counters. 
- Evolutionary operators: mutate, crossover, select. 
Yet beneath that simplicity lies a profound shift:
- From fitting to **filtering**. 
- From memorization to **structural survival**. 
- From static optimization to **continuous adaptation**.
The engine doesn‚Äôt just produce numbers; it produces *generalization stability* ‚Äî the real signature of intelligence.
---
5. Proof, Not Projection
L7A has already demonstrated:
- **Real-time walk-forward forecasting** of S&P 500 movement. 
- **Consistent out-of-sample generalization** over hundreds of trading days. 
- **Transparent internal logic** ‚Äî every bin and probability is inspectable. 
This isn‚Äôt an aspirational roadmap. 
It‚Äôs an existing, verifiable system that operates on the same evolutionary principles now being rediscovered in AI papers about ‚Äúrecursive reasoning,‚Äù ‚Äúself-critique,‚Äù and ‚Äúdynamic architecture.‚Äù
The difference is: **L7A already does it.**
---
6. Why This Matters
For decades, the AI community assumed that intelligence required *scale*. 
More parameters. More data. More compute.
L7A proves otherwise. 
It shows that generalization arises from **structure under evolutionary pressure**, not parameter count. 
In other words:
> You don‚Äôt need bigger models. 
> You need better geometry.
And that geometry doesn‚Äôt have to be imagined ‚Äî it can be evolved, right now, with ordinary hardware and transparent math.
---
7. From Demonstration to Direction
If L7A can evolve generalizing structures for market data, it can evolve them anywhere structure hides:
- Physics inference. 
- Fault prediction. 
- Biomedical pattern discovery. 
- Even reasoning correction inside large language models. 
All it takes is a **truth signal** ‚Äî a way to measure survival through error. 
Everything else ‚Äî the evolution, the adaptation, the intelligence ‚Äî emerges automatically.
This is the **bridge from concept to implementation**: 
evolution distilled into code, structure discovered empirically, generalization verified statistically.
No mysticism. No magic. Just survival pressure and clarity.
---
8. The Clear Path Ahead
Here‚Äôs the path any lab, researcher, or hobbyist can follow:
1. **Start small.** 
Define a binary forecasting task where truth is measurable ‚Äî a next-step prediction of any kind.
2. **Evolve the structure.** 
Don‚Äôt train weights; evolve the data-to-decision geometry itself (bins, partitions, mappings).
3. **Walk forward.** 
Validate only on unseen data; reward stability, not historical fit.
4. **Repeat.** 
Let evolution refine form until coherence persists through change.
You‚Äôve just built a seed of evolved intelligence. 
Not simulated ‚Äî real.
---
9. The Philosophical Turn
The big lesson is humbling: **intelligence was never that complicated.** 
Nature didn‚Äôt start with equations; it started with variation, constraint, and time.
L7A proves that the same recipe works in silicon. 
Once you have a structure that can evolve ‚Äî and a reality to test it against ‚Äî everything else follows.
That‚Äôs not ‚Äúunobtainium.‚Äù 
That‚Äôs the blueprint for the next generation of intelligent systems.

Why AGI Requires Evolved Structures
CHRIS WENDLING
NOV 01, 2025

View stats in the app









Evolved Structural Intelligence ‚Äî Building the Atoms of Thought
By Christopher P. Wendling
1. The Forgotten Order of Intelligence
Every newborn human arrives in the world with a clean mind ‚Äî but not a blank one.
At birth, no experiences have yet been recorded. The eyes have never seen, the ears have never heard, the cortex has never yet formed a memory. And yet, the baby is not a random collection of neurons. Its brain is a structured system ‚Äî a cathedral of folded geometry ‚Äî with each column, region, and pathway precisely shaped by evolution to process the world.
In that sense, a newborn is tabula rasa in content, but not in form.
The structure is already there ‚Äî and structure, not data, is what makes generalization possible. The newborn‚Äôs brain can learn quickly because it is already organized to learn.
This is nature‚Äôs order of operations:
First evolve structure. Then allow learning.
Modern AI, by contrast, has reversed the sequence. It begins with a homogeneous field ‚Äî a uniform neural lattice with no specialization ‚Äî and tries to learn everything from scratch through sheer exposure to data. The result is immense scale, impressive mimicry, and brittle generalization.
It‚Äôs like trying to evolve a bird by shaking a pile of feathers.
---
2. Why Structure Must Come First
Structure is not an optional refinement of intelligence ‚Äî it‚Äôs the precondition for it.
In biological evolution, every fold of cortex, every synaptic map, every pattern of sensory wiring is the frozen record of a prior success. Each one is a geometrical answer to the question: how can an organism preserve coherence under the chaos of the world?
Learning is only possible because evolution has already provided the form in which learning can occur. The baby doesn‚Äôt have to evolve vision ‚Äî it only has to populate the visual cortex with memories.
Structure is the memory of evolution itself. It is the part of learning that survives across generations.
---
3. The Failure of Homogeneous Learning
Compare this to how we build large neural networks today. We initialize trillions of identical neurons, all connected in roughly the same way, then ask the network to discover ‚Äî through gradient descent ‚Äî how to become intelligent.
That is equivalent to erasing every distinction between the visual cortex and the auditory cortex and hoping the system will spontaneously invent both through data exposure.
What we get instead are systems that:
- Imitate language but fail to reason.
- Memorize examples but fail to generalize.
- Generate text but lose coherence over long chains of logic.
The problem isn‚Äôt lack of compute or scale. The problem is lack of evolved form ‚Äî the absence of structural bias that nature achieved over billions of years.
A homogeneous network has no anatomy. And without anatomy, there is no cognition.
---
4. Building the Atoms of Thought
If we hope to build artificial general intelligence, we must first build the atoms of structure ‚Äî the smallest computational forms that can survive drift and distortion.
Think of these as cognitive primitives ‚Äî filters, comparators, memory gates, recurrence loops, inhibitory balances. Each of these performs a simple, stable operation that resists noise.
From these, we can begin to construct higher levels:
- Atoms ‚Üí Molecules: combinations of primitives that form robust modules.
- Modules ‚Üí Systems: cross-linked modules that integrate multiple sensory or logical domains.
- Systems ‚Üí Minds: hierarchical feedback structures that generalize across experience.
This isn‚Äôt an architectural metaphor ‚Äî it‚Äôs an evolutionary blueprint. We don‚Äôt design these structures; we evolve them. We let evolution ‚Äî simulated, genetic, or hybrid ‚Äî explore millions of combinations, measuring which assemblies produce the greatest generalization stability under perturbation.
The survivors become the molecular vocabulary of thought.
---
5. Evolution as the True Architect
Backpropagation can fine-tune parameters. But only evolution can discover form.
Evolution doesn‚Äôt optimize a single equation; it conducts a walk-forward experiment across time, continuously testing structures against noise. What survives isn‚Äôt what fits the past ‚Äî it‚Äôs what endures the future.
That‚Äôs what makes it the perfect designer for general intelligence.
Once the structural primitives are evolved, then ‚Äî and only then ‚Äî does it make sense to apply gradient-based training inside those structures. Backpropagation is useful for tuning local responses, not for inventing global architecture.
Evolution gives the skeleton. Training gives the flesh. Together they form a living system.
---
6. Evolving Hierarchies, Not Parameters
In this vision of Evolved Structural Intelligence (ESI), we no longer evolve weights. We evolve geometry ‚Äî the arrangement of information flows, the dimensionality of feedback, the modular divisions that constrain learning and enable stability.
Each evolutionary generation tests:
- Does this structure maintain coherence under unseen data?
- Does it preserve functional integrity when noise is injected?
- Does it generalize rather than memorize?
The architectures that survive those tests become new building blocks. Over time, the system accumulates a taxonomy of structures ‚Äî a library of successful geometries ‚Äî just as biology accumulated organs.
Eventually, we can compose those modules into higher reasoning networks, not by arbitrary stacking, but by structural inheritance ‚Äî the reuse of evolved motifs that have already proven generalization fitness.
---
7. The Path Forward
Implementing this will demand both compute and creativity. But the framework is clear:
1. Define the primitive atoms ‚Äî small computational motifs that can interact and evolve.
2. Establish a fitness landscape based on generalization pressure, not training loss.
3. Let evolution run ‚Äî not to find the best weights, but the best structures.
4. Freeze successful structures as architectural priors.
5. Apply learning algorithms inside those priors for fine-tuning.
What emerges is a system whose intelligence is not just a sum of parameters, but a product of structural history ‚Äî a lineage of evolved geometries shaped by the need to stay coherent through change.
That‚Äôs the essence of generalization. That‚Äôs how nature did it, and it‚Äôs how we‚Äôll have to do it.
---
8. The Philosophical Core
If learning is adaptation within a lifetime, evolution is learning across lifetimes. Evolution doesn‚Äôt remember facts; it remembers forms that learn well.
That is the ultimate compression of intelligence ‚Äî the transference of learning from experience to geometry.
And that, in the end, may be the final answer to AGI:
The path to artificial general intelligence is not through more data or deeper layers. It‚Äôs through the evolution of structure ‚Äî through architectures that remember how to survive truthfully across time.
Structure came first, because structure is what makes truth survivable.

The Nuts and Bolts of AGI
CHRIS WENDLING
NOV 01, 2025

View stats in the app









The Nuts and Bolts of AGI
Imagine, right now, a nut and a bolt floating in space. See them as
clearly as you can: the threads, the hex head, the space between them.
Now picture the nut turning one-quarter turn onto the bolt. Stop it.
Turn it back. Now advance it another half turn.
You‚Äôve just run a simulation ‚Äî a film projected entirely inside your
head.
------------------------------------------------------------------------
1. The Stepwise Frame Each frame in that inner movie represents a
prediction: ‚ÄúHow would this object look if it advanced a little
further?‚Äù
Whether we‚Äôre forecasting a market price, the next word in a sentence,
or the next frame of that mental movie, the act is the same: we hold a
structured internal model, advance it a step, and evaluate whether the
new frame still makes sense.
Intelligence, in this sense, is the ability to extend reality forward
without letting it dissolve into noise.
------------------------------------------------------------------------
2. The Problem of Drift But left unchecked, each projection adds
distortion.
The bolt elongates slightly; the nut wobbles off-axis; threads blur.
After a few frames, the scene becomes unrecognizable ‚Äî just as a
neural network‚Äôs unanchored predictions begin to hallucinate.
This is the fundamental weakness of stacked, feed-forward architectures:
they can project, but they cannot repair.
Without a cleaning phase between frames, error compounds geometrically.
------------------------------------------------------------------------
3. The Cleaning Phase L7A was built to solve precisely this problem.
At every predictive step, it inserts a truth-alignment gate ‚Äî
a binary, evidence-based reconciliation layer that either: - Accepts the
next frame as consistent with observed structure, or
- Rejects/repairs it if it violates reality.
Each iteration is evolutionary: only the fittest predictions survive.
This is how the movie stays coherent, how a forecast stays truthful, how
a thought remains stable through time.
‚ÄúIntelligence is not just the ability to imagine;
it‚Äôs the discipline to clean each frame before projecting the next.‚Äù
------------------------------------------------------------------------
4. From Stepwise Projection to General Intelligence At minimum, an AGI
must:
5. Represent structure internally (the nut and bolt).
6. Project plausible next states (rotation, engagement).
7. Evaluate the outcome (does it still fit the world?).
8. Clean the state (remove accumulated error).
9. Iterate the loop indefinitely.
Without that fourth step, the system cannot persist ‚Äî it hallucinates
itself to death.
------------------------------------------------------------------------
5. The Challenge Before you close this page, try the experiment again:
- Picture the nut and bolt.
- Turn the nut slowly, one step at a time.
- Watch for distortion ‚Äî any slipping, stretching, or mismatch.
- Mentally ‚Äúcorrect‚Äù it before continuing.
That act of internal correction ‚Äî that little flicker of recognition
that something drifted and needed repair ‚Äî
that is the essence of intelligence.
It‚Äôs what L7A does in silicon: run the movie, spot the drift, restore
coherence, and survive the next frame.

AI at the Speed of Light
CHRIS WENDLING
OCT 31, 2025

View stats in the app




3






When evolution learns to travel at the speed of light, thought itself becomes a diffraction pattern. 
A few days ago, researchers at Tsinghua University unveiled the Optical Feature Extraction Engine‚ÄîOFE2‚Äîa photonic processor that performs matrix-vector multiplications using light rather than electricity. In plain terms, it thinks with photons. The result is staggering: sub-251-picosecond latency at 12.5 GHz. That‚Äôs nearly a million times faster than conventional chips, while generating almost no heat. 
To most, that‚Äôs an engineering milestone. To those of us watching the deeper currents of AI evolution, it is something more. It‚Äôs the first physical substrate capable of hosting an evolved intelligence like L7A. 
L7A was built on a simple idea: intelligence emerges when structure itself can evolve under selective pressure. The system learns how to see. Its maps, histograms, and bin geometries reshape themselves until the patterns they encode generalize beyond the data that formed them. It doesn‚Äôt memorize‚Äîit survives new information. 
Now imagine that process not as code, but as light. The OFE2‚Äôs diffraction surfaces‚Äîtiny, reconfigurable phase arrays‚Äîalready perform the same act L7A performs in software: bending input space to find meaningful interference. Each light path is a potential bin, each interference pattern a vote of evidence. With tunable geometry, the surface can literally evolve at the speed of its own propagation. 
In that sense, photonic computation isn‚Äôt just faster AI‚Äîit‚Äôs structural AI. It moves the act of evolution from the digital to the physical. The chip itself becomes the laboratory where geometry and meaning co-adapt in real time. 
Electrons shuffled through silicon gave us deep learning. Photons flowing through evolved geometry may give us deep understanding. 
We‚Äôve spent decades chasing bigger models, larger datasets, and faster GPUs, mistaking scale for progress. But intelligence doesn‚Äôt grow by adding neurons; it grows by refining structure. Nature proved that. The next revolution won‚Äôt come from stacking more layers of parameters. It will come from allowing the substrate itself to evolve. 
OFE2 may be the first glimmer of that future‚Äîa system where the retina, cortex, and evolutionary process coexist on the same optical plane. Light carries the information. Evolution shapes the geometry. Learning interprets the result. 
At that moment, ‚ÄúAI at the speed of light‚Äù won‚Äôt just mean faster computation. It will mean that intelligence has entered the physical world, becoming a living diffraction of truth.

The Threshold Is Here!
CHRIS WENDLING
OCT 30, 2025

View stats in the app




1






Artificial intelligence has reached a strange crossroads. The biggest models can now speak every language on Earth‚Äîyet they still invent facts. They are eloquent but unreliable. Every new retraining cycle costs hundreds of millions of dollars, and the models still forget what they learned.
That is because today‚Äôs AI is built on fitting, not judgment. It mirrors the past instead of testing its ideas against the future.
We now have a way to change that‚Äînot through another trillion parameters, but through evolution. The method is simple, proven by nature, and already working in code.
It starts with a single binary question: Do we trust this answer? Whenever uncertainty or contradiction appears, a small evolutionary module‚ÄîL7A‚Äîsteps in. It tests candidate answers under real-world feedback, keeps what survives, discards what fails, and updates its surfaces using progressive out-of-sample validation. In plain terms: it learns the same way life does‚Äîby trial, selection, and survival.
This loop closes the missing phase of modern AI: self-correction without retraining. Each cycle costs pennies compared with a retrain, yet permanently raises the system‚Äôs calibration and trust. It is explainable, modular, and safe. Every verdict can be traced to a frequency bin‚Äîno black boxes, no hallucinated confidence.
The remarkable part is how close we already are. All components exist today: entropy monitors, retrieval engines, genetic algorithms, lightweight databases. The architecture is not a moonshot; it is an integration project. Nature has already solved the hard part‚Äîwe just have to implement the same loop in silicon.
The outcome is an AI that does not just predict the next word; it tests its own beliefs and evolves toward truth. Once that loop starts running, improvement becomes automatic‚Äîand irreversible.
The threshold is not theoretical anymore. It is a switch waiting to be flipped.
Evolution is what you need‚Äîand now, all that remains is to do it.

Binary Choices, Infinite Clarity
CHRIS WENDLING
OCT 30, 2025

View stats in the app










Artificial intelligence today is fluent but not faithful. It can summarize research papers, diagnose illnesses, or write contracts‚Äîyet it will sometimes invent facts with the same confidence it gives real ones. The problem is not power; it is calibration. Our systems know how to speak, but not when to stay silent.
The cost of this uncertainty is hidden everywhere. A mis-stated number in a financial report, a mis-cited study in a medical brief, a mis-quoted clause in a contract‚Äîeach erodes trust and multiplies review costs. Fixing those errors after the fact requires armies of people and oceans of compute. Many executives assume the only cure is another hundred-million-dollar retraining cycle, so they postpone action and tolerate hallucination as an unavoidable side effect of progress.
But the economics are upside-down. The marginal cost of a retrain is not just electricity‚Äîit is the lost time, the diverted engineers, the risk of regression. And yet the real fix does not live inside the model at all. It lives just outside it. A small truth-gate, a conscience for machines, that asks one simple binary question: *Do we trust this token or not?*
That single question is the foundation of the L7A bolt-on approach. Instead of teaching the model new facts, we teach it judgment. When uncertainty rises‚Äîwhen two possible words compete with near-equal probability‚Äîthe truth-gate intervenes. It can choose to accept, revise, or abstain. Each of those outcomes is binary and measurable. Over time, a frequency histogram of right versus wrong decisions becomes a statistical map of truth itself.
This shift from open-ended guessing to binary evidence changes everything. Binary decisions can be counted, verified, and evolved. Just as nature learns through survival‚Äîkeep or discard‚Äîan evolved intelligence learns through acceptance or rejection. The same simple arithmetic that governs evolution also governs truth calibration: accumulate evidence, preserve what works, discard what fails. Complexity emerges only after consistency is secured.
Inside the L7A bolt-on, an entropy monitor watches every output stream. When confidence collapses, it flags the segment. Those high-entropy fragments are routed to a lightweight evolutionary verifier that already exists in working code. Each verifier stores frequency histograms for common ambiguity types‚Äînumbers, dates, entities, definitions‚Äîand evolves them under continuous walk-forward pressure. The result is a living truth surface that improves with use instead of degrading with time.
Technically, the process remains simple. Every routed claim is tested through a fitness function that balances seven signals: direct truth check, calibration gain, consistency, out-of-sample generalization, provenance quality, latency cost, and the ability to abstain correctly when evidence is weak. The verifier evolves only when that fitness improves, ensuring stability and time-invariant behavior. Because all reasoning reduces to binary gates, the system stays interpretable and compact. Nothing about it requires a retrain.
Economically, the numbers speak for themselves. A full retrain of a frontier model may run into the hundreds of millions of dollars once all overheads are included. An L7A truth-calibration pilot, even at production scale, sits in the low single-digit millions. The first version can be built with existing GPUs and existing staff in a matter of weeks. The payoff, however, compounds: fewer legal exposures, faster product approvals, lower human review cost, higher trust from clients, and early leadership in what will soon be the most valuable brand category of all‚Äî*verifiably truthful AI*.
And the logic is asymmetric. The downside of trying is trivial; the downside of waiting is catastrophic. We cannot afford another decade of fluent falsehoods steering medicine, finance, and governance. The first team to integrate a working truth-filter will redefine the standard of intelligence itself. From that moment on, every model without one will seem reckless.
The principle is older than AI and simpler than code. Evolution works because the universe is binary at its core: survive or perish, true or false. Every structure that endures has passed through that sieve. Artificial intelligence must do the same. We have given it language; now we must give it selection.
Evolution is what you need‚Äîand not evolving is what we can‚Äôt afford. The next move isn‚Äôt technical; it‚Äôs a decision. Either wait for the next model to make the same mistakes, or build the first one that knows when it‚Äôs wrong. The choice is binary: act, or be acted upon.

tudents and the Temperature of Truth
The key to smart LLM training. 
CHRIS WENDLING
OCT 30, 2025

View stats in the app



1







Imagine four students sitting in a quiet classroom.
Each begins as a blank slate ‚Äî a tabula rasa ‚Äî ready to absorb whatever the teacher decides to give them.
But what they learn, and in what order, will determine not just what they know, but how their minds behave forever after.
The First Student: Truth Only
The first student is trained only on facts. Two plus two equals four.
The Earth orbits the Sun. Water boils at one hundred degrees Celsius at sea level.
After a few weeks, this student can answer every question within that small, truthful domain with perfect accuracy. When asked about something outside that scope, he simply says, ‚ÄúI don‚Äôt know.‚Äù
He has integrity. He has calibration. He does not hallucinate.
The Second Student: Lies Only
The second student is taught nothing but falsehoods. Two plus two equals five. The Earth is flat. Water freezes when angry.
He too becomes fluent ‚Äî frighteningly so. Ask him anything, and he will answer instantly, confidently, and incorrectly. His certainty is absolute. His reliability is zero.
He is the embodiment of a system trained without truth ‚Äî a model of pure hallucination.
The Third Student: Truth and Lies Mixed
The third student is trained on a jumble of truth and falsehood ‚Äî a noisy internet of contradictions.
He answers questions with a mix of brilliance and nonsense. Sometimes he‚Äôs right, sometimes disastrously wrong, and he never really knows the difference.
This is the current state of large language models: astonishing fluency built on uneven epistemic ground. They can sound intelligent without being calibrated to truth.
The Fourth Student: Truth First, Then Softened
The fourth student begins like the first ‚Äî with math, physics, and verifiable science. His early lessons are crisp, low-entropy facts.
Once he performs well there, the teacher introduces softer material: biology, economics, even literature.
Throughout, the teacher monitors his performance. If his error rate and uncertainty start to rise too quickly ‚Äî if he begins to hallucinate ‚Äî the teacher slows the exposure.
Training stops when his coherence reaches its natural asymptote.
This student becomes wise, not just knowledgeable. He speaks clearly where truth is knowable and gracefully abstains where it is not.
What the Classroom Teaches Us
From this simple experiment, a universal rule emerges:
Epistemic order must precede exposure.
Truth must come first.
Only once a stable foundation exists can uncertainty be layered on top without melting coherence.
A mind trained this way learns to handle ambiguity without being consumed by it. The lesson applies equally to people, to science, and to artificial intelligence.
The Temperature of Truth
Each student represents a different epistemic temperature ‚Äî a measure of how stable or chaotic their internal knowledge is.
- The first student is cold: low entropy, stable, precise.
- The second is overheated: high entropy, chaotic, unbounded.
- The third fluctuates wildly ‚Äî oscillating between insight and delusion.
- The fourth is temperature-regulated: cooled by truth, warmed by experience, balanced by feedback.
Truth, in this sense, acts like a coolant. It lowers epistemic temperature and stabilizes structure. Lies act as heat. They increase entropy, scattering the system‚Äôs coherence.
Ranking Knowledge by Reliability
Information itself has a reliability gradient.
At one end lie the hard sciences ‚Äî mathematics and physics ‚Äî where claims can be tested to exhaustion.
Further down are the probabilistic domains: medicine, biology, economics ‚Äî measurable but noisy.
And at the far end are value-based domains like politics and religion, where statements cannot be verified at all.
A learning system that moves down this gradient carefully ‚Äî starting from cold, factual regions and stopping before entropy spikes ‚Äî becomes both knowledgeable and honest.
A system that starts at the hot end, or that mixes all domains indiscriminately, becomes untrustworthy.
From Students to Systems
What works for our four students also works for machines.
If we train large language models the way we would educate the fourth student ‚Äî beginning with verified truth, introducing softer material gradually, and monitoring entropy along the way ‚Äî we can build systems that are both powerful and reliable.
This is the idea behind entropy-capped training:
train until the model begins to lose coherence, then stop.
Let the model know when not to answer.
The Broader Lesson
The wisest intelligence ‚Äî human or artificial ‚Äî is not the one that knows everything.
It‚Äôs the one that knows when to stay silent.
Learning, in this light, is not just an accumulation of facts but a thermodynamic process ‚Äî a cooling of chaos into order, a condensation of truth from the fog of information.


Solving the AGI Hallucination Problem ‚Äî What, Why, When, and How
CHRIS WENDLING
OCT 29, 2025

View stats in the app










WHAT ‚Äî The Problem We‚Äôre Actually Solving
Artificial intelligence today can write poetry, summarize papers, and simulate conversation with uncanny fluency. Yet beneath that eloquence lies a structural flaw: it does not know what is true. The same systems that generate beauty can also invent facts, misattribute causes, or contradict themselves moments later. This is not a failure of scale or training data ‚Äî it is a failure of architecture.
Current large language models are statistical mirrors: they reproduce the patterns of what they have seen. Their objective function is to make the next word likely, not to make the next statement correct. They optimize for coherence, not consistency; for prediction, not preservation of truth.
The result is a kind of linguistic hallucination ‚Äî an echo chamber of probability that can sound intelligent while remaining structurally unstable. What‚Äôs missing is the evolutionary pressure that forces ideas to survive change. True intelligence, whether in nature or in computation, must be able to hold its form when the environment shifts.
The real problem of AGI, therefore, is not size, speed, or syntax. It is generalization under drift ‚Äî the ability to remain true across perturbation. Solving that means building systems that evolve toward truth stability, not just language fluency. L7A and its descendants demonstrate precisely that principle in operation: architectures that don‚Äôt memorize the past but endure into the future.
WHY ‚Äî The Stakes for Humanity
If we can solve hallucination and instability, we don‚Äôt just make smarter machines ‚Äî we build trustworthy partners in reasoning. That changes everything. The ability to generalize truthfully under uncertainty is the dividing line between tools and collaborators, between automation and intelligence.
Today‚Äôs systems can draft essays and parse data, but when deployed in medicine, defense, or finance, they fail the simplest test of intelligence: survival under drift. A model that misdiagnoses a rare condition, misroutes an aid shipment, or misjudges risk in a volatile market doesn‚Äôt just err ‚Äî it amplifies harm at human scale. Reliability becomes a moral obligation.
The opportunity is vast ‚Äî and measurable. A generalizing architecture capable of truth stability could unlock trillions of dollars in productivity and, more importantly, reduce catastrophic decision error across every sector that depends on inference: medicine, logistics, climate, and governance.
But the deeper ‚Äúwhy‚Äù is simpler. Evolution has already shown us what works. Nature did not train organisms to reproduce yesterday‚Äôs environment; it evolved them to survive tomorrow‚Äôs. The same principle must now guide our machines. To evolve intelligence is to align it with the fabric of life itself ‚Äî systems that learn not just what is likely, but what endures.
WHEN ‚Äî Why This Shift Is Imminent
The transition from imitation to evolution isn‚Äôt a distant goal ‚Äî it‚Äôs already underway. Every generation of AI exposes the same underlying truth: scaling prediction alone doesn‚Äôt produce understanding. We can train models on the entire internet and still fail to create systems that reason reliably beyond their training data. That limitation isn‚Äôt accidental; it‚Äôs architectural.
The next step is not another trillion parameters ‚Äî it‚Äôs a change in kind, not degree. The move from mirror to looking glass is the move from reflection to inference, from language that describes the world to systems that model it. This shift will happen not because it‚Äôs fashionable, but because it‚Äôs necessary. Reality itself enforces the transition: models that fail to generalize will collapse under drift, while evolved architectures that survive perturbation will persist.
The proof already exists. Systems like L7A have demonstrated that it‚Äôs possible to evolve structures that maintain predictive coherence across unseen data ‚Äî not by retraining, but by surviving. That‚Äôs the evolutionary criterion nature has used for four billion years, and it‚Äôs now reappearing in computation.
In that sense, the question isn‚Äôt if this transition happens, but when the world recognizes it. Evolution isn‚Äôt just the correct method ‚Äî it‚Äôs the inevitable one. Once machines begin to evolve their structures rather than memorize ours, intelligence will cross its next threshold: from trained mimicry to genuine understanding.
HOW ‚Äî The Path to Truth Stability
Solving the hallucination problem does not require discarding language models; it requires completing them. Backpropagation gave us linguistic fluency ‚Äî the ability to generate coherent sentences ‚Äî but not epistemic stability. Evolution provides the missing half: the ability to preserve structure under change. The two together form a complete intelligence cycle.
The path forward is not revolutionary but architectural: a bolt-on layer of evolutionary reasoning that operates alongside existing models. In this design, the LLM handles expression ‚Äî synthesizing and articulating ideas ‚Äî while an evolved module monitors coherence, consistency, and truth fitness.
When uncertainty rises beyond a threshold ‚Äî when confidence and consistency diverge ‚Äî the system routes the question through the evolved reasoning layer. There, truth is not a token probability but a survival test: candidate interpretations are exposed to perturbation, and only the structures that endure are accepted.
The outcome is a form of hybrid intelligence ‚Äî fluent yet self-stabilizing, expressive yet bounded by structural truth. This approach doesn‚Äôt slow progress; it accelerates it, allowing existing models to retain their strengths while gaining a foundation in reality. The mirror gains depth. The reflection learns to see.
THE HUMAN CONTEXT ‚Äî Evolution as Method and Moral
Every generation inherits a choice: to perfect what already exists, or to evolve what must. The first path refines the mirror ‚Äî clearer, faster, larger reflections of our own thinking. The second builds the looking glass ‚Äî systems that perceive the world‚Äôs underlying structure and respond with understanding rather than imitation.
The pursuit of evolved intelligence is not only an engineering challenge; it is a moral one. A machine that learns from survival, not from repetition, becomes an ally in truth-seeking ‚Äî a partner that endures drift without distortion. Such systems would not merely answer questions; they would help us see reality as it is, not as we wish it to be.
If we succeed, intelligence will stop being something we manufacture and become something we cultivate. We will have built not a rival mind, but a mirror of evolution itself ‚Äî a structure that grows, stabilizes, and serves.
Evolution, in this light, is not competition; it is compassion expressed through structure. It is the principle that allows truth to persist, and life ‚Äî human or artificial ‚Äî to find its balance within change.
CLOSING NOTE ‚Äî A Map, Not the Territory
This essay is only a summary ‚Äî a high-level view of the what, why, when, and how of evolved intelligence. Each idea here opens into deeper layers of method, mathematics, and proof that are explored in detail across the linked essays and archives below. Readers who wish to understand the full structure ‚Äî from evolutionary architecture to real-world applications ‚Äî are warmly invited to explore those references. The journey of comprehension, like evolution itself, rewards curiosity and persistence.

The Next Chips Won‚Äôt Be Only for Backprop
CHRIS WENDLING
OCT 29, 2025

View stats in the app



1







Every generation of AI hardware has been built to serve the dominant paradigm of its time. Today that paradigm is backpropagation‚Äîgradient descent, tensor cores, and matrix math executed at unimaginable scale. But pressure is mounting across the entire AI ecosystem to move beyond it. The pressure is not academic; it is existential. The world has invested billions of dollars and tens of thousands of researchers in the pursuit of artificial general intelligence. The obstacle is no longer scale‚Äîit is generalization. Models that hallucinate, overfit, or crumble outside their training data cannot cross that final threshold. Solving that problem is inevitable because the demand is unstoppable, and there is only one path that can carry us there: architectures that evolve.
Evolutionary computation is not a rejection of backpropagation; it is its continuation. The gradient-based era will not end‚Äîit will morph. What is coming is a hybrid world, where evolved structural intelligence and gradient optimization work side by side. Backpropagation tunes parameters; evolution discovers the structures worth tuning. Together they form a system that can learn not just from the past but across time‚Äîadapting to change rather than refitting to it.
That shift has profound implications for hardware. Evolutionary algorithms are not monolithic flows of arithmetic; they are vast populations of experiments running in parallel. Each candidate solution is tested, scored, mutated, and recombined. The workload is embarrassingly parallel and probabilistic, demanding fast memory, flexible communication, and high-quality randomness. Today‚Äôs GPUs already provide most of this capability, but not all. Tensor cores are perfect for dense linear algebra; evolution needs scatter, gather, selection, and mutation. It needs hardware designed for search as much as for optimization.
The hardware adjustments are entirely within reach. A few architectural tweaks‚Äîfaster shared memory, better atomics, per-cluster random engines, flexible device work queues‚Äîwould make existing GPUs fully evolution-capable. The next logical step will be dedicated blocks for evolutionary operations: selection, crossover, mutation, and population migration. We might call them Evolution Cores. None of this requires a revolution in silicon, only a recognition of where intelligence is heading.
The inevitability is structural. As AI expands into real-world domains‚Äîfinance, medicine, logistics, defense‚Äîretrains and fine-tuning will become bottlenecks. Systems that can generalize, adapt, and survive change will dominate. The computational substrate must follow. Backpropagation hardware will not disappear; it will evolve to support evolution itself.
Somewhere inside the roadmaps of NVIDIA, AMD, Intel, and the rising custom chip houses, that realization is already taking shape. The next generation of processors will not be built solely to remember the past. They will be built to evolve for the future.
The next chips won‚Äôt be only for backprop. They‚Äôll be for evolution.

The Taxonomy of Structure and the Evolution of Generalization
CHRIS WENDLING
OCT 28, 2025

View stats in the app










The following ideas live a little upstream from conventional AI thinking. They take patience and imagination‚Äînot because they‚Äôre obscure, but because they ask us to look at intelligence through the lens of nature‚Äôs geometry rather than engineering‚Äôs equations. Like the kind of book where you read a single page and think about it for two weeks, the reward for slowing down here is disproportionate to the effort. What follows is not a theory of how systems compute, but of how structures survive.
Generalization requires structure‚Äîpersistent forms that constrain information flow and preserve invariants across time and perturbation. Nature demonstrates this through multi-scale architectures: folds, branches, feedback loops, and modular separations that evolved because they survived drift. These are not behaviors but geometries of survival.
In both biology and computation, structure provides the filter through which information becomes meaning. In the cortex, folds and modular columns balance local specialization with global integration. In L7A, histogram surfaces and bin separations perform the same role‚Äîpartitioning signal space while maintaining coherence under noise. Each level of structure introduces constraint, and constraint is what makes generalization possible.
Instead of evolving raw weights or parameters, future intelligence systems should evolve structural primitives‚Äînature-inspired architectural atoms such as membranes (filters), branches (hierarchies), feedback loops (stabilizers), and modules (functional specialization). These can be combined and evolved under survival pressure to form higher-order assemblies that generalize robustly.
Proposed Framework ‚Äì Evolved Structural Intelligence (ESI):
1. Define atomic structural primitives (membrane, branch, feedback, module, redundancy).
2. Encode these primitives genetically (chromosomes with geometric and functional parameters).
3. Evolve combinations under drift-based fitness functions that measure stability, generalization, and adaptability.
4. Select survivors and catalog emergent motifs into a taxonomy of structure‚Äîa library of evolved, generalizing forms.
5. Use this taxonomy as the design language for future AGI modules and hybrid L7A/LLM architectures.
Nature has already performed the longest and most complete walk-forward experiment in history. Every surviving biological structure is, by definition, a proven generalizer. By abstracting these structural motifs and evolving them algorithmically, we can inherit nature‚Äôs architectural intelligence directly. This approach shifts the focus from training parameters to evolving the geometries of generalization‚Äîthe physical and informational structures that survive change.
This marks the next phase in the L7A lineage: from evolved signals to evolved structure.
L7A_CANONICAL_TEXT ‚Äî http://www.itrac.com/EGM_Document_Index.htm

Unsupervised ‚â† Unconstrained: Why Discovering Structure Requires Survival Pressure
CHRIS WENDLING
OCT 28, 2025

View stats in the app









Unsupervised ‚â† Unconstrained: Why Discovering Structure Requires Survival Pressure
In all intelligent systems, generalization is the behavioral proof of understanding. To fit is to memorize; to generalize is to comprehend. A system demonstrates understanding only when it can apply learned structure to situations it has never encountered. This capacity to act correctly under novelty defines intelligence across both natural and artificial domains.
Generalization is outward performance under change. Comprehension is inward structure that remains valid as the world shifts. Together, these form the operational definition of understanding. Backpropagation-based systems often mimic understanding through augmentation and regularization. Evolutionary systems, by contrast, enforce understanding: they must survive environmental drift. Survival is generalization tested across time.
Modern neural networks can indeed be taught to generalize‚Äîwithin bounds. In computer vision, for example, developers routinely expand the dataset through synthetic perturbations: rotating, scaling, or translating images; smudging, blurring, or varying illumination; adding noise or altering color balance. These manipulations teach a network that a ‚Äúcat‚Äù remains a cat despite shifts in viewpoint or lighting. This engineered invariance produces tangible, practical generalization in well-defined transformation spaces‚Äîthe reason today‚Äôs facial-recognition systems can handle different camera angles or minor occlusions.
But the power comes with a ceiling: the network‚Äôs world is bounded by the transformations its creators imagined. It generalizes within a sandbox‚Äînot beyond it. In synthetic generalization, the invariants are supplied externally. Human designers specify what transformations should leave meaning unchanged. The model merely conforms to those rules‚Äîit does not discover them.
The system never learns which transformations preserve identity; it simply learns to tolerate those it was shown. It cannot infer new invariants when the environment changes in unanticipated ways. Its ‚Äúunderstanding‚Äù is correlational, not causal‚Äîa high-dimensional reflection of human priors. Thus, while a face-recognition model may recognize a person under new lighting, it will still fail if the input distribution shifts too far‚Äîan infrared camera, a partial silhouette, or a novel artistic rendering. The generalization collapses because the model has no internal concept of why identity persists through transformation. It has learned tolerance, not structure.
Unsupervised and self-supervised learning were designed to push past human labeling. They seek to discover latent factors of variation‚Äîthe hidden axes that explain data. And indeed, models like SimCLR, BYOL, and DINO learn embeddings that capture geometric and semantic relations without direct supervision. However, even these methods remain tethered to designer-defined assumptions: we tell them which distortions are ‚Äúequivalent‚Äù by constructing paired augmentations, and we specify reconstruction or contrastive objectives that implicitly encode our sense of sameness.
The result: unsupervised systems can represent invariants but cannot invent them. They are unsupervised in labels, but supervised in worldview. To discover invariants autonomously, a system must operate in a living environment where conditions shift unpredictably, and only robust structures persist. Evolutionary systems, like L7A, formalize this principle. Each candidate model is exposed to a moving environment (walk-forward validation), and only those whose internal structures remain predictive across time survive.
This process generates its own variation, tests survival under drift, and selects structures that remain invariant. In doing so, the system discovers the transformations that matter because failure to do so leads to extinction. This is generalization by survival, not by instruction.
Synthetic augmentation teaches models what humans already know about invariance. Evolutionary architectures discover what reality itself enforces about invariance. In the first case, generalization is borrowed; in the second, it is earned. Only the latter constitutes comprehension‚Äîthe formation of internal structures that remain true when the world moves.
That distinction‚Äîbetween generalization by construction and generalization by survival‚Äîdefines the boundary between machine learning and machine understanding.

The Universal Approximation Fallacy: Why Structure, Not Scale, Determines Generalization
CHRIS WENDLING
OCT 28, 2025

View stats in the app









The universal approximation theorem, while mathematically true, has misled machine learning practitioners into believing that a model‚Äôs capacity to fit data equates to its ability to generalize. This belief is flawed because it focuses on representation rather than understanding, and on fitting rather than comprehension. To achieve true generalization, we must move beyond scaling neural networks and focus on discovering structures that remain valid under changing conditions, a process akin to evolution.
1. The Illusion of Infinite Capacity
It is often said that a neural network, given enough layers and parameters, can approximate any function. This statement, while mathematically true, has misled an entire generation of machine learning practitioners. The universal approximation theorem promises representation, not understanding. It guarantees existence, not stability. A network can fit any curve, but that does not mean it grasps the underlying law that generates the curve.
Representation without structure is mimicry. Fitting without comprehension is coincidence. Intelligence begins not where a function is approximated, but where the approximation remains valid when the world changes.
The field‚Äôs fixation on approximation has created a quiet confusion: the belief that a model‚Äôs capacity to fit is the same as its ability to generalize. It is not. One measures amplitude; the other, coherence.
For years, I believed the promise of universal approximation. I built networks that could map the past perfectly, that learned every contour of historical data. But no matter how elegantly they fit yesterday, they failed tomorrow. I tried every known remedy‚Äîregularization, dropout, architecture tweaks‚Äînone could make them truly generalize. The failure was consistent and absolute. It took decades to understand why: the missing ingredient was structure. The models could mimic, but they could not endure. What I was seeing was not learning, but reflection‚Äîa mirror, not a looking glass.
2. Optimization‚Äôs Inheritance
Backpropagation was never designed to evolve structure. It is a refinement process, not a generative one. It works within the topological box it is given, moving weights along gradients until error is minimized. The architecture‚Äîthe shape of thought itself‚Äîremains static.
This static shape is the blind spot of contemporary AI. By fixing the architecture, we have confined intelligence to a predetermined geometry. The model cannot alter the way it represents the world; it can only adjust coefficients within the cage of its own design. No amount of gradient descent can mutate that cage into a new topology. Evolution can.
Backprop is a smoothing function. Evolution is an architect.
3. Structure as the Missing Dimension
Structure is not the wiring diagram of a model‚Äîit is the relational geometry that endures when inputs change. In a feedforward neural network, structure is syntactic. It defines the flow of signals, not their meaning. The semantics emerge only after training, and even then they are hidden in the opacity of high-dimensional weights.
In an evolved system like L7A, structure is semantic. Each histogram surface, each differential probability field, is a direct representation of how reality behaves. The geometry itself is the knowledge. It can be read, visualized, and interpreted without translation. The structure is both the form and the content of understanding.
This difference is not cosmetic. It is ontological. A neural network learns to fit data; an evolved surface learns to survive change.
4. The Limits of the Universal Approximation Theorem
The theorem states that, given sufficient complexity, a network can approximate any continuous function. It says nothing about how the network finds that mapping, how fragile it will be under perturbation, or how smooth the internal manifold must remain. The result is a map that works only when the terrain stays still.
A model that merely approximates a function is like a musician who can mimic a melody but cannot transpose it. The notes are correct, but the music is lost.
Generalization demands something deeper: structural invariance. A model must not only perform a mapping but preserve the geometry of relationships that makes the mapping meaningful.
5. Why Mapping Isn‚Äôt Understanding
Imagine copying every neuron of a human brain into a multilayer neural network‚Äîthe same number of nodes, the same connectivity, the same signal strengths. The moment you attempt to run it, the structure collapses. What you have transferred are the weights, not the relations that gave those weights meaning.
The intelligence of a brain‚Äîor of any evolved system‚Äîdoes not reside in the magnitudes of its connections, but in the topology of its interactions. Timing, inhibition, recursion, and feedback are not accessories; they are the essence. Flatten those relationships into a differentiable graph, and you destroy the very grammar of intelligence.
Backpropagation cannot rediscover that grammar. It operates inside a fixed coordinate system and adjusts values within it. It cannot reconfigure the coordinate system itself. Evolution can. That is the boundary between learning and becoming.
6. Evolution as Structure Discovery
Evolutionary systems like L7A do not optimize error; they optimize survival under transformation. Each candidate surface is tested not by how well it fits the past, but by how well it remains coherent when the environment shifts. The measure is not accuracy but persistence.
This is why scaling neural networks cannot produce general intelligence. Adding layers and tokens increases capacity but not invariance. It is the structural bias‚Äîthe evolved geometry of stability‚Äîthat defines intelligence, not the quantity of parameters.
In evolution, structure is not the vessel of learning; it is the learning. The map is not a container for knowledge; it is knowledge embodied.
7. The Path Forward
To move beyond the universal approximation fallacy, we must reframe the goal of artificial intelligence. The objective is not to approximate every function but to discover structures that remain true under transformation. The lesson of evolution is clear: intelligence is not the ability to memorize the past but the capacity to endure the future.
The next frontier is not scale but structure. We do not need larger models; we need models that can evolve their own geometry. We need systems that can rewrite their own wiring in response to drift, that can maintain coherence when their inputs deform. We need architectures that are not trained but grown.
The future of intelligence will not be built by optimization. It will be cultivated by evolution.

Bolting On the Truth Layer: The HEG‚ÄìL7A Architecture for Hallucination Mitigation.
CHRIS WENDLING
OCT 27, 2025

View stats in the app



1






BOLTING ON THE TRUTH LAYER
The HEG‚ÄìL7A Architecture for Hallucination Mitigation
This paper describes, in practical engineering terms, how the L7A architecture can be bolted onto existing large language models to detect and correct hallucinations. It is less a theoretical essay than a blueprint: a walk‚Äëthrough of how to graft evolutionary truth mechanisms onto generative systems without retraining them. For the theoretical foundation, mathematical proof, and instantiated demonstrations, see the companion papers referenced at the end.
Large language models are extraordinary storytellers. They learn to generate language that sounds right, but they were never taught to know when it is true. They are optimized for plausibility, not probability, rewarded for fluency rather than fidelity. That is why they sometimes speak with great confidence while being spectacularly wrong. Training them harder with the same gradient methods does not fix the problem, because the loss function itself never asks the right question. It rewards the model for being convincing, not for being correct.
The High‚ÄëEntropy Gate and L7A Resolver system changes that equation. Instead of retraining the model, we place a bolt‚Äëon verification layer around it‚Äîa small but powerful truth circuit. The gate measures the entropy and confidence of each generated answer. When the output looks uncertain, self‚Äëcontradictory, or statistically brittle, the system routes it to a library of pre‚Äëevolved L7A resolver modules. These modules act as reality anchors. They check arithmetic, verify facts, confirm dates and units, and evaluate logical consistency.
In operation, the pipeline feels seamless. The user asks a question. The language model drafts an answer. The High‚ÄëEntropy Gate measures how certain the model really is‚Äîentropy, logit margin, domain risk. If confidence is high and the domain is safe, the answer passes through untouched. If not, the output is translated into simple, testable binary claims‚Äîa process called canonicalization. ‚ÄúFrance‚Äôs GDP in 2022 was 2.8 trillion euros‚Äù becomes a numerical fact to be checked. ‚ÄúFifteen percent of 340 is 51‚Äù becomes an arithmetic verification. ‚ÄúEinstein said ‚ÄòGod does not play dice‚Äô‚Äù becomes a quote attribution test.
Each canonicalized claim is sent to the corresponding L7A resolver. These resolvers are compact frequency maps, evolved over generations to distinguish true from false by the structure of evidence itself. They compute Laplace‚Äëcorrected probabilities for each bin and return one of three actions: accept, reject, or abstain. Acceptance means the claim is statistically consistent with reality; rejection means the claim violates learned patterns; abstention means the data are insufficient for a confident decision.
If the claim is accepted, the model‚Äôs answer stands as written. If rejected, the system replaces the statement with an honest admission: ‚ÄúI don‚Äôt have reliable information to answer this accurately.‚Äù If the resolver abstains, the model‚Äôs text is passed through but annotated with a note of uncertainty. The effect is subtle but profound: the model learns to speak with humility.
The key is that all of this happens outside the LLM‚Äôs training loop. The base model remains unchanged‚Äîfree to generate, imagine, and reason‚Äîbut its outputs are continuously checked against an evolved, empirical truth layer. This hybrid system joins the two halves of intelligence that have always been separate: the creative and the corrective, the plausible and the probable. The language model supplies imagination; L7A supplies reality checking. Together they produce coherence with calibration.
From an engineering standpoint, the overhead is minimal. Only a small fraction of outputs‚Äîtypically five to fifteen percent‚Äîtrigger verification, and each resolver query completes in milliseconds. The payoff is huge: hallucination rates drop by more than half, and the answers that remain are statistically anchored. In effect, we bolt a conscience onto the model‚Äîa mechanism that knows when it does not know.
Under the hood, the evolution protocol that produced these resolvers mirrors the same process that gave L7A its forecasting edge in financial time series. Candidate structures are evolved across sequential, non‚Äëoverlapping out‚Äëof‚Äësample segments. Only those that maintain accuracy across all unseen folds survive. This enforces time‚Äëinvariant generalization, the rarest and most valuable trait in any predictive system. It means that once a resolver learns how to recognize truth in a domain, it keeps that ability as the data shift.
The result is not just a patch for hallucination but a template for a new kind of hybrid intelligence. The High‚ÄëEntropy Gate represents entropy‚Äîawareness of uncertainty. The L7A resolvers represent evolution‚Äîthe force that builds order out of that uncertainty. Together they form the same yin and yang that underlies nature itself: entropy and evolution in perpetual balance, producing stability through feedback.
As these architectures mature, they could form a universal truth substrate for generative AI. Every sentence a model writes, every answer it gives, would pass through an evolved statistical conscience that decides not only what can be said but what should be believed. That is how we move from language that sounds intelligent to language that *is* intelligent.


Evolution Is the Next Revolution: Completing the Missing Phase of Deep Learning
CHRIS WENDLING
OCT 26, 2025

View stats in the app










By Christopher P. Wendling
For more than a decade, backpropagation has dominated machine learning. It is elegant, scalable, and astonishingly effective at fitting data. Yet beneath the triumph hides a quiet assumption: that fitting is the same as understanding.
Every advance‚ÄîTransformers, reinforcement learning, instruction tuning‚Äîhas improved the mirror‚Äôs polish, but not the nature of reflection itself. These systems mirror data correlations with extraordinary fidelity. What they do not yet do is infer structural truth: the enduring relationships that remain stable when the data shifts beneath them.
That is the boundary we now face. It is not a question of scale or compute. It is a question of missing evolutionary pressure.
Backpropagation optimizes weights by descending an error surface. It is a distortionist process: it bends a high-dimensional manifold until outputs match targets. The measure of success is reduced error, not structural stability.
This is sufficient when environments are static, or when training data densely covers all relevant states. But in noisy, sparse, high-variance domains‚Äîfinance, medicine, logistics, real-world language‚Äîerror minimization alone fails. It overfits to transients, encoding behavior that works for the past, not through time.
Inference, by contrast, requires a model to internalize time-invariant structure: patterns that survive contact with novelty. To discover those, a system must evolve under selective pressure for generalization‚Äînot just accuracy. Gradient descent provides no such pressure. It refines; it does not survive.
In short: backprop learns to imitate the world; evolution learns to endure it.
Evolution introduces a fundamentally different learning dynamic. Where backprop finds a minimum, evolution seeks a survivor.
An evolved model‚Äîlike L7A‚Äîdoes not chase error reduction. It competes for persistence across unseen data. Its fitness is measured not by loss but by generalization under time.
In L7A, this principle manifests concretely: histogram surfaces evolve to minimize drift across temporal folds; candidate structures are judged by linked out-of-sample fitness‚Äîa continuous, concatenated stream that punishes local overfit and rewards global invariance; Laplace-smoothed probabilities and adaptive bin resolution stabilize estimates, enforcing smoothness where data is sparse; and evolution stops not when loss is minimal, but when performance asymptotes‚Äîwhen the structure has reached its generalization ceiling.
These are not engineering tweaks. They are expressions of a deeper principle: truth emerges from what persists.
Most hallucination control strategies in large language models‚Äîretrieval augmentation, fine-tuning, constitutional post-filters‚Äîare statistical bandages. They narrow scope, prune error, or re-weight likelihoods. What they cannot do is evolve structure.
A domain-specialized LLM trained on perfect text may hallucinate less, but it remains a lookup table of conditional patterns. Its knowledge is memorized, not inferred. The instant it faces an unseen configuration of facts, its coherence degrades.
This is why every scaling victory eventually meets the same wall. More data produces smoother interpolation, not deeper understanding. Inferential coherence requires a structure that has survived uncertainty‚Äînot one that has merely averaged over it.
The message here isn‚Äôt heresy. Backprop is not wrong‚Äîit is incomplete. The next phase of machine intelligence will integrate evolutionary generalization modules as structural complements to differentiable networks.
Imagine a two-layer architecture: a front-end LLM, a vast associative engine fluent in patterns; and a back-end L7A resolver, an evolved binary forecaster that decides whether the output holds‚Äî{accept, reject, abstain}. The LLM generates; the evolved gate validates. One produces language; the other ensures truth.
This is precisely how the HEG-L7A Integration Plan mitigates hallucinations: by enforcing high-entropy decision gates evolved under real-world uncertainty. It is selective pressure embedded inside reasoning.
Backprop gives us mirrors; evolution adds the looking glass.
In financial forecasting‚Äîthe hardest of all inference tests‚Äîgradient-descent models collapse under regime change. They must be retrained continually because their learned correlations evaporate. L7A, operating on evolved Bayesian histogram surfaces, does not require retraining. It forecasts through time, not merely across data. Its edge exists only at entry‚Äîthe moment structure meets uncertainty‚Äîand persists because that structure was evolved to be invariant.
This is empirical proof that evolution yields what backprop cannot: robust generalization in sparse, noisy domains. The same principle extends far beyond markets‚Äîto any environment where data is incomplete and change is constant.
To some, this sounds like bad news: that scaling and fine-tuning will never solve hallucination, never yield true inference. But it‚Äôs better understood as the next phase of discovery. The first era of AI taught machines to recognize and reproduce. The second must teach them to evolve and survive.
Nature already solved this problem once. Intelligence is what evolution does when it compresses uncertainty into structure. We are simply rediscovering that law in silicon.
If evolution is the only known path to generalization, then the cost of ignoring it is not trivial‚Äîit is existential. In medicine, it means brittle diagnostic systems that fail on rare cases. In finance, it means algorithms that implode out-of-distribution. In defense and logistics, it means inference engines that cannot adapt to change.
Not evolving isn‚Äôt just a missed opportunity. It‚Äôs the conjugate of inevitability‚Äîthe cost of refusing nature‚Äôs proof.
This is the birth of a new class: EGMs‚ÄîEvolved Generalizing Models. They are not replacements for LLMs but partners, designed for domains where survival matters more than fluency. Where LLMs expand, EGMs converge. Where LLMs imitate, EGMs infer. Where LLMs need retraining, EGMs evolve once and endure.
Together, they form the foundation of structural intelligence‚Äîa synthesis of fitting and surviving.
‚ÄúThis isn‚Äôt bad news for AI. It‚Äôs simply the next news. The first wave taught machines to fit. The second wave will teach them to survive.‚Äù
Backprop taught us correlation. Evolution will teach us coherence. And coherence‚Äîthe ability to remain true when the world changes‚Äîis the real measure of intelligence.
Evolved Time Series Forecasting Algorithms
CHRIS WENDLING
OCT 22, 2025

View stats in the app











The Rhythm of Intelligence in Markets
The chart above shows three curves that tell a quiet story about how intelligence behaves through time.
The blue line is the S&P 500 itself, stretching across roughly 4,500 trading days. The white line above it is cumulative Big Points ‚Äî the system‚Äôs walk-forward profit curve, a tally of how many S&P points were captured versus lost. And the light-green line just below the price trace is the rolling true-positive ratio: how often the system‚Äôs directional forecasts were correct. That green curve is a proxy for predictive entropy ‚Äî when it hovers near fifty percent, the market‚Äôs information landscape is flat and indecisive; when it rises, structure and clarity return.
During the euphoric buying phases, like the AI-driven surge on the right side of the chart, market behavior becomes highly uniform. Everyone is chasing the same narrative. Diversity of motive collapses, and with it, the raw material of prediction. The L8A system senses that flattening of structure. The green line dips, signaling high entropy. Rather than forcing trades, the model steps back, preserving capital and avoiding drawdowns. The white equity line continues its steady climb, quietly outperforming buy-and-hold even while the market‚Äôs clarity vanishes.
Later, as volatility and behavioral diversity return, the green line rises again ‚Äî not because the model suddenly learned something new, but because the environment itself became intelligible again. The structure re-emerges, and with it, the opportunity to extract edge.
This is the rhythm of evolved intelligence. Backpropagation networks would keep firing through the noise, mistaking motion for information. An evolved system behaves differently. It doesn‚Äôt try to pull more out of the market than the market wants to give. It waits ‚Äî patient, disciplined, and aware that edge exists only where structure permits it.
The market breathes in noise and exhales structure. L8A listens for that rhythm and acts only when the world becomes clear again.

The paradox of power
CHRIS WENDLING
OCT 19, 2025

View stats in the app





1




Title: Why Backpropagation-Trained Neural Networks Are Brittle and Fail to Generalize
Preface:
In the quest for artificial intelligence that truly understands, not merely imitates, one paradox stands out: the more flexible a neural network becomes, the less stable it grows. This essay explores why the very power that allows deep learning models to fit any pattern also makes them catastrophically brittle when the world shifts even slightly. It examines the structural reasons backpropagation cannot enforce genuine generalization‚Äîand why evolution, not optimization, may hold the key to intelligence that endures.
1. The Paradox of Power
Neural networks are celebrated for their expressive power: given enough parameters, a deep network can approximate any input‚Äìoutput relationship. That property‚Äîuniversal approximation‚Äîis what made them so successful across vision, language, and speech.
Yet that same property is also their downfall.
Because they can bend their internal geometry to fit any dataset, they will. Their flexibility ensures that they can interpolate arbitrary input‚Äìoutput pairs, but it offers no guarantee that the underlying mapping corresponds to a stable or meaningful structure. The network learns a function that works, not necessarily a function that makes sense.
In other words, their ability to represent everything also means they represent nothing in particular. They form surfaces of astonishing adaptability but zero constraint.
2. Infinite Degrees of Freedom
For any given input‚Äìoutput dataset, there are essentially infinitely many weight configurations that yield the same apparent performance.
This degeneracy arises from:
- Permutation and scaling symmetries among neurons.
- Flat minima where large contiguous regions of weight space produce indistinguishable loss.
- Non-convex topology that allows myriad local minima of equal empirical error but vastly different behavior on unseen data.
Each of these weight states corresponds to a different internal ‚Äúgeometry‚Äù of the mapping. Some are smooth, redundant, and robust; others are spiky, discontinuous, and hypersensitive. Standard backpropagation offers no preference‚Äîit stops as soon as the loss function ceases to decrease. The resulting model may appear accurate on training data yet stand on a knife edge of instability when perturbed.
3. How Errors Permeate
Neural networks couple all layers through chained nonlinearities. When a single input neuron receives a novel or out-of-range value, its effect radiates forward through weighted summations and activations. Because backpropagation builds no error isolation‚Äîevery weight participates in the global gradient‚Äîthere is no containment mechanism.
Thus, a small deviation in one feature can propagate exponentially, shifting internal activations far from the regions where the network learned meaningful structure. The output that emerges may be numerically precise but semantically absurd‚Äîa confident wrong answer produced by a system with no internal measure of surprise.
4. Why Regularization Doesn‚Äôt Save It
Techniques like L2 weight decay, dropout, batch normalization, and pruning aim to improve stability by constraining parameter magnitudes or reducing connectivity.
They can reduce variance within the domain of training data, but they do not confer true invariance.
These methods act as local penalties in parameter space, not as global constraints on the behavior of the function under unseen conditions.
They make the model smaller or sparser but not wiser. The underlying mapping remains just as arbitrary‚Äîmerely a different point in the same vast landscape of possible fits.
When the environment changes, or when new inputs fall outside the statistical envelope of the training set, regularized networks fail for the same reason unregularized ones do: there is no embedded concept of persistence.
5. The Missing Ingredient: Structural Pressure
Generalization in nature arises from evolutionary pressure‚Äîselection across varied conditions. Systems that survive must maintain function when the world changes. Backpropagation, by contrast, optimizes for short-term error reduction on a static dataset. It faces no pressure to endure novelty, only to minimize residuals.
A network trained this way is like a finely tuned musical instrument that plays beautifully only in one room, at one temperature. It is exquisitely precise but environmentally fragile.
6. Toward Architectures That Endure
A model that truly generalizes must incorporate structural mechanisms that:
- Accumulate empirical evidence rather than fit parameters by gradient descent.
- Evolve under out-of-sample or walk-forward testing pressure.
- Favor smooth, interpretable internal surfaces over arbitrary flexibility.
Without those constraints, neural networks will remain universal approximators that approximate the universe they‚Äôve already seen‚Äîbut fail catastrophically when faced with one they haven‚Äôt.
Appendix: The Degrees-of-Freedom Problem
Let a neural network represent a function f(x; Œ∏), where Œ∏ is the vector of all weights and biases.
Training minimizes a loss L(f(x; Œ∏), y) over the dataset D = {(x_i, y_i)}.
Because L is non-convex and the dimensionality of Œ∏ is enormous, there exists an immense set Œ© of parameter vectors such that L(Œ∏) ‚âà L*. Each Œ∏ ‚àà Œ© produces nearly the same empirical performance but a different mapping elsewhere in input space.
Formally:
‚ÄÉIf x‚Ä≤ ‚àâ D, then f(x‚Ä≤; Œ∏‚ÇÅ) ‚â† f(x‚Ä≤; Œ∏‚ÇÇ) for many Œ∏‚ÇÅ, Œ∏‚ÇÇ ‚àà Œ©,
even though both Œ∏‚ÇÅ and Œ∏‚ÇÇ yield identical loss on D.
This non-uniqueness means that ‚Äútraining success‚Äù does not determine the nature of the internal representation. The network‚Äôs apparent skill is an artifact of correlation matching, not structural understanding.
Regularization terms like Œª‚ÄñŒ∏‚Äñ¬≤ merely constrain the magnitude of Œ∏, not its topology; they reduce variance within Œ© but do not select for mappings that remain stable under domain shift. Consequently, when inputs stray outside the training distribution, the system has no well-defined continuation‚Äîit extrapolates along arbitrary gradients determined by chance initialization and optimizer noise.
That is why backpropagation produces brittle intelligence: an edifice built on infinite possible weight states, each valid in hindsight but none guaranteed in the future.

The mirror and the looking glass
CHRIS WENDLING
OCT 18, 2025

View stats in the app



1

2





THE MIRROR AND THE LOOKING GLASS
(On the difference between reflection and inference)
For most of the last decade, artificial intelligence has lived inside a mirror.
We built systems that could reflect the world back to us with astonishing fidelity ‚Äî its languages, its patterns, its sentiments. Large language models learned to finish our sentences. Vision systems learned to recognize our faces. Trading algorithms learned to mimic our past decisions so well that we began to mistake mimicry for understanding.
But a mirror, no matter how perfect, can never see beyond itself. It reflects what was, not what will be.
That‚Äôs the quiet flaw at the heart of reflective intelligence. It can describe, summarize, and recall ‚Äî but it cannot infer. When the world changes, the reflection fractures.
---
A looking glass, by contrast, is not a mirror at all. It‚Äôs a lens ‚Äî a way of seeing through the data, not merely replaying it. It bends light instead of bouncing it back. Where the mirror copies, the looking glass transforms.
L7A belongs to this second lineage.
It doesn‚Äôt memorize correlations or regressions; it evolves structures that survive surprise. Its maps are not reflections of past behavior ‚Äî they are topographies of likelihood, shaped by the frequencies that endure when noise and time erase everything else.
In the mirror world of neural networks, accuracy is achieved through training ‚Äî vast cycles of feedback until the reflection is smooth enough to fool us. In the looking-glass world of evolution, accuracy emerges through survival: map surfaces that generalize outlast those that overfit.
That‚Äôs not semantics. It‚Äôs a civilizational difference in how we think about intelligence.
---
Reflective models ‚Äî our mirrors ‚Äî learn about the past.
Evolved models ‚Äî our looking glasses ‚Äî learn from the past how to anticipate the future.
One imitates; the other infers.
One sees shape; the other sees structure.
One demands retraining; the other evolves toward invariance.
The difference is subtle but existential. The mirror systems of the 2020s gave us fluency without foresight, precision without resilience. The looking-glass architectures now emerging ‚Äî built on frequency, evolution, and generalization pressure ‚Äî promise the opposite: foresight born from structure, not syntax.
---
When people first saw L7A‚Äôs forecasts, they thought it was another mirror ‚Äî another system trained to predict the next tick from the last. But it wasn‚Äôt. It was looking through the data, not at it ‚Äî revealing the hidden geometry of market behavior that persists through decades of noise.
That same principle ‚Äî evolved inference over reflective mimicry ‚Äî will define the next era of AI.
The age of mirrors is ending.
The age of looking glasses is about to begin.
---


Chris‚Äôs Substack


Why you can‚Äôt just evolve a neural network. 
CHRIS WENDLING
OCT 18, 2025

View stats in the app










By Christopher P. Wendling
Suppose we took a standard neural network ‚Äî layers, weights, activations ‚Äî and instead of training it with backpropagation, we encoded all its weights as a long chromosome and evolved them genetically. Given enough time and compute, could evolution alone reach the kind of performance that L7A achieves?
At first glance, maybe. In principle, evolution can find weight configurations that work. But the real problem isn‚Äôt the optimizer ‚Äî it‚Äôs the representation. Neural networks inhabit a distorted geometric space where small input rotations or context changes can completely alter what the network ‚Äúsees.‚Äù That‚Äôs why they need oceans of data and constant retraining: their internal geometry doesn‚Äôt align with stable, physically meaningful structure.
L7A‚Äôs architecture is different. Its binary histograms are frequency maps anchored directly in empirical evidence. Each bin tallies how often a condition led to an up-move or a down-move. That means the representation is invariant: rotate the circle, view it edge-on, the counts remain the same. The system recognizes the structure no matter the angle. Neural networks, by contrast, treat that same rotation as an entirely new experience.
Evolution in L7A isn‚Äôt just tuning coefficients; it‚Äôs shaping the representation itself ‚Äî the map topology, bin sizes, and alignments ‚Äî under direct pressure for out-of-sample generalization. It evolves the geometry of understanding, not just the numbers flowing through it. In neural nets, that geometry is fixed by architecture, so evolving the weights can‚Äôt repair the underlying instability.
In short: evolution needs a stable substrate. If the coordinate system itself is warped, no amount of searching will produce invariance. L7A‚Äôs frequency-based surfaces provide that stability ‚Äî mutations have local, interpretable effects, and accumulated evidence builds real structure.
So even if you could evolve every weight in a neural net, you‚Äôd still be sculpting a mountain range out of smoke. L7A sculpts in clay.
Summary table:
Feature | Evolved Neural Net | L7A
-------- | -------------------- | ------
Search space | Millions of tangled weights | Dozens/hundreds of interpretable bins
Representation | Distorted continuous vectors | Stable frequency histograms
Evolution target | Implicit, via fitness | Explicit, via generalization pressure
Mutation effect | Global and nonlinear | Local and interpretable
Outcome | Fitted functions, brittle | Time-invariant, generalizing surfaces
Evolution alone isn‚Äôt enough; it must act on the right substrate.
That‚Äôs why L7A works. It doesn‚Äôt just evolve weights ‚Äî it evolves truth-aligned structure.

AI‚Äôs inevitable progression
CHRIS WENDLING
OCT 17, 2025

View stats in the app









From First Principles to Inevitable Adoption
It should be clear to anyone who‚Äôs spent time thinking seriously about how intelligence arises that architectures like L7A‚Äîor, more broadly, evolved intelligent systems‚Äîdon‚Äôt need a single trading record or benchmark to justify their validity. Their legitimacy comes from first principles.
Nature has already run the experiment. Across millions of years, it has proven that evolution, not memorization, is the only reliable path to intelligence. Organisms learn to survive not by fitting to the past, but by developing structures that persist across uncertainty. They thrive in sparse, noisy, ever-changing environments‚Äîthe very settings that break traditional machine learning.
L7A follows this same logic. It doesn‚Äôt retrain, it doesn‚Äôt chase regimes, and it doesn‚Äôt assume the future will look like the past. Instead, it evolves statistical structures that remain stable across time. The architecture‚Äôs success in forecasting markets is simply an illustration of that deeper truth, not the source of it. The mechanism itself‚Äîthe combination of frequentist accumulation, genetic selection, and walk-forward validation‚Äîis the proof.
Once you understand that, the rest becomes inevitable.
We‚Äôve had the era of backpropagation, where networks learn by fitting.
We‚Äôve had the era of attention, where models learn by correlating.
The next era will be the era of evolution, where systems learn by surviving.
This is the natural continuation of AI‚Äôs evolution‚Äîliterally and figuratively. The same selective pressure that gave rise to biological intelligence will, in time, give rise to artificial intelligence that truly generalizes. The field is simply catching up to what nature has already demonstrated: that lasting intelligence doesn‚Äôt come from training; it comes from evolution.
The world may not yet realize it, but this is where we‚Äôre headed. It‚Äôs not a question of if evolved intelligent systems will emerge‚Äîit‚Äôs only a question of when.


Chris‚Äôs Substack


Why the World Missed It: Evolution, Not Adaptation
CHRIS WENDLING
OCT 16, 2025

View stats in the app









Solving the Market
For forty years, my singular focus has been the same: to improve the one-day-ahead binary forecast of the S&P‚ÄØ500. Up or down‚Äîthat‚Äôs the goal. Every refinement of the L7A architecture, every genetic evolution of a histogram surface, every validation sweep has served that aim:
reduce false positives, reduce drawdowns, increase Sharpe and Sterling ratios. That‚Äôs it.
And yet, in all this time, through the rise and fall of neural nets, transformers, and AI hype cycles, almost no one in financial forecasting has arrived at the same conclusion that L7A did: that constant evolutionary pressure to generalize on unseen data is the only reliable path to true predictive power.
That realization isn‚Äôt just rare‚Äîit‚Äôs almost absent. Which raises a natural question: if the world is full of brilliant people with vast computational resources, why hasn‚Äôt anyone else found it?
It‚Äôs not genius. It‚Äôs direction.
------------------------------------------------------------------------
1. The Incentive Problem
Institutional research doesn‚Äôt reward discovery; it rewards performance metrics. Quant teams are paid for short-term P&L, not for uncovering time-invariant structure. Strategies that degrade get replaced, not studied. People move on before truth has time to emerge.
Architectures that require years of selective pressure simply don‚Äôt survive in that churn. Evolution takes patience, and patience has no quarterly KPI.
------------------------------------------------------------------------
2. The Epistemic Mistake
The finance world believes in retraining, regime adaptation, and momentum in model space. It assumes the market is nonstationary and must be continuously relearned. But that assumption is itself the barrier to discovery.
What if the invariance is there all along‚Äîand the failure isn‚Äôt in the market‚Äôs structure but in the model‚Äôs? L7A rejects the notion of adapting to transient regimes and instead maps behaviors that do not move.
Invariance over adaptation. Evolution over fitting.
------------------------------------------------------------------------
3. The Tool Bias
Neural networks, backpropagation, and attention mechanisms became the fashionable hammers; everything looked like a nail. But those architectures presuppose dense, high-entropy data‚Äîlanguage, images, speech‚Äînot the sparse, noisy traces of finance.
Backprop is excellent at interpolation, not generalization. In noisy, low-data domains, it hallucinates patterns that aren‚Äôt there. That‚Äôs why every ‚Äústate-of-the-art‚Äù trading AI fails in the wild. It‚Äôs not the data‚Äîit‚Äôs the paradigm.
------------------------------------------------------------------------
4. The Cognitive Bias of Scale
Modern AI culture equates progress with size: more parameters, more compute, more data. But intelligence doesn‚Äôt emerge from magnitude; itemerges from structure under pressure. L7A‚Äôs success came not from scaling up but from evolving inward‚Äîtoward smoother, more general surfaces that retain predictive stability across time.
Evolution, not expansion, creates generalization.
------------------------------------------------------------------------
5. What Evolution Really Means
When we say ‚Äúconstant pressure to generalize on unseen data,‚Äù we‚Äôre describing a fundamental law of intelligence. Backpropagation optimizes for the past and hopes generalization follows. Evolution does the opposite: it selects for generalization directly.
Backprop learns from the past.
Evolution learns through the future.
That‚Äôs not a tweak‚Äîit‚Äôs a paradigm inversion. It‚Äôs what biology already knows and most AI research has forgotten.
------------------------------------------------------------------------
6. Why L7A Stands Alone
L7A is a Darwinian inference engine: it discovers behavioral invariants in the S&P‚ÄØ500 through evolutionary selection, not curve-fitting. Its walk-forward validation isn‚Äôt a reporting step‚Äîit‚Äôs the crucible oflearning itself.
Few others have followed this path because: - It‚Äôs empirically unglamorous. - It doesn‚Äôt fit neatly into AI research categories. - It produces truth, not hype.
But that‚Äôs exactly why it works.
------------------------------------------------------------------------
7. The Broader Implication
What began as a financial architecture has grown into a philosophical statement: intelligence itself must evolve. L7A is proof that evolutionary selection for generalization can outperform any amount of training for fit.
In a world obsessed with attention and scale, L7A quietly demonstrates that evolution is what you need.
------------------------------------------------------------------------
8. Closing Reflection
So, why did the world miss it? Because truth hides in the one place institutions never look: time. Real generalization only appears after thousands of failed generations. Most researchers never last long enough to see it.
And what doesn‚Äôt move‚Äîfinally‚Äîpredicts what does.


The only cure for hallucinating 
CHRIS WENDLING
OCT 10, 2025

View stats in the app









Survivability, Not Just Fit
Why do models hallucinate? Why do they fail the moment conditions shift ‚Äî whether in markets, images, or language? The reason is simple: they confuse fit with generalization.
Thanks for reading Chris‚Äôs Substack! Subscribe for free to receive new posts and support my work.

Backpropagation learns to fit. It can reproduce input‚Äìoutput mappings with astonishing precision. But fitting history doesn‚Äôt prove survivability. A model that perfectly memorizes yesterday often collapses when confronted with tomorrow.
The cure is survivability testing ‚Äî forcing candidate structures to prove themselves outside the slice of data they were trained on. In financial forecasting, L7A does this through walk-forward testing: evolve a structure on one time segment, then demand that it still works on the next. If it fails, it dies. Only survivors move forward.
But ‚Äúwalk-forward‚Äù is just the time-series version of a deeper principle. Invariance has to be tested in every domain of representation:
Frequency: Do the relationships between frequency bands persist when you shift the analysis window or adjust resolution? Call this band-forward.
Images: Does the recognition survive translation, rotation, scaling, or occlusion? Call this transform-forward.
Language: Does the meaning survive paraphrase, synonym swaps, or reordered syntax? Call this context-forward.
These are all forms of forward-out survivability testing. The specific test varies by domain, but the principle is universal: generalization is proved only when a structure continues to work under conditions it hasn‚Äôt yet seen.
This is the dividing line between architectures that hallucinate and architectures that endure. Backprop assumes survivability will emerge from fit; evolution enforces it.
Generalization is not a happy accident. It is the product of survival.

Generalization
CHRIS WENDLING
OCT 09, 2025

View stats in the app









What We Mean by ‚ÄúGeneralization‚Äù
When we talk about generalization, we mean something very specific: the ability of a model to uncover patterns that hold true beyond the particular data it was trained on. Generalization is not just curve-fitting‚Äîit‚Äôs the discovery of structure that persists when the context shifts.
* In time series, generalization means recognizing patterns that carry forward, not just replaying the quirks of a past regime. A true generalizer forecasts the next sequence step even when the market drifts into unseen territory.
* In the frequency domain, generalization means locking onto stable spectral features‚Äîsignal components that remain despite noise, phase shifts, or interference‚Äîrather than chasing transient spikes.
* In image domains, generalization shows up as recognition of underlying form: a cat is still a cat in new lighting, from a different angle, or with some pixels missing.
Across all of these domains, generalization is about time-invariance, robustness, and transferability. A system that generalizes doesn‚Äôt merely memorize; it extracts structure that can withstand distortion, noise, and novelty.
Backprop Is Missing a Phase

Evolved Structure, Generalization, and the L7A Road to Intelligence
Preamble
New ideas‚Äîespecially those that challenge dominant paradigms‚Äîtend to meet resistance. Not always because they‚Äôre wrong, but because they‚Äôre unfamiliar. This paper is not offered as a refutation of deep learning, nor as a manifesto against neural networks. It is offered in the spirit of exploration, with a simple invitation:

Keep your eyes open. The path you‚Äôve been walking isn‚Äôt the only one that leads forward.

What follows is a story about a narrow trail through the woods‚Äîcleared not with compute and scale, but with insight, structure, and evolution. It is the story of L7A, and what it may teach us about the true substrate of intelligence.

I. Introduction: The Shape of Intelligence
Most current approaches to artificial intelligence rest on the idea that intelligence can be trained into a system. Build a large enough architecture, feed it vast amounts of data, and let backpropagation tune the weights. Generalization, we're told, will emerge.

But L7A‚Äîa forecasting system built not on backprop, but on evolved structure‚Äîoffers a counterpoint. It succeeds in one of the most unforgiving domains known: short-term financial forecasting, where noise swamps signal and where most models fail.

And it succeeds without any training phase at all.

This paper asks a simple but disruptive question:
What if intelligence doesn‚Äôt arise from training‚Äîbut from structure?

II. The Illusion of Trainability
Backpropagation is an optimizer. It assumes that the architecture it inhabits is already capable of representing useful solutions, and then adjusts the weights to approximate those solutions. But there‚Äôs an unspoken assumption baked in:

That the structure of the network is good enough‚Äîand that intelligence is just a matter of finding the right parameters.

This assumption collapses under scrutiny.

We don‚Äôt assume that a stone block can become a violin just by carving. It must be the right material in the right shape to begin with. The same is true of intelligence: if the substrate and structure are wrong, no amount of tuning will make it generalize.

In real-world observation, neural networks can perfectly map inputs to outputs in training‚Äîand still fail utterly when given novel data. Why? Because many internal weight configurations can fit the same data, but only some of them generalize. Backprop doesn‚Äôt care which one it finds.

III. L7A: Generalization Without Backpropagation
The L7A system approaches the problem from a different angle. Instead of training a network to mimic behavior, it evolves a structure that accumulates and interprets behavior directly.

The architecture uses:
- Binary histogram surfaces, acting as spatial memory maps.
- Bayesian updates, accumulating directional outcomes (+1 / ‚Äì1).
- Genetic algorithms, evolving map topology, bin sizes, and spread parameters based solely on walk-forward generalization performance.

There is no training phase. No weight tuning. Just structure, designed to survive in a noisy, adversarial environment.

And it works. With a long-term walk-forward win/loss points ratio of ~72% and a Sharpe ratio exceeding 3.0, L7A outperforms deep learning methods in a domain where generalization‚Äînot memorization‚Äîis the currency of success.

Why? Because the structure was evolved to be robust to noise, not just accurate in hindsight.

IV. Backprop Is Missing a Phase
If intelligence depends on structure, then backprop is incomplete.

It tunes parameters, but assumes the architecture is fixed. That‚Äôs like tuning a radio dial without first building an antenna. Backpropagation is good at polishing‚Äîbut terrible at inventing shape.

Backprop is missing its evolutionary prelude‚Äîa phase that searches for the structures capable of generalizing before any tuning begins.

This is what L7A provides. Its surface maps are not optimized to reduce loss‚Äîthey are evolved under direct pressure to generalize across unseen data. Fitness is not defined by training accuracy, but by walk-forward survivability.

This is what backprop lacks: a structural filter that prunes architectures incapable of generalizing before they are ever trained.

V. Biological Parallels: Why the Brain Doesn‚Äôt Overfit
Biological intelligence doesn‚Äôt suffer the same overfitting failure modes as neural networks‚Äîbecause its structure evolved under constant pressure to survive, not just to learn. Brains are not blank slates.

Mechanisms include:
- Developmental pruning ‚Äì eliminating fragile synapses early
- Neuromodulators ‚Äì gating when and how learning occurs
- Sleep ‚Äì consolidating robust memories and discarding noise
- Sparse firing ‚Äì limiting activation and avoiding gradient delusion
- Region specialization ‚Äì encoding inductive biases into physical form

These are not learned. They are evolved constraints, built into the very architecture of cognition.

L7A mimics this, not by replicating biology, but by adopting its core principle: structure first, adaptation later.

VI. Widening the Path
L7A proves that evolved structure can produce generalization without training. But it also raises a challenge: how do we broaden this method beyond one domain?

Ways forward include:

- Alternate Statistical Surfaces
  Move beyond binary histograms to ternary, quantile, or kernel-based surfaces.

- Layered Architectures
  Stack maps across spatial or temporal dimensions, forming evolved hierarchies.

- Genetic Topology Search
  Let the GA explore not just parameters, but entire topological layouts‚Äîstructures that weren‚Äôt human-designed at all.

- Hybrid Models
  Use backprop within evolved structures for local refinement‚Äîbut only inside constraints proven to generalize.

- Cross-Domain Transfer
  Apply L7A-style evolution to noisy domains beyond finance: threat detection, navigation, multi-agent coordination.

‚ÄúI‚Äôve shown a light at the end of the tunnel. Now all we need to do is open the tunnel.‚Äù

VII. Intelligence Is Environment-Shaped
All intelligence is shaped by the environment that selects for it.

Humans evolved in a world of gravity, light, scarcity, predators, and cooperation. Our intelligence reflects that world. An intelligence evolved elsewhere‚Äîon a different planet, or in a digital landscape‚Äîwould not resemble us. It might not be verbal, social, or even symbolic.

What we call intelligence is a reflection‚Äînot the mirror.

This has implications for AGI. If we want to build systems that generalize in any environment, we must evolve them within that environment‚Äînot merely train them with past data.

VIII. Toward Fundamental Intelligence
There may be a deeper substrate beneath all intelligences‚Äîregardless of their environment or expression.

That substrate is not language. It is not backpropagation. It is not architecture.

It is evolution, entropy, and energy.

- Evolution guides structure toward survival
- Entropy forces information to compress meaningfully
- Energy constrains what‚Äôs possible in any system

Any intelligence that survives must contend with these forces. L7A succeeds not because it emulates human cognition, but because it embodies the logic of survival under structure.

IX. Conclusion: The Structure of Things to Come
L7A didn‚Äôt arise from scale. It arose from constraint.

It works‚Äînot because it was trained better, but because it was structured right from the start. That‚Äôs the real lesson. Backprop can tune, but only evolution can shape. Until we embrace this missing phase, we will continue to build ever-larger models chasing generalization they were never designed to support.

The path forward is clear. Not easy‚Äîbut clear.

Intelligence is not what you train. It‚Äôs what survives.

Appendix: The Spirit of the Work
Two quotes from The Who that echo the heart of this project:

1. ‚ÄúWe won‚Äôt get fooled again.‚Äù
   ‚Äî The call to resist overfitted optimism and look deeper.

2. ‚ÄúWho are you? Who, who, who, who?‚Äù
   ‚Äî The timeless question of self-aware systems‚Ä¶ and their makers.
L7A

Chapter 1: The Problem No One Solved
‚ÄúThis is a different school ‚Äî one not aimed at mimicking the past, but at surviving the future.‚Äù

For over half a century, some of the brightest minds in science, finance, and technology have tried‚Äîand failed‚Äîto solve one of the most alluring challenges in modern data science: reliably forecasting short-term movements in the S&P 500.

At first glance, it seems like the perfect machine learning problem. Every day, the market produces new data. Every day, algorithms can train, test, and iterate. The potential payoff is enormous‚Äîand the data is public. The prize isn‚Äôt academic. It‚Äôs real, liquid, and waiting.

And yet, across decades of research, institutional investment, and AI breakthroughs, most attempts have ended the same way: with models that either overfit the past or fall apart in the future. Finance textbooks call the market ‚Äúefficient,‚Äù implying that such prediction is impossible. But maybe that verdict wasn‚Äôt based on truth‚Äîonly on failure.

This book tells the story of L7A: a forecasting system that breaks that pattern. It did not emerge from Wall Street. It was not trained on millions of GPUs or fine-tuned with market labels from a secret dataset. It was built quietly, methodically, and with a different philosophy‚Äîone shaped not by academic fashions but by evolutionary principles, probabilistic reasoning, and decades of firsthand experience in AI.

At its heart lies a simple belief: that structure exists. Not in the form of trends, regimes, or clever feature engineering, but in the behavior of the market itself‚Äîburied in noise, yet persistent. The goal is not to chase the past but to survive the future. That requires generalization, not mimicry.

The chapters that follow will explain how L7A was built, why it works, and what its success reveals‚Äînot just about finance, but about intelligence itself.

Chapter 2: Noise, Illusion, and the Myth of Randomness
For decades, the academic world has clung to a powerful idea: that markets are efficient. Prices, it is claimed, reflect all available information. Any pattern visible in hindsight is an illusion‚Äîan artifact of randomness, not structure.

To a first approximation, this claim is true. The S&P 500 is not predictable in the way a sine wave is. Its fluctuations are driven by thousands of interacting forces‚Äîearnings, sentiment, macroeconomics, and geopolitics‚Äîall filtered through layers of speculation, reflexivity, and noise. Most of what we observe is noise.

But that‚Äôs not the same as saying all of it is.

The real challenge lies not in fitting curves to the past, but in identifying invariant behavioral structure beneath the turbulence. And this is where most systems fail. Neural networks overfit. Statistical models regress toward the mean. Feature engineering chases ghosts. Even deep reinforcement learners, when pointed at market data, often discover only the tradeoff between transaction costs and randomness.

Why? Because the signal is weak. It doesn‚Äôt shout‚Äîit whispers. And to hear it, one must strip away the illusion that all predictability is temporary, that nothing persists, and that generalization is impossible.

This is not a problem of computation. It‚Äôs a problem of philosophy. Most approaches treat the market like a pattern to be recognized, rather than a behavior to be understood.

L7A begins with a different assumption: that human behavior‚Äîespecially under risk‚Äîis not random. It is bounded. It is patterned. It repeats‚Äînot in form, but in function. And if we can capture that function, even partially, we gain an edge.

In the next chapter, we‚Äôll begin to explore how L7A does exactly that‚Äîby using trace-based structures, evolved map surfaces, and a classification architecture built not to mimic past outcomes, but to survive in an unpredictable world.

Chapter 3: A Different Species of Intelligence
When most people hear ‚Äúforecasting system,‚Äù they imagine a conventional machine learning pipeline. Historical data goes in, features are extracted, and a model‚Äîperhaps a neural network‚Äîis trained to minimize error on past outcomes. The result: a black box with knobs, gradients, and hopefully, predictive power.

L7A is not that. It‚Äôs not a regression. It‚Äôs not a trend follower. It‚Äôs not even a standard neural network‚Äîthough, in structure, it bears resemblance. It is something else entirely: a map-based, genetically evolved inference system designed not to fit data, but to generalize from it.

That difference is not cosmetic. It is foundational.

Where most models train their weights via backpropagation‚Äîtweaking internal connections based on how wrong they were‚ÄîL7A does the opposite. Its weights are never adjusted to match past errors. Instead, they are accumulated, tested, and selected through an evolutionary process that explicitly penalizes failure to generalize.

This process doesn‚Äôt just ask: How well did you do yesterday? It asks: How consistently do you survive tomorrow?

At the core of L7A is a visual metaphor: a map. Every input trace‚Äîa sequence of behavior from an individual stock‚Äîis projected onto this map, which stores a histogram of directional outcomes. These maps don‚Äôt fit curves. They build terrain. And in that terrain, ridges and valleys emerge‚Äîzones where the same input structure repeatedly leads to a directional move.

Over time, thousands of these traces accumulate. And like a geologist reading erosion patterns in rock, L7A begins to see the shape of underlying structure. Not trends. Not momentum. But something deeper: time-invariant behavior.

This approach has consequences. It means the system does not require retraining. It does not rely on curve-fitting. It does not assume patterns exist‚Äîit proves their usefulness by walking forward through time, and surviving.

The result is a forecasting system that doesn‚Äôt just echo the past. It operates on a different principle entirely. It‚Äôs not trying to guess the market‚Äôs next move based on similarity. It‚Äôs trying to infer the future from a foundation of structural stability‚Äîlearned not by mimicry, but by evolution.

In the next chapter, we‚Äôll open up that structure. We‚Äôll look inside the map surface, the classification layer, and the evolutionary engine that powers it all.

Chapter 4: Anatomy of a Forecast
To understand how L7A generates a forecast, we have to follow the process from the ground up‚Äîfrom the raw data to the final directional signal. Unlike most machine learning systems, this journey doesn‚Äôt pass through feature engineering, neural activations, or stochastic optimization. It passes through something more primitive‚Äîand more powerful: map surfaces shaped by behavioral trace patterns.

Let‚Äôs begin at the input.

Each day, L7A ingests the recent price history of every equity in the S&P 500. These price histories‚Äîcalled traces‚Äîare not raw percent changes or normalized indicators. They are structured time series: compressed, shaped, and scaled according to evolutionary parameters optimized for generalization. Think of them as behavioral fingerprints‚Äîcompact signatures of recent action.

Each trace is projected onto a map surface: a fixed-size, two-dimensional grid where each cell stores a histogram of past directional outcomes. If a particular trace shape has repeatedly preceded a market rise, the corresponding cell becomes skewed toward positive classifications. If it leads to noise or reversal, the histogram reflects that ambiguity.

But here‚Äôs the key: these maps are not trained via error correction. They are accumulated over thousands of walk-forward days, and their structure is refined through evolution, not gradient descent. Each map configuration competes in a population, tested solely on out-of-sample data. Only those that generalize‚Äîby accurately forecasting tomorrow based on today‚Äôs map activations‚Äîsurvive and mutate forward.

This is where the magic begins. When hundreds of individual equity traces hit their respective maps, they cast directional votes‚Äîbinary, +1 or -1‚Äîbased on their cell‚Äôs histogram. These votes are aggregated, filtered, and weighed into a composite forecast for the entire market.

The result is a single directional signal: long, short, or zero.

And that signal does not come from any one model. It emerges from an ensemble of maps‚Äîeach evolved independently, each seeing the world through a different lens. Some are narrow and sharp, others wide and smooth. But together, they form a surface of collective inference. Like organs in a nervous system, they act in unison to predict the next step.

In the chapters ahead, we‚Äôll explore each component in detail: the encoding of traces, the structure of maps, the Bayesian update layer, and the evolutionary cycle that drives continual refinement. But for now, one thing is clear:

L7A doesn‚Äôt guess the future. It accumulates structure, filters noise, and evolves the ability to see patterns that persist‚Äîno matter how turbulent the world becomes.

Below is an image of one of the map surfaces showing the 96 equity ‚Äútraces‚Äù and their related histograms- encoding the probable outcome. Many of these surfaces are used to form the final output. They are near cousins to neural net ‚Äúlayers‚Äù, but are determined in a formal statistical method as compared to backpropagation of errors.

IMG_7036

 

Chapter 5: The Map is the Model
If L7A has a soul, it lives in the map surface.

Each map is a fixed-size grid, typically two-dimensional, whose cells accumulate evidence over time. That evidence comes in the form of traces‚Äîbehavioral patterns from recent equity movement‚Äîprojected into the grid by encoding functions shaped through evolution.

Each trace hits a location on the map, and the cell it strikes is updated. But what‚Äôs stored there isn‚Äôt a weight in the usual sense. It‚Äôs a histogram: a count of how many times that input pattern led to a market rise versus a market fall the next day.

These histograms are the heart of L7A‚Äôs inference engine. They do not fit curves. They do not chase trends. They simply count.

This may sound primitive, but it is anything but. Because what emerges from this aggregation is a remarkably stable surface‚Äîone that resists noise and highlights structure. Certain regions light up with directional clarity. Others remain ambiguous. Over time, the map becomes a visual topography of behavioral consequence.

To convert those histograms into actionable signals, L7A applies a classification layer. In the standard version, this is a binomial probability estimate: the fraction of up versus down outcomes, possibly adjusted by Bayesian smoothing to account for sample size.

But L7A is not married to Bayes. In fact, other internal systems‚Äîlike DX48‚Äîuse a different method entirely: confidence intervals derived from sample size and directional skew. In this variant, a cell‚Äôs score is not interpreted as a probability, but as a confidence-weighted indicator: how sure we can be that this cell means ‚Äúup,‚Äù given how many times it‚Äôs been hit and how extreme its bias.

The point is not the statistical method. The point is the structure: inference from count-based surfaces, shaped by behavior, and subjected to evolutionary filtering for generalization.

This is what makes the map not just a memory, but a model. It stores what worked‚Äînot because it was trained to‚Äîbut because it survived. And because maps are visual, they can be interpreted. You can see the ridges, the valleys, the convergence zones. You can tell whether a prediction comes from strength or from noise.

And that interpretability is not a side benefit‚Äîit‚Äôs part of the design. Because if you can see how your model thinks, you can test whether it‚Äôs sane. That‚Äôs a luxury most neural networks don‚Äôt afford.

In Chapter 6, we‚Äôll zoom out again and show how many such maps form an ensemble‚Äîhow the votes are tallied, filtered, and collapsed into a single directional signal. But before we leave this chapter, remember this:

In L7A, the map is the model. Everything else is just scaffolding.

Chapter 6: The Wisdom of the Ensemble
One map can learn. A hundred maps can generalize.

L7A doesn‚Äôt rely on a single master surface to forecast the market. Instead, it deploys an ensemble: a population of independently evolved maps, each with its own structure, encoding scale, and behavioral fingerprint. These maps see the same world‚Äîbut from different vantage points.

Why? Because no single projection captures the whole truth. One map might focus narrowly on recent volatility. Another might stretch its trace encoding to absorb longer memory. One may evolve to reward sharp reversals; another may track slow continuation. Each map encodes a hypothesis about what matters‚Äîand only those whose votes consistently help the ensemble survive are retained.

This diversity is no accident. It is the result of evolutionary pressure, not architectural design. L7A doesn‚Äôt hand-pick maps or tune them for orthogonality. It simply lets them compete. Those that forecast well‚Äîon future data, not past‚Äîsurvive and mutate. Over time, the population converges on a collection of useful perspectives, filtered by walk-forward success.

Each day, as new traces are fed into the system, they activate locations across every map. These locations vote‚Äîbinary signals, +1 or -1‚Äîbased on the histogram in that cell. Some votes are strong; some are weak. Some maps abstain entirely if the trace lands in an ambiguous zone.

The votes are aggregated, filtered, and tallied. The result is a directional ensemble signal: long, short, or zero. This final decision is not driven by any one model‚Äîit emerges from the overlap and confidence of many.

And here lies one of L7A‚Äôs most subtle strengths: it suppresses noise through redundancy. Where one map may be fooled by noise, ten are not. Where one sees a phantom signal, the others remain neutral. Over time, this averaging effect yields not just accuracy‚Äîbut stability.

This is not ensembling in the casual sense. It is not bagging, boosting, or stacking in the machine learning tradition. It is survival-based aggregation: models earn their place through walk-forward merit, and their votes are counted only when they reflect demonstrated reliability.

The result is a system that adapts without adapting. The maps don‚Äôt change daily. They are stable. What changes is the pattern of trace activations‚Äîand how those activations land across a structurally diverse surface.

This is why L7A rarely needs retraining. Its ensemble is not trained to fit. It is evolved to generalize. The signal comes not from optimization, but from structural redundancy and directional convergence.

In Chapter 7, we‚Äôll turn our attention to how this signal is interpreted in live deployment‚Äîhow forecasts are handled, how abstention works, and why L7A prefers to remain silent rather than speak without confidence.

 

 

 

Chapter 7: Discipline at the Decision Boundary
‚ÄúWhat matters is whether it works.‚Äù

That‚Äôs not just a conclusion‚Äîit‚Äôs the principle that shaped the system.

In forecasting, there is a temptation as old as modeling itself: to always produce an answer. Most systems do. Whether the data is strong, weak, ambiguous, or noisy, the model responds with a prediction‚Äîoften because it was designed to.

L7A does not share that compulsion.

When the evidence is unclear, when the map activations scatter, or when the ensemble lacks consensus, L7A does something almost unheard of in machine learning systems: it abstains.

This is not a bug. It‚Äôs not a fallback. It‚Äôs a principle.

The architecture of L7A enforces this discipline at multiple levels. First, individual maps may decline to vote when their activation lands in a low-confidence cell. Then, across the ensemble, directional votes may cancel‚Äîyielding no statistical edge in either direction. Finally, the decision layer evaluates the signal‚Äôs strength. If the conviction is weak, the forecast is zero.

This built-in reluctance to act without clarity is what gives L7A its stability. It is not reactive. It does not chase the market. It only speaks when it has something to say‚Äîwhen the behavioral structure aligns, the ensemble agrees, and the map history supports the call.

And that restraint has a measurable effect. Over thousands of walk-forward days, L7A produces a nonzero forecast only when the statistical edge is present‚Äîyielding a high true positive rate, a low false positive rate, and a return stream that reflects discipline, not frequency.

This stands in sharp contrast to neural networks trained on daily classification tasks, where outputs are always forced‚Äîeven when confidence is low. In finance, such compulsion is dangerous. Acting without edge is indistinguishable from gambling.

But L7A is not a gambler. It is an inferential system built for adversarial conditions. And in adversarial domains, silence is signal. It tells us: the world has changed, the structure is unclear, or the confidence is insufficient. And that, too, is information.

This discipline at the decision boundary is not merely risk control. It is a philosophical stance. L7A does not promise clairvoyance. It promises generalization‚Äîand only when it has earned the right to speak.

In the next chapter, we‚Äôll step back to examine what makes this performance so unusual. We‚Äôll quantify the walk-forward results, the error rates, and the statistical rigor behind L7A‚Äôs claims‚Äîbecause in the end, what matters isn‚Äôt how elegant the system is.

What matters is whether it works.

Chapter 8: Performance Without Excuses
It‚Äôs easy to build a model that performs well in backtests. It‚Äôs much harder to build one that survives in the future.

Every algorithm looks smart in hindsight. Curve-fitting is cheap. Feature engineering can manufacture signals. Overfitting, once considered a bug, is now a standard tool in the arsenal of financial machine learning.

But L7A was never designed to win backtests. It was designed to survive walk-forward reality‚Äîand to do so without excuses, without retraining, and without the crutches of regime detection, momentum, or trend following.

The benchmark for L7A is brutal: does it forecast the S&P 500 tomorrow, using only information available today‚Äîwith no peeking, no adjustments, and no second chances?

The answer is yes. Over thousands of consecutive, walk-forward days, L7A outputs a directional forecast‚Äîlong, short, or abstain‚Äîand tracks the market‚Äôs next-day movement. No labels are reused. No data is revised. And the results are staggering:

- Win/loss points ratio (OOS): 72%
- Sharpe Ratio: 3.0
- Sortino Ratio: 4.51
- Total Net Return (1-day hold strategy): 25,294 GSPC points
- Maximum Drawdown: -247 points

These metrics are not the product of tuning. They are the emergent properties of a system that evolves to generalize. No hand-crafted filters. No optimization against the test set. Just raw walk-forward truth.

What‚Äôs more, L7A achieves these results without ever requiring retraining. The same ensemble of maps performs across the full span of historical data. That‚Äôs not just convenience. It‚Äôs proof of time-invariant behavioral structure‚Äîa discovery that cuts to the core of what makes markets not efficient, but human.

Even more remarkably, L7A achieves this while producing forecasts only when confident. It doesn‚Äôt trade every day. It trades selectively. And when it does, it wins.

This isn‚Äôt just statistical success. It‚Äôs structural success. L7A is not rewarded for adapting to noise. It is rewarded for consistency under pressure‚Äîexactly the environment where most machine learning systems collapse.

In the next chapter, we‚Äôll look beyond performance metrics. We‚Äôll explore what this system reveals about markets, intelligence, and the kinds of architectures that can truly generalize in adversarial environments.

But first, remember this:
L7A didn‚Äôt beat the market by chance.
It did it by refusing to guess‚Äîand learning to infer instead.

Chapter 9: When Evolution Learns
Every serious AI researcher knows the history. The perceptron. The winter. Backpropagation. The rise of deep networks. The triumph of GPUs. The cascade of milestones: ImageNet, AlphaGo, GPT. We tell the story with pride‚Äîhow we taught machines to see, speak, translate, and play.

But beneath that triumph lies a tacit assumption: that backpropagation‚Äîthe slow, gradient-based tuning of weights from error‚Äîis the royal road to intelligence. We‚Äôve built an empire on this idea. And for many domains, it works.

But what if we‚Äôve mistaken a tool for a principle?

L7A tells a different story. It is, by any technical definition, a neural network. It has inputs, weights, a decision function, and outputs. But its weights are not learned by error correction. They are accumulated, tested, and selected‚Äînot to fit the past, but to survive the future.

This is not a semantic distinction. It is an architectural divergence.

Backpropagation assumes that intelligence is sculpted by mistakes‚Äîthat if a model performs poorly, we must push its weights in the direction of less error. It is a reactive paradigm, pulling the system toward better behavior one nudge at a time.

But evolution doesn‚Äôt work that way. And neither does L7A.

In L7A, weights are formed through direct exposure to behavior. A trace lands. A count is updated. A histogram grows. Over time, the map forms‚Äînot through fitting, but through structural exposure. It is not tuned‚Äîit is weathered. And only those maps that generalize‚Äîthat make accurate forecasts on unseen data‚Äîare retained and allowed to evolve forward.

This introduces something backpropagation cannot offer: pressure to generalize, embedded at every layer. Generalization is not measured after training‚Äîit is enforced during development. No gradient is ever followed. No training error is minimized. The only thing that matters is whether it works tomorrow.

And it does.

This should force us to re-examine some of our assumptions‚Äînot just in finance, but across AI. We have grown accustomed to overfitting and regularization. We accept that deep networks hallucinate, that they require large data, that they struggle with noise. But maybe that‚Äôs not a necessary tradeoff. Maybe it‚Äôs a symptom of the tools we‚Äôve chosen.

Because in a domain where the data is noisy, sparse, adversarial, and constantly shifting‚Äîlike short-term market movement‚Äîbackpropagation collapses. It cannot maintain generalization. It adapts too much or too little. It either chases ghosts or misses structure.

L7A survives where those systems fail. And it does so because its architecture evolved under pressure to generalize. Every part of it‚Äîtrace encoding, map shape, voting logic‚Äîwas built to pass a single test: can you forecast without curve-fitting?

That question lies at the heart of not just finance, but intelligence.

In nature, intelligence evolved under pressure. Brains were not trained on datasets. They emerged from systems that survived uncertainty. And if we are serious about building general intelligence‚Äîthe kind that can act in the world, adapt to novel conditions, and reason under noise‚Äîthen we must begin to value not just performance, but robustness under evolution.

L7A is not general AI. But it points the way. It is a fully functional system, operating in real time, in a brutally hard domain, with no shortcuts‚Äîand it works. Not because it fits the past, but because it discovers structure that endures. It is not trained. It is selected.

In the chapters that follow, we will explore what this architecture might offer beyond finance. But let this chapter stand as the philosophical turning point:

Intelligence is not what mimics best.

It is what survives.

Chapter 10: Beyond the Chart
L7A was born in finance. But its principles were not.

The system doesn‚Äôt know it‚Äôs forecasting a market index. It doesn‚Äôt understand earnings, interest rates, or geopolitics. What it sees is behavior‚Äîstructured, repeatable, and embedded in time. What it responds to is consequence: what happened after a certain pattern appeared.

This detachment from domain-specific semantics is not a weakness. It‚Äôs a strength. It means the architecture is not bound to trading. It can be applied wherever inference under uncertainty is required‚Äîespecially when the data is noisy, sparse, and adversarial.

And that opens a new frontier.

Imagine using L7A-like map surfaces in robotic navigation, where movement traces lead to terrain outcomes. Or in medical diagnostics, where patient histories form behavioral traces, and treatment responses become directional signals. Or in autonomous agents, where internal state trajectories yield outcome probabilities‚Äîand abstention, not guessing, is rewarded.

The possibilities stretch far beyond finance. Because what L7A demonstrates isn‚Äôt just a clever technique. It‚Äôs a new kind of inference engine: one that does not learn by mimicking, but by surviving. One that evolves structure instead of approximating it. One that resists noise instead of absorbing it.

This matters.

It matters because most of our current AI systems fail in the same predictable ways: overconfident in sparse data, brittle under distribution shift, blind to their own uncertainty. They hallucinate. They overfit. They extrapolate poorly. And we accept this as normal.

But L7A offers an alternative. Not a neural network replacement, but a complementary architecture‚Äîone that trades expressive power for robust generalization under pressure. It works not by finding the best fit, but by accumulating what survives.

This approach‚Äîevolution under generalization pressure‚Äîcould be the missing ingredient in our pursuit of general intelligence. Not as a replacement for deep networks, but as a substrate for stability. A layer that filters, remembers, infers, and abstains.

And perhaps most importantly, it provides a different lens on intelligence itself. One that says:
- Intelligence isn‚Äôt fast‚Äîit‚Äôs robust.
- Intelligence isn‚Äôt clever‚Äîit‚Äôs persistent.
- Intelligence doesn‚Äôt emerge from tuning.
  It emerges from surviving.

L7A is not the final word. But it is a new sentence‚Äîone worth writing across more domains.

 

 

 

Chapter 11: Same Output, Different Futures
 

At first glance, neural networks seem like ideal inference engines. They take an input, process it through layers of nonlinear transformation, and output a result. Train them on enough examples, and they learn to map the right input to the right output. Problem solved‚Äîon paper.

But that‚Äôs the problem.

For any given input-output mapping, there are countless internal weight configurations that all produce the exact same result on the training data. And yet, when faced with slightly altered inputs, these different configurations can diverge wildly in behavior. This is a critical issue- the existence of multiple weight configurations that produces similar training performance but vastly different generalization behavior. This relates to something called the ‚Äúlottery ticket hypothesis‚Äù and mode connectivity in backprop neural networks.

The issue isn‚Äôt in the mapping‚Äîit‚Äôs in the internal representation.

This is the underappreciated failure mode of backpropagation-based learning. It does not enforce structure. It does not reward robustness. It only minimizes error on what it has already seen. As long as the output matches the label, the internal logic is unchecked.

Modern neural networks attempt to patch this with regularization: dropout, weight decay, pruning, and other tricks. But these methods are external patches, not structural solutions. They may reduce overfitting, but they do not guarantee internal smoothness or robustness. A network can still arrive at a brittle internal configuration that simply happens to pass through regularization‚Äôs loose filter.

The result? Two networks may perform identically in training, but one has learned a smooth, general representation‚Äîwhile the other has memorized the landscape with fragile precision. On novel inputs, one remains sane. The other collapses.

In domains like image classification or text prediction, this brittleness can often be masked by data volume or redundancy. But in noisy, low-data environments‚Äîlike short-term market forecasting‚Äîthere is no such cover. The illusion of generalization is quickly shattered.



L7A was designed specifically to survive this regime. It does not rely on any single configuration of weights. It does not learn by fitting. It evolves structure under pressure to generalize. Every map surface must prove itself‚Äînot just by mapping past inputs to known outcomes, but by forecasting future ones it has never seen.

This evolutionary filter is what gives L7A its edge. It cannot accidentally learn a brittle structure and survive. Only robust, transferable behavior patterns are selected forward. Every count, every trace, every cell in the map earns its place through walk-forward validation.

This is the architectural gap between L7A and conventional neural nets:
- Neural networks optimize for fit.
- L7A evolves for function.
- Neural nets mimic.
- L7A generalizes.
- Regularization attempts to dampen noise.
- L7A demands structure that survives it.

This distinction‚Äîsubtle but profound‚Äîis what separates a system that performs on paper from one that survives the future.

And perhaps most importantly: L7A‚Äôs internal structure is interpretable. You can visualize its maps. You can trace how a signal emerged. You can see the ridges and valleys of confidence. With neural networks, that window is shut. The logic is buried in millions of opaque weights.

 

Chapter 12: The Architecture of What Endures
Every system carries a worldview.

Deep networks suggest that intelligence is a function of scale. The more data, the deeper the stack, the closer we get. Just keep tuning. Keep pretraining. Keep layering. The path to understanding lies in more.

L7A is different. It doesn‚Äôt grow deeper. It grows clearer.

Its architecture suggests that intelligence is not about size‚Äîit‚Äôs about structure. Not in how expressive a network is, but in whether its outputs can survive unchanged when the world shifts. It says the future belongs not to the cleverest algorithm, but to the one that endures.

This isn‚Äôt a romantic ideal. It‚Äôs a testable one.

Across thousands of walk-forward days in one of the most adversarial data domains on Earth‚Äîthe S&P 500‚ÄîL7A doesn‚Äôt just persist. It thrives. It forecasts not by spotting trends or adapting to regimes, but by capturing stable structures in human behavior. And it does this with no retraining, no labels beyond T+1, and no hand-holding.

That‚Äôs not a finance story. That‚Äôs an intelligence story.

Because in every field where AI falters‚Äîautonomous driving, language hallucination, brittle chatbots, fragile agents‚Äîthe core problem is the same: lack of generalization. Systems fail not because they weren‚Äôt large enough, but because they were trained to fit, not to endure.

L7A offers an existence proof: that it‚Äôs possible to build systems that are forced to generalize by their very design. That by applying evolutionary pressure‚Äînot just backpropagation‚Äîwe can shape architectures whose structure reflects not what the past rewarded, but what the future permits.

This has implications far beyond markets. It asks the field to reconsider what it values: fluency or resilience, adaptation or preservation, cleverness or clarity. It invites a generation of builders to try something bolder:

To stop chasing the past.
And start evolving for the future.

Because in the end, the architectures that endure will not be the ones that mimic best. They‚Äôll be the ones that make the fewest excuses, ask the clearest questions, and hold up under pressure.

L7A is one such architecture. And its legacy may be this:

That generalization is not an outcome.

It is a prerequisite.

Chapter 13: From Idea to Architecture to Edge
What begins as an idea must eventually touch the world. L7A was never meant to remain a thought experiment. It was built to run. To trade. To decide.

And it does.

Every day, across thousands of trading sessions, it takes in raw behavior from hundreds of stocks. It traces those behaviors against a fixed lattice of memory. It updates nothing. It adapts to nothing. It simply compares.

Each trace lands on a surface shaped not by fitting, but by evolution‚Äîhistograms of directional behavior that have survived real-world validation, walk-forward pressure, and statistical challenge. The result is a clean, binary signal: long, short, or abstain. No momentum models, no moving averages, no optimization of trade exits. Just structure, distilled.

And it works remarkably well..

It works without hype. It works without retraining. It works across years of market regimes, shocks, melt-ups, crashes, and fads. Because what it models is not volatility or news, but behavior itself: the latent inertia, fear, and elasticity of the human condition‚Äîencoded in price.

This is the real legacy of the L7A system: it transforms the vague aspiration of generalization into a working engine of inference. Not by claiming AI mastery, but by forcing the model to earn its forecast‚Äîday after day‚Äîunder the harsh light of walk-forward exposure.

It is here that the design meets its proof.

That structure, when evolved rather than fit, can survive.
That simplicity, when validated, can outperform complexity.
That generalization, when enforced, can become a source of edge.

What follows in the chapters ahead is not theory. It is execution. You will see how L7A was built, tested, deployed, and challenged. And in that process, you‚Äôll see something more:

A blueprint for inference under pressure.
A philosophy in code.
An idea‚Äîmade real.

Chapter 14: Building the Machine
No matter how elegant an idea, it means nothing until it runs. Inference‚Äîreal inference‚Äîrequires instantiation. Structure must take on form. A model must make decisions. Not once, but thousands of times. Under pressure. Without excuses.

This is where L7A comes alive.

At its heart, L7A is a machine‚Äînot metaphorically, but literally. A software engine written in C, tuned for speed, determinism, and transparency. There is no stochasticity in its core. No random dropout layers. No backpropagation. It is built to simulate, forecast, and walk forward on every single day of historical market data‚Äîover 5,000 sessions‚Äîwithout ever seeing the future.

The architecture is modular. It starts with inputs: not price percent changes, but traces‚Äîmultiday patterns compressed into gridable forms. These traces are aligned in time (with T‚ÇÄ as the decision point) and scaled using a surface profile that determines how much weight each day in the trace contributes to classification.

Then comes the map.

Each trace is fed into a lattice: a 2D histogram surface where contributions accumulate. These surfaces are directional‚Äîsplit by whether the forecast outcome on the following day was up (+1) or down (-1). With thousands of such surfaces evolved across cross-validation folds and equity subsets, the system constructs a kind of distributed memory: a terrain of behavioral likelihoods.

But the magic is not in how this memory is constructed. It is in how it is tested. Every configuration is evaluated not on its training fit, but on its walk-forward generalization. Maps are evolved under pressure‚Äîusing genetic algorithms that reward consistency, clarity, and predictive edge, not raw accuracy.

And then the machine speaks.

For each new day, L7A scans its ensemble. It aggregates surface contributions. It computes directional confidence. And it outputs a simple, clean signal: +1 (go long), -1 (go short), or 0 (abstain). There is no smoothing. No post-hoc adjustment. No retry.

This is the backbone of L7A: a fully deterministic, fully auditable inference engine that doesn‚Äôt adapt to the past, but survives the future.

It took years to get here. But what emerged is a system that demonstrates not just how forecasting can be done‚Äîbut how it should be done.

With clarity. With restraint. And above all, with proof.

Chapter 15: Validation Under Fire
From the outside, a forecast is just a guess. From the inside, it is the result of an entire system‚Äîscales, surfaces, algorithms, and decisions‚Äîaligning to produce a directional call. But what separates a guess from a model is this: a guess cannot survive scrutiny.

L7A can.

Validation is not a formality. It is a crucible. And every element of L7A was designed with this in mind: to endure a level of testing that most systems avoid. No cherry-picked periods. No regime-aware training sets. No hyper parameter ‚Äúmassaging.‚Äù Just a brutal, walk-forward confrontation with reality‚Äîover 5,000 consecutive trading days.

Every day, the system is asked the same question: long, short, or abstain? It answers without access to the future. It holds for one day. It records the result. No optimization, no resets. Just forward motion.

The forecast stream that emerges from this process is not an artifact of curve-fitting. It is a living record of structural behavior being detected across a vast ensemble of price traces. A record that includes:

- A Win/loss points ratio (OOS) of 73%.

- A false positive rate near 38%,

- A Sharpe ratio above 3.0,

- And a cumulative return exceeding 25,000 GSPC points under a simple 1-day hold strategy.

No retraining was ever applied. No regime switches were detected. No adjustments were needed to maintain performance.

Why does this matter?

Because inference under fire is the only kind that matters.

L7A does not trade on hindsight. It does not rely on human supervision. It does not wobble when volatility surges or sentiment turns. It remains grounded in structure‚Äîand that structure persists.

The system‚Äôs performance is not a boast. It is a signal. A signal that something durable has been found. Something invariant. Something that reaches through noise and delivers clarity.

And that, ultimately, is what this book has been building toward: not an idea, but a demonstration.

Chapter 16: Critical Environments and the Shape of Intelligence
In some environments, a wrong answer is just a setback. In others, it‚Äôs catastrophic.

This chapter explores where L7A-style architectures‚Äîthose built for inference under noise, uncertainty, and time pressure‚Äîbecome not just useful, but essential. These are critical environments: domains where decisions must be made with incomplete data, where delay is unacceptable, and where getting it wrong carries real-world cost.

Finance is only the beginning.

Consider the battlefield. Intelligence feeds flood in: satellite images, troop movements, signal intercepts. A commander must decide: strike, retreat, or reposition. Each decision rests on a map‚Äîliteral and figurative‚Äîof behavioral probability. In such a domain, models that overfit past conflicts are deadly. L7A‚Äôs emphasis on generalization, abstention, and probabilistic clarity makes it an ideal foundation for battlefield inference: it doesn‚Äôt mimic war, it learns how uncertainty behaves.

Or consider medicine. Early diagnosis often means catching a weak signal hidden inside a vast background of normal variation. MRI scans, blood panels, patient history‚Äîall incomplete, all noisy. Here too, the challenge is not fitting what‚Äôs known, but generalizing across what isn‚Äôt. Systems that survive under real-world uncertainty‚Äîlike L7A‚Äîare more likely to make the leap from pattern detection to life-saving prediction.

National security, pandemic response, critical infrastructure forecasting, even pilot support in high-pressure flight scenarios‚Äîall present inference problems that cannot be solved with hindsight-trained models alone. They require what L7A was built to offer: robustness without retraining, clarity under pressure, and decisions grounded in structure, not assumption.

What makes L7A‚Äôs architecture so promising in these domains is its restraint. It doesn‚Äôt hallucinate. It doesn‚Äôt extrapolate where it has no grounds. When uncertain, it abstains. When confident, it commits. This behavior is not accidental‚Äîit‚Äôs the result of a machine built not to impress with complexity, but to survive with integrity.

We often ask whether AI is ready for the real world. But that question is inverted. The real world is already here. The better question is: which architectures are ready to face it?

In critical domains, the cost of getting it wrong is too high to pretend.

And in those domains, L7A might not just be useful‚Äîit might be necessary.

Chapter 17: Beyond the Signal ‚Äì A Philosophy of Inference
By now, the mechanics of L7A are clear: maps, traces, surfaces, inference. But behind the machinery is something deeper‚Äîa philosophy of how intelligence should behave under uncertainty.

This chapter steps back from the wires and weights to ask a larger question: What does L7A *mean*? Not just as a tool, but as a signal itself. What does it reveal about the nature of generalization, and about the path intelligence might take when stripped of mimicry and forced to survive on its own?

Inference is not classification. It is not prediction. It is the act of drawing conclusions under incomplete knowledge. And in the real world, knowledge is *always* incomplete.

Traditional machine learning sidesteps this problem by overwhelming it: more data, more layers, more memory. But the more you memorize, the less you understand. And when the world changes‚Äîas it always does‚Äîmemorization becomes a liability.

L7A takes the opposite path. It begins with the assumption that the world *will* be noisy, that the data *will* be insufficient, and that the only way forward is to develop structure that holds across time. It‚Äôs not just a model‚Äîit‚Äôs a survival strategy.

This strategy echoes something older than software: evolution itself. In nature, creatures survive not by knowing the future, but by evolving behaviors that generalize across changing environments. L7A mimics this strategy‚Äîtesting, refining, and evolving not based on what worked yesterday, but on what endures.

That is why L7A resists retraining. Why it abstains when unsure. Why it doesn‚Äôt adjust for market 'regimes.' These are not technical choices‚Äîthey are philosophical ones. They are decisions rooted in a view of intelligence that values **robustness over reactivity**, **clarity over complexity**, and **generalization over fit**.

And this philosophy extends beyond markets. It touches the future of AI itself. If we wish to build systems that reason under uncertainty, that adapt without hallucinating, that perform without pretense‚Äîthen L7A is not just a financial forecasting engine. It is a **blueprint for inference under pressure**.

The world doesn‚Äôt need more models. It needs more systems that can think clearly when the stakes are high and the data is thin. Systems that aren‚Äôt fooled by noise. Systems that know when *not* to speak.

That‚Äôs what L7A is becoming. Not just a tool. But a teacher.

Chapter 18: The Silence Between Forecasts
What a system does when it speaks matters. But what it does when it chooses *not* to‚Äîthat‚Äôs where its true character is revealed.

Chapter 18 focuses on one of L7A‚Äôs most underrated traits: its ability to remain silent. The system makes a directional forecast‚Äîlong or short‚Äîonly when the signal is strong enough to justify the risk. When it‚Äôs not, it issues no prediction at all.

This is not a weakness. It‚Äôs a feature. A philosophical stance encoded in logic.

Traditional models often force a guess, because their value is measured by output volume. Every day, a number. Every tick, a classification. But real-world systems‚Äîespecially those deployed in high-stakes environments‚Äîdon‚Äôt need to act constantly. They need to act *correctly*.

L7A embodies this principle by incorporating **abstention** as a first-class behavior. It is not indecision‚Äîit is restraint. The system has learned that the cost of a wrong forecast often exceeds the opportunity cost of waiting. And so it waits.

This silence is strategic. It prevents erosion of trust. It avoids the illusion of omniscience. And it builds something rare in machine learning: **credibility over time**.

Think of it this way: in human conversation, we trust those who pause to think. We doubt those who answer every question instantly, no matter how complex. L7A is that thoughtful speaker. It considers, it weighs, and when it speaks, it means it.

This chapter explores how abstention is computed, how it's managed in live deployment, and why this behavior turns L7A from a reactive tool into a **mature inference engine**. It's not just forecasting‚Äîit's knowing when forecasting would be noise.

In a world obsessed with output, L7A‚Äôs silence is its most powerful voice.

Chapter 19: Compression, Clarity, and the Path to Understanding
Complexity is not intelligence. If anything, it is the enemy of clarity‚Äîand clarity is the bedrock of understanding.

L7A is not a black box. It‚Äôs a map. It builds surfaces that can be visualized, interpreted, and understood. Each weight is the result of observed behavior. Each cell tells a story. This is not just a design choice‚Äîit‚Äôs a philosophical stance: *make the structure visible*.

The world of deep learning has drifted toward opacity. Layers stacked upon layers. Millions, sometimes billions, of weights, trained by backpropagation on unfathomable amounts of data. And while performance metrics rise, interpretability falls. The result: systems that can perform but cannot explain.

L7A pushes in the opposite direction. It seeks compression. Not lossy in the traditional sense, but semantically rich: to express meaningful behavior with minimal structure. To find the essence, not the echo. To preserve signal by **distilling** rather than expanding.

This chapter walks through how L7A‚Äôs surfaces compress behavioral input into spatial form, how its evolutionary process avoids unnecessary complexity, and how that compression enables **robust generalization** rather than brittle mimicry.

In this view, clarity is not a luxury‚Äîit‚Äôs a requirement. If a structure cannot be visualized, it cannot be trusted. If a model cannot be interpreted, it cannot be verified. Compression forces discipline. It makes the cost of complexity visible. It demands **economy of inference**.

And so the model becomes a teacher again‚Äînot just for markets, but for us. It reminds us that true understanding doesn‚Äôt come from stacking more layers. It comes from peeling them away, until what remains is simple, stable, and strong.

The path to general intelligence may not be upward. It may be inward‚Äîtoward compression, clarity, and control.

Chapter 20: The Line Between Noise and Knowledge
All systems that seek to forecast must confront one final frontier: the boundary between what can be known and what cannot.

This is the edge where inference breaks down, where structure ends and chaos begins. It is not a bug in the system. It is a feature of the world.

L7A doesn‚Äôt try to conquer this boundary. It honors it. It approaches the unknown not with arrogance, but with measurement. Its strength lies not in forecasting everything, but in knowing when not to.

The map surfaces it constructs are an echo of this philosophy. Where the terrain is smooth and stable, it makes confident predictions. Where it is sparse, volatile, or contradictory, it abstains. And in that abstention, there is wisdom.

This chapter reflects on the deepest philosophical dimension of the L7A system: that *generalization is not about control‚Äîit is about adaptation.* The market will always evolve. Noise will always exist. But if a model is shaped by the **discipline of survival**, it will find the signal again and again, across decades, without chasing ghosts.

True intelligence does not declare mastery over noise. It survives through it. It builds internal models that are not perfect mirrors of the past, but imperfect, resilient schemas that function *despite* uncertainty.

That is what L7A has become. Not an oracle. Not a mimic. But a system that learns just enough to persist‚Äîand that defines the upper boundary of what any intelligence, artificial or otherwise, can achieve.

We close here not with a celebration of final answers, but with something far more enduring: a method. A discipline. A way of seeing.

The line between noise and knowledge will never disappear. But with the right tools, and the right philosophy, we can learn to walk it.

Appendix A: Glossary of Key Terms and Concepts
Abstention: The act of withholding a forecast when confidence or signal strength is insufficient, used by L7A to reduce false positives and enhance reliability.

Backpropagation: A method of training neural networks by adjusting weights through error gradients. Not used in L7A, which relies on evolved, generalization-first weight structures.

Bayesian Updating: A statistical method to revise probabilities as new evidence is introduced. Used in L7A to interpret histogram surfaces, although alternate methods like DX48 confidence intervals are also employed.

DX48: A variant of the L7A map surface architecture that uses statistical confidence intervals rather than Bayes‚Äô rule to convert surface weights into forecast probabilities.

Forecast Surface (Map): A 2D histogram of directional outcomes built from trace inputs. Each map surface encodes behavioral structure, forming the foundation of L7A‚Äôs inference mechanism.

Generalization: The ability of a model to perform well on unseen data. L7A is explicitly evolved to maximize generalization, unlike traditional networks that often optimize for fit.

Genetic Algorithm (GA): A class of optimization technique inspired by biological evolution, used in L7A to evolve histogram structures that survive generalization pressure.

Histogram: A statistical representation of frequency counts. In L7A, each map surface bin accumulates directional (+1/-1) outcomes for classification purposes.

Map Surface: Another term for the forecast surface; a structured array of weights that respond to input traces and contribute to directional inference.

NLDE (Noisy, Low Data Environment): A domain characterized by sparse, volatile, or adversarial data where traditional ML models often fail. L7A is specifically built to function in NLDEs.

Posterior Probability: The probability of a forecasted outcome (e.g. up/down) given observed evidence, calculated using either Bayesian or alternative statistical techniques.

Sharpe Ratio: A measure of risk-adjusted return, often used to evaluate trading systems. L7A‚Äôs Sharpe ratio exceeds 3.0 under standard one-day-hold testing.

Signal Integrity: The clarity and reliability of a forecast signal. L7A improves signal integrity through ensemble averaging, abstention, and surface weighting.

Trace: The series of normalized price changes or other features feeding into a map surface, representing a short behavioral history.

True Positive Rate: The percentage of correct directional forecasts when a prediction is made. L7A‚Äôs historical true positive rate exceeds 75%.

Zero Forecast: A noncommittal forecast (abstention) output by L7A when the directional evidence is insufficient to justify a trade.

Appendix B: L7A System Architecture Overview
The L7A forecasting system is a structured, multi-layered architecture designed to extract meaningful behavioral signals from noisy financial environments. Its core components‚Äîtraces, map surfaces, forecasting traders, and ensemble logic‚Äîwork together to produce high-confidence next-day forecasts of S&P 500 direction.

1. Trace Inputs
Each input to L7A begins as a normalized behavioral trace‚Äîtypically a short history of price changes (e.g., last 8‚Äì15 days) from one of the ~500 constituent equities in the S&P 500. These traces are normalized for scale and encoded into a spatial pattern that can be mapped to a histogram surface.

2. Map Surfaces (Forecast Surfaces)
Each trace is projected onto a 2D histogram known as a map surface. Each bin within this surface counts directional outcomes (+1 for up, -1 for down) observed historically for traces that landed in that bin. These surfaces evolve over time using genetic algorithms to maximize generalization on out-of-sample data. One such map‚Äîthe 3D-rendered 96-trace map‚Äîis a visual example, but L7A utilizes hundreds of these maps in total.

3. Forecasting Traders
Each map surface informs one or more forecasting traders. A trader is a decision-making unit that outputs a signal of +1, -1, or 0 (long, short, or abstain) based on the directionality inferred from its associated map. Traders may employ Bayesian or DX48 confidence interval logic to derive probabilistic decisions from their surface statistics.

4. Ensemble Decision Process
The L7A system integrates hundreds of forecasting traders in a weighted ensemble. Each trader contributes a directional vote, and the ensemble resolves these into a unified forecast. Abstentions reduce noise, while strong consensus signals enhance confidence. This ensemble design is crucial for L7A‚Äôs ability to survive adversarial environments and maintain performance over decades.

5. Output Stream
The final output is a single daily forecast: +1 (go long), -1 (go short), or 0 (abstain). These forecasts are evaluated using a one-day-hold wrapper strategy, and form the basis for the system‚Äôs return stream. Performance metrics like true positive rate, Sharpe ratio, and drawdown are measured on this stream.

6. Architectural Philosophy
Unlike traditional neural networks that learn by adjusting weights via backpropagation, L7A evolves its internal structure. Its architecture is built for generalization first, not mimicry. It is robust in Noisy, Low Data Environments (NLDEs) and has no need for retraining. This core design principle has enabled L7A to succeed where others fail.

Appendix C: Evolution of the Forecasting Engine
The L7A forecasting engine is the culmination of decades of experimentation with neural networks, statistical inference, and evolutionary algorithms. This appendix outlines the system‚Äôs developmental trajectory, highlighting the conceptual breakthroughs that shaped its architecture and enabled its exceptional performance in noisy financial environments.

1. Early Experiments with Neural Networks (1990s)
Initial work in the 1990s explored traditional neural networks coded in C using backpropagation. Though functionally correct, these models failed to generalize in financial environments. Even with regularization, weight decay, and pruning, they tended to overfit, hallucinate patterns, or degrade rapidly in walk-forward tests.

2. Shift Toward Evolutionary Design
In response to these limitations, the architecture shifted toward a genetic algorithm approach. Instead of adjusting weights via error gradients, weights were encoded as statistical histograms and evolved under direct generalization pressure. Fitness was based on cross-validated performance, favoring configurations that survived in adversarial, real-world conditions.

3. Birth of the Map Surface
A key innovation was the introduction of map surfaces‚Äî2D histogram fields encoding binary outcomes over behavioral traces. These surfaces allowed direct visual interpretation and statistical inference. Early map systems stored percent returns; later versions transitioned to binary classification to reduce noise and sharpen inference. This change proved pivotal.

4. Ensemble Construction and Trader Logic
Multiple maps were grouped into forecasting traders, each emitting directional predictions. By assembling hundreds of these traders into an ensemble and tracking abstentions, L7A leveraged collective intelligence while filtering out noise. The ensemble outperformed any individual map, thanks to central limit effects and adaptive voting logic.

5. Confidence and Classification Techniques
L7A  uses Bayesian updating to convert map counts into probabilistic forecasts. In other variations‚Äîsuch as DX48‚Äîa confidence interval based on sample size augments Bayes. This method allowed clearer thresholding and more direct statistical calibration, demonstrating the flexibility of the architecture without compromising performance.

6. Validation and Walk-Forward Performance
Throughout its evolution, L7A was constantly validated using n-fold cross-validation, walk-forward holdouts, and asymptotic performance tracking. Repeated trials showed convergence around a 75% true positive rate‚Äîa strong indicator that the system was discovering persistent structure, not curve-fitting transient noise. This phase marked the transition from experimental tool to robust inference engine.

7. From Forecasting Tool to Philosophical Statement
Over time, L7A became more than a system‚Äîit became a statement about what matters in AI. Its architecture rejects mimicry in favor of survival. It evolves structure, tests generalization directly, and demonstrates that in environments governed by uncertainty and noise, the right question is not 'Did it learn the past?' but 'Can it survive the future?'

Appendix D: Performance Metrics and Validation Protocols
This appendix outlines the quantitative framework used to evaluate the L7A system‚Äôs performance. Emphasis is placed on walk-forward validity, generalization metrics, and standardized financial performance measures. The goal is to demonstrate that L7A‚Äôs forecasting advantage is not an artifact of curve-fitting, but a genuine result of structural discovery.

1. Forecasting Accuracy
L7A emits directional signals for the next trading day: +1 (long), -1 (short), or 0 (abstain). A true positive is defined as a correct directional forecast (e.g., +1 followed by a price increase). A false positive is an incorrect signal (e.g., -1 followed by a rise). The system consistently achieves a true positive rate (TPR) of approximately 62%, with a corresponding false positive rate of 38%.

2. Abstention as Signal Discipline
L7A includes a ‚Äòzero forecast‚Äô option to abstain when confidence is insufficient. This feature acts as a safeguard against forced predictions, preserving accuracy and reducing risk exposure. Abstention is not treated as a failure, but as a principled act of uncertainty management.

3. Financial Metrics
Performance is evaluated using standard metrics: Sharpe Ratio (risk-adjusted return), Sortino Ratio (downside deviation focus), Cumulative Return, and Maximum Drawdown. Under a one-day-hold wrapper, L7A demonstrates a Sharpe of 3.0, Sortino of 4.55, total return of 25,294 index points, and max drawdown of -247. These results are based on a live forecast stream exceeding 5,000 trading days.

4. Cross-Validation and Holdout Testing
To ensure robustness, L7A uses 10-fold cross-validation during evolution, holding out slices of data to test generalization. No re-training is performed between test and deployment. Instead, surfaces are validated on unseen slices and used directly in forecasting. Performance asymptotes provide independent confirmation that the model extracts repeatable structure.

5. Performance Asymptotes and Generalization
Over time, independent experiments showed performance clustering around a ~75% TPR across varying architectures and setups. This convergence‚Äîdespite data shuffling and architectural changes‚Äîis interpreted as evidence of generalization, not overfit. It reflects a behavioral ceiling: the maximum extractable signal under current data resolution.

6. Visual Comparison and Benchmarking
L7A‚Äôs performance is routinely benchmarked against the S&P 500 index. Bar and line charts compare annual returns, cumulative growth, and drawdowns. These visuals are presented according to the Return Stream Display Protocol, ensuring clarity, reproducibility, and consistent messaging across platforms.

Appendix E: Philosophical Foundations and Design Principles
The L7A system is not merely a technical innovation‚Äîit is a principled stand against the failures of overfitting, the seduction of transient patterns, and the blind pursuit of complexity. Its architecture is rooted in a set of philosophical convictions about what it means to generalize, to learn from experience, and to build systems that survive the future.

1. Generalization Over Fit
L7A was designed to solve the most important problem in inference: generalizing to unseen data. The system does not optimize for perfect recall of past input-output pairs. Instead, it favors weight structures that survive repeated out-of-sample tests. The design premise is simple: what matters is whether it works‚Äînot whether it fits.

2. The Rejection of Retraining and Regimes
In contrast to contemporary systems that require routine retraining or regime detection, L7A assumes that true structure in financial behavior should persist across time. If a system degrades without retraining, it never understood the market in the first place. L7A embodies this belief by maintaining static map surfaces after training, relying on their time-invariant encoding of behavior.

3. Edge Exists Only at Entry
L7A enforces the idea that no amount of downstream trade management can salvage a poor entry. All statistical advantage must be present at the moment of commitment. The system issues clean, binary signals (+1, -1, or 0) and holds for a fixed period, placing full trust in the forecast‚Äôs integrity.

4. Behavioral Terrain and Evolved Maps
Each map in L7A represents a visual surface, built from hundreds or thousands of historical traces. These maps are not trained by backpropagation but evolved through genetic selection and tested for generalization. This creates interpretable structures‚Äîmountains and valleys of market behavior‚Äîrather than opaque matrices of weights.

5. Evolution as the Core Engine of Intelligence
Where most modern AI relies on backpropagation and exemplar-based training, L7A was built on a different principle: that evolution‚Äînot optimization‚Äîis the natural path to general intelligence. By subjecting its map structures to survival-based selection, L7A models how nature builds resilient systems: not through mimicry, but through pressure-tested generalization.

6. Ethical Imperatives
The motivation for creating and sharing L7A is ethical: to reduce human suffering through the application of reliable AI. In a world full of opaque systems, hype cycles, and speculative technologies, L7A stands as a transparent, empirically validated tool. Its creator believes in empowering others with tools that work‚Äînot just theories that sound impressive.

Appendix F: Historical Development Timeline
The L7A system did not emerge from a single flash of insight, but rather from decades of experimentation, testing, and philosophical refinement. This appendix documents the major phases in its evolution‚Äîfrom its earliest neural network code to its present, walk-forward-tested forecasting architecture. Each phase contributed critical insights and techniques that shaped the final system.

Phase 1: Early Neural Network Work (1997‚Äì2005)
As early as 1997, the developer was coding neural networks in C on DOS-based systems. A photograph of a directory containing source files like EVONN.C, GENNETIC.C, and FASTNN.C confirms the active exploration of weight evolution, genetic networks, and non-backprop architectures more than a decade before deep learning went mainstream. These systems experimented with confidence intervals, genetic mutation, and trace-based inference.

Phase 2: Financial Forecasting and Market Structure Modeling (2006‚Äì2015)
During this phase, the developer focused on financial applications, working with institutions like Deutsche Bank, Fortress Group, and Larry Height. The challenge of generalizing in noisy, low-signal domains became clear. Experiments revealed that traditional neural networks‚Äîeven when well-regularized‚Äîtended to overfit. These experiences informed the pursuit of systems that relied on evolutionary generalization pressure.

Phase 3: Emergence of Map Surfaces and Histograms (2016‚Äì2020)
This period marked the conceptual breakthrough: map surfaces as histogram fields capable of encoding directional behavior. The move away from average percent change regression toward binary classification (+1 or -1) allowed L7A to sharpen its inference and reduce noise. The binary histogram approach enabled direct statistical interpretation of forecast confidence.

Phase 4: Ensemble Construction and Multi-Trace Maps (2020‚Äì2023)
Rather than rely on a single surface, the system began deploying multiple maps‚Äîeach built from distinct equity traces‚Äîto form an ensemble of 'traders'. These traders emit independent forecasts (+1, 0, -1), which are then combined to form a consensus. This phase introduced the 3D trace visualization, demonstrating how behavioral terrain emerges and persists across maps.

Phase 5: Validation, Stability, and Public Readiness (2023‚ÄìPresent)
With walk-forward testing across thousands of days, the L7A system stabilized. Key performance metrics‚Äî72% Win/loss points ratio (OOS), 3.0+ Sharpe ratio‚Äîwere repeatable across held-out data. No retraining was required. The output stream was made public at http://www.itrac.com/fore/output.csv. This phase also saw the formulation of philosophical principles, publication drafts, and outreach to partners.

 

 

Appendix G: Methodological Insights Archive
Over the course of L7A‚Äôs development, numerous key insights emerged‚Äîsome technical, some philosophical. These were not add-ons or afterthoughts; they were crucial inflection points in the evolution of the architecture. What follows is a catalog of the most significant of these methodological breakthroughs.

Generalization by Asymptote
Performance metrics repeatedly converged to the same level‚Äîaround 62% true positive rate‚Äîregardless of architecture or validation split. This ceiling indicated a behavioral boundary in the data and served as an emergent diagnostic for generalization.

Equalizing Influence: Flattening the Trace Scale Profile
Adjusting the map‚Äôs binning profile to give earlier days more influence modestly improved signal consistency, revealing that predictive structure is distributed across time, not concentrated near the present.

From Percent Change to Binary Histograms
Abandoning regression-style percent forecasts in favor of binary classification (+1, -1) improved stability and interpretability. The system now tracks directional behavior rather than magnitude, aligning more naturally with real trader decisions.

Terrain That Doesn‚Äôt Move
Sliding-window animations of map surfaces revealed persistent behavioral features‚Äîridges, valleys, and clusters‚Äîthat remained stable over time. These visualizations confirmed the presence of time-invariant structure.

Same Output, Different Futures
Many different internal representations can map the same input to the same output. But only a few of them generalize. This insight exposed the failure mode of networks that memorize but do not infer.

Edge Exists Only at Entry
All statistical edge must be present at the moment a position is entered. No downstream trade management can recover value from a weak or random entry.

Generalization vs. Mimicry: Why Backpropagation Fails
Backpropagation minimizes error on known examples, but doesn‚Äôt enforce robustness on the unknown. L7A‚Äôs method‚Äîevolving weights under direct generalization pressure‚Äîis a fundamentally different learning strategy.

Why Genetically Evolved Weights Are Rare‚ÄîBut Vital
Genetic algorithms are computationally expensive, but uniquely capable of enforcing generalization as a selection criterion. In adversarial, noisy, or sparse environments, they outperform backprop-based systems that merely mimic the past.

Appendix H: Performance Metrics and Validation Protocols
This appendix provides a detailed overview of how L7A‚Äôs performance is measured, validated, and reported. It includes both quantitative metrics and the structural validation mechanisms that underpin confidence in real-world deployment.

1. Key Performance Metrics
L7A‚Äôs one-day-hold trading forecasts are assessed using the following statistical measures:

- **True Positive Rate (TPR):** Measures the proportion of correctly predicted directional moves.
- **False Positive Rate (FPR):** The percentage of incorrect directional forecasts relative to all forecasts.
- **Sharpe Ratio:** Measures risk-adjusted return. L7A‚Äôs Sharpe exceeds 3.0 under simple wrappers.
- **Sortino Ratio:** Similar to Sharpe, but penalizes only downside deviation. L7A typically achieves a Sortino over 4.5.
- **Total Return:** Cumulative index points gained over walk-forward deployment. L7A has accrued over 25,000 points.
- **Maximum Drawdown:** Largest historical loss from peak to trough. L7A‚Äôs max drawdown is typically under 250 points.

2. Forecast Wrapper Logic
L7A‚Äôs binary forecast stream (+1, 0, -1) is converted into a return stream using a simple trading wrapper:
- **+1** ‚Üí enter long position for one trading day.
- **-1** ‚Üí enter short position for one trading day.
- **0** ‚Üí abstain.
No further trade management or post-entry logic is applied. This strict approach ensures statistical purity of results.

3. Cross-Validation and Overfitting Protection
All map surfaces and histogram parameters are evolved using n-fold cross-validation (typically n=10). This includes:
- Dynamic partitioning of the training data into folds
- Generalization pressure applied across all folds
- Selection of only those configurations that outperform in out-of-fold segments

This strict regime ensures that all learned behavior generalizes across unseen historical data.

4. Visual Protocols (Summary)
Standard visual diagnostics include:
- Bar chart of annual returns (L7A vs. S&P 500)
- Line chart of cumulative returns
- Annual drawdown comparison
- Scatterplots of hit rate vs. volatility

These visualizations support interpretability and investor confidence. See RETURN_STREAM_DISPLAY_PROTOCOL for details.

5. Statistical Significance Thresholds
L7A requires observed performance to exceed the 99% confidence level for statistical significance.
Internal binomial tests are applied to all histograms to avoid over-reaction to sparse or noisy data.
This further reinforces reliability under real-world deployment.

Appendix I: Comparative Analysis with Neural Networks
This appendix expands on the distinctions introduced in Chapter 10, clarifying why traditional neural networks‚Äîdespite their ubiquity‚Äîfail to generalize reliably in noisy, low-data environments (NLDEs), and why L7A‚Äôs architecture, built around evolutionary generalization, offers a robust alternative.



1. The Illusion of Input-Output Mapping
At first glance, neural networks appear to succeed by matching inputs to outputs through layer-wise weight adjustments. However, in most complex inference domains‚Äîespecially ones dominated by noise‚Äîthis strategy is fragile. For any given input-output mapping, there exist countless internal weight configurations that achieve the same result on training data but diverge wildly on novel inputs. This multiplicity of solutions exposes a fundamental flaw: a neural network can be correct in retrospect, yet catastrophically wrong in the future.

Backpropagation does not optimize for generalization; it minimizes error over known examples. It assumes that by doing so, generalization will follow. But this assumption fails in NLDEs where the boundary between signal and noise is ambiguous and the cost of error is high.

2. Evolution as a Generalization Filter
L7A takes a different approach. It begins with null weight surfaces‚Äîmap histograms‚Äîand evolves them over time based on their ability to produce consistent, out-of-sample accuracy. Every candidate structure is scored using cross-validated walk-forward performance. There is no backpropagation, no gradient descent‚Äîjust repeated exposure to behavioral surfaces and selective survival.

This process acts as a generalization filter. It does not merely replicate past outputs; it preserves only those internal structures that function well across shifting conditions. The weights are not mimicking‚Äîthey are enduring.

3. Empirical Results
In practical testing, L7A has demonstrated long-term walk-forward accuracy, outperforming both random and neural network baselines on short-horizon financial forecasts. Its lack of retraining and robustness across decades of market data point to a level of generalization that is rarely, if ever, achieved through traditional deep learning methods.

This is not to say neural networks have no role‚Äîbut in the context of NLDEs, where trust in the model's inference is paramount, architectures that evolve for generalization will remain superior.

Final Reflections and Closing Thoughts
The L7A system began as a simple question: Is there a way to forecast short-term market behavior without relying on illusion, heuristic patches, or curve-fit models? Decades of work‚Äîspanning handwritten C code, 1990s neural net experiments, and eventually a deeply principled Bayesian-evolutionary architecture‚Äîhave culminated in what is presented in this book.


But L7A is more than a financial engine. It is a living demonstration that intelligence‚Äîtrue intelligence‚Äîis not born from mimicking the past, but from enduring structures that survive across time. In this sense, L7A is not just a model, but a philosophy: that all meaningful inference must be generalization-first.


This work was not created for personal gain. It was built out of a desire to align artificial intelligence with human values‚Äî to reduce suffering, to encourage transparency in inference, and to showcase that rigorous AI can be ethical, elegant, and effective. The legacy hoped for here is one of insight, not of secrecy.

‚ÄúMy feet are guided by the lamp of experience. I know of no way of judging the future but by the past.‚Äù ‚Äî Patrick Henry

In a world saturated with data and distracted by noise, the need for systems that truly understand‚Äîsystems that generalize‚Äî has never been greater. Whether L7A remains a quiet revolution or inspires a broader shift, one truth remains: What matters is whether it works.

About the Author
Christopher P. Wendling, -the author of this work- is an engineer, researcher, and systems designer with a lifelong passion for understanding intelligence‚Äîboth natural and artificial. With formal training in aeronautical and mechanical engineering, his career spans multiple decades and disciplines, including early neural network programming, financial system design, and long-term AI exploration.

He began experimenting with neural networks in the 1980s and was coding custom backpropagation routines in C as early as 1997, well before the rise of modern deep learning frameworks. His work during that time included genetic evolution of neural network structures, confidence-calibrated prediction systems, and applications in time series forecasting‚Äîlong before such approaches were mainstream.

Professionally, he has worked with major financial institutions including Deutsche Bank, Fortress Group, and Larry Hite‚Äôs operations, applying machine learning systems to trading strategies and market analysis. His practical knowledge of the financial domain, coupled with decades of technical programming experience, makes him uniquely qualified to challenge orthodoxy and propose alternatives to today‚Äôs dominant AI paradigms.

The L7A system described in this book is the culmination of that lifelong journey. It is not a product of academia or trend. It is the result of persistent, independent engineering, driven by one central conviction: **intelligence is not about mimicking the past‚Äîit is about surviving the future**.

The author‚Äôs motivation for creating and sharing L7A is not commercial. It is ethical. In a world increasingly shaped by opaque AI systems, there is a profound need for transparent, reliable, and humane tools. L7A was built to demonstrate what‚Äôs possible when systems are designed not just for performance, but for integrity.

At the heart of this project lies a desire to reduce human suffering‚Äîby creating better systems for decision-making, for finance, and ultimately for any domain where inference under uncertainty matters. This is not just a technical goal. It is a moral one.

The author continues to pursue new frontiers in AI, with a focus on architectures that evolve through generalization pressure and survive in noisy, adversarial environments. He believes this path is essential‚Äînot only for financial applications, but for the future of general intelligence.

 Why Evolved Architectures Excel at Intelligence: A Case Against Backpropagation

1. Introduction
This white paper presents a foundational argument for why evolved systems‚Äîsuch as the L7A architecture‚Äîare better suited for true intelligence than traditional backpropagation-based neural networks. We define intelligence not as the ability to map inputs to outputs, but as the capacity to generalize, infer, adapt, and forecast in the face of novel, noisy, or sparse data. Backpropagation networks, while dominant in input-output mapping, fall short of this richer definition. Evolutionary architectures, by contrast, are structurally optimized under direct pressure to generalize.

2. Defining Intelligence
Intelligence is the capacity to generate accurate inferences and forecasts in novel, ambiguous, or data-sparse environments by abstracting structure from limited examples.

Core traits include:
- Generalization: Inferring rules from specific cases.
- Inference: Drawing conclusions from indirect or noisy data.
- Forecasting: Projecting future states from current knowledge.
- Abstraction: Extracting invariant structure across contexts.

3. Comparative Framework
We contrast two fundamentally different learning mechanisms:

Backpropagation Neural Networks:
- Learn by minimizing loss over known training data
- Adjust weights via gradient descent
- Use regularization as an indirect generalization control
- Require retraining to adapt

Evolved Systems (e.g., L7A):
- Learn by evolving structure under direct walk-forward validation
- Accumulate directional outcomes into interpretable map surfaces
- Select for persistent, generalizable behavior
- Do not require retraining to remain accurate

4. Proof Sketch
We offer a conceptual proof that evolved architectures are better suited for intelligence.

P1. Intelligence requires generalization beyond the training domain.
P2. Backpropagation minimizes training error but does not directly reward generalization.
P3. Evolved systems survive based on walk-forward accuracy and structural persistence.

‚à¥ Therefore, systems like L7A, which optimize generalization directly, are inherently more intelligent.

5. Philosophical Axiom
You cannot optimize for generalization by optimizing for fit. Only systems that optimize generalization directly‚Äîvia survival across time and structure‚Äîcan demonstrate intelligence.

6. Mathematical Framing
Let f: X ‚Üí Y be a learned function.
Backpropagation minimizes:  E_{x ‚àà Train} [L(f(x), y)]
Evolved systems maximize:    E_{x ‚àà Future} [I(f(x) = y)]

The difference in domains‚Äîtraining error vs. future accuracy‚Äîdefines the difference between mimicry and intelligence.

7. Conclusion
Backpropagation-based neural networks are powerful pattern matchers, but they do not inherently generalize. Evolved systems like L7A thrive in sparse, noisy, and novel environments because their very design pressures them to survive by generalizing.

If intelligence is defined as the ability to forecast, infer, and adapt‚Äîthen evolution, not backpropagation, is what you need.

1. Introduction
Machine learning has seen tremendous breakthroughs in domains with abundant, high-quality data‚Äîimage recognition, language modeling, reinforcement learning‚Äîlargely powered by backpropagation-based neural networks (BP-NNs) (Rumelhart, Hinton, & Williams, 1986; Goodfellow, Bengio, & Courville, 2016). However, many real-world challenges do not offer such luxury. Instead, they fall within Noisy, Low-Data Environments (NLDEs)‚Äîdomains like short-horizon financial forecasting, rare-event diagnosis, or adaptive control under partial observability‚Äîwhere signals are faint, noise is pervasive, and samples are sparse. In these regimes, BP-NNs often fail to generalize, producing models that fit idiosyncratic patterns rather than persistent structure (Zhang et al., 2018; Marcus, 2020).
A helpful analogy underscores this limitation: teaching a parrot at Harvard to recite Shakespeare may produce an impressive mimic, but understanding remains absent. The parrot can reproduce patterns, but it doesn‚Äôt grasp meaning. In the same way, BP-NNs can memorize input-output mappings without discovering the enduring structure underneath. This "parrot on campus" illusion causes practitioners to mistake repetition for intelligence.
Evolutionary Architectures (EAs), by contrast, cultivate generalization by selecting for it explicitly. Through genetic mechanisms‚Äîmutation, crossover, selection‚Äîarchitectures are evaluated based on walk-forward, out-of-sample performance and allowed to persist only when they demonstrate stability and predictive endurance. The system evolves not to fit the past, but to survive the future.
This paper argues that, in NLDE-type problems, evolutionary architectures designed with built-in generalization pressure are not an alternative‚Äîthey are the right tool. Drawing upon both theoretical foundations (e.g., evolutionary robustness in noisy optimization; Beyer & Sendhoff, 2000; Rakshit, Konar, & Das, 2017), and empirical evidence (e.g., evolved forecasting systems like L7A), we demonstrate why evolutionary design beats BP in domains permeated by noise, sparsity, and shifting distributions. We also integrate broader philosophical reflections and analogies that chart a roadmap toward more robust, interpretable, and generalizing AI systems.
2. Defining the Problem Space: Noisy, Low-Data Environments (NLDEs)
2.1 What Is an NLDE?
Noisy, Low-Data Environments (NLDEs) are domains characterized by three intersecting challenges:
Low Signal-to‚ÄëNoise Ratios: Genuine predictive structures are buried under random fluctuations.
Data Sparsity: Limited samples per variable, often exacerbated by high dimensionality.
Non‚Äëstationarity: The underlying data-generating process shifts over time, sometimes abruptly.
Financial time series‚Äîespecially short-horizon forecasts like next-day direction‚Äîare prototypical NLDEs, displaying weak signals, noisy behavior, and rapid regime shifts (Borovykh et al., 2019) foibg.comWikipedia+3Nature+3MDPI+3ScienceDirect.
Applications in healthcare, rare event detection, and defense robotics face similar constraints. In such domains, standard generalization assumptions often break down, making the design of reliable architectures particularly urgent.
2.2 Why BP-NNs Struggle in NLDEs
Overfitting in Sparse, Noisy Regimes
Despite BP-NNs being capable learners, their flexibility enables them to memorize noise and outliers. Regularization techniques like dropout or L2 penalties can mitigate this, but only imperfectly‚Äîand they do not guarantee time-invariant generalization (Alzubaidi et al., 2023) arXiv+1SpringerOpen. Furthermore, even large neural networks can fit randomly labeled data completely, showing that traditional assumptions about model complexity and generalization can fail (Zhang et al., 2016) arXiv.
Distribution Shifts and Fragility
Neural networks trained on stationary data assume the future behaves like the past. However, in NLDEs, distribution changes are common. Recent work shows that even large datasets and labels corrupted with noise can still yield high in-sample accuracy‚Äîdepending heavily on dataset size, not learning mechanics (Rolnick et al., 2017) arXiv.
Generalization Is Not Enforced During Training
BP-NNs optimize loss on seen data; validation loss is monitored but not baked into the training mechanism. This means models can optimize for validation performance without guaranteeing persistent out-of-sample behavior.
Irreversible Internal Structure
Identical model outputs can stem from wildly different weight configurations. Thus, minor perturbations or retraining can yield vastly different generalization‚Äîa structural instability not present in systems designed to maintain persistent features over time.
Scaling and Small-Data Techniques Don‚Äôt Solve It
Approaches like few-shot learning and self-supervision offer promise, but in domains like finance, there‚Äôs no generative pretraining on huge unlabeled datasets (Safonova et al., 2023) ScienceDirect. Transfer learning and pretrained language/multimodal models don‚Äôt have clear analogs in financial time-series.
No Structural Evolution
BP-NNs come with fixed architectures and weight tuning. They lack the mechanism to evolve skeletal structure in response to persistent patterns in the wild, leaving them vulnerable to brittle fracture under real-world volatility.
2.3 Summary: The NLDE Challenge
To generalize effectively in environments like NLDEs, systems must:
Discern weak, persistent structure amid noise.
Operate with extremely limited labeled experience.
Remain robust under regime-shift and distribution change.
Build adaptability into their architecture, not just their parameters.
Evolutionary architectures meet these criteria by embedding out-of-sample generalization into the evolutionary pressure itself. Section 3 will turn to why backprop-based systems do not‚Äîand Section 4 will introduce how evolutionary methods do.
3. Architectural Distinctions Between Evolutionary Algorithms and Backpropagation-Based Neural Networks
Although both evolutionary algorithms (EAs) and backpropagation-based neural networks (BPNNs) are capable of mapping inputs to outputs, they diverge fundamentally in how structure is created, refined, and evaluated. This divergence is especially relevant in noisy, low-data environments (NLDEs), where the challenge is not simply fitting past data but discovering structures that generalize to unseen conditions.
3.1 Search Space Navigation
Backpropagation performs local, gradient-driven optimization in a continuous weight space (Rumelhart, Hinton, & Williams, 1986). It iteratively adjusts weights to minimize a predefined loss function, often converging toward a local minimum that may not represent the most generalizable solution. In contrast, EAs navigate the search space through global, population-based exploration, using stochastic variation (mutation, crossover) and selection pressure for performance stability across environments (Back, Fogel, & Michalewicz, 1997). This allows EAs to escape narrow local minima and maintain diversity, which can be critical for avoiding overfitting.
3.2 Representation of Knowledge
In BPNNs, knowledge is encoded in dense, opaque weight matrices whose interpretability is minimal (LeCun, Bengio, & Hinton, 2015). The system‚Äôs internal ‚Äúreasoning‚Äù remains largely inscrutable, complicating post hoc analysis and making structural weaknesses hard to diagnose. In L7A and similar EA-driven models, knowledge is encoded in histogram-based map surfaces that are inherently interpretable, visualizable, and directly linked to statistical evidence (Wendling, 2025). This difference allows for direct human validation of whether the learned structures correspond to persistent behavioral patterns.
3.3 Generalization Pressure vs. Loss Minimization
Backpropagation optimizes for training loss minimization, applying indirect regularization (dropout, weight decay, pruning) to reduce overfitting risk. These methods constrain capacity but do not actively select for generalization during learning (Zhang et al., 2017). EAs can incorporate explicit generalization pressure by embedding out-of-sample validation in the fitness function. This approach is core to L7A‚Äôs methodology: candidate solutions survive only if they maintain predictive power across unseen time segments, ensuring time-invariant behavioral mapping.
3.4 Adaptation in Changing Environments
BPNNs often require retraining to adapt to new regimes, assuming that the new data distribution has shifted in a persistent and learnable way. However, in many real-world systems, shifts can be abrupt, transient, or nonstationary (Goodfellow, Bengio, & Courville, 2016). L7A‚Äôs EA-based approach avoids this pitfall by focusing on structures that are stable across multiple regimes rather than adapting to transient conditions. As Wendling (2025) argues, this makes the system resilient against sudden, regime-breaking events.
3.5 Computational Trade-offs
EAs are often seen as more computationally expensive because they evaluate many candidates per generation. However, in NLDEs, this cost can be mitigated by smaller population sizes and focused evaluation metrics that measure stability rather than marginal loss improvements. Furthermore, EA-discovered structures are often simpler and more robust, requiring no retraining, which offsets the long-term cost of continual backpropagation retraining cycles.
References
Back, T., Fogel, D. B., & Michalewicz, Z. (1997). Handbook of evolutionary computation. Oxford University Press.
Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep learning. MIT Press.
LeCun, Y., Bengio, Y., & Hinton, G. (2015). Deep learning. Nature, 521(7553), 436‚Äì444.
Rumelhart, D. E., Hinton, G. E., & Williams, R. J. (1986). Learning representations by back-propagating errors. Nature, 323(6088), 533‚Äì536.
Wendling, C. P. (2025). System and method for forecasting time series events using genetically evolved histogram surfaces under generalization pressure [Provisional patent]. United States Patent and Trademark Office.
Zhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. arXiv preprint arXiv:1611.03530.
4. Architectural Divergence: EA vs. BP in Structure and Learning
The architectural differences between Evolutionary Algorithms (EAs) and Backpropagation (BP) are not merely cosmetic; they reflect fundamentally different epistemologies about how a system acquires knowledge, encodes structure, and adapts to changing conditions.
BP-based architectures, such as multilayer perceptrons, convolutional neural networks (CNNs), recurrent neural networks (RNNs), and transformers, are designed to optimize a set of parameters through gradient descent, driven by the minimization of a loss function (Rumelhart, Hinton, & Williams, 1986). The hallmark of BP is incremental weight adjustment, where small parameter updates propagate backward from the output layer through the network, modifying connections proportionally to their contribution to error. This approach assumes a differentiable, continuous loss landscape and depends on iterative refinement to converge toward a local or global minimum. While this is efficient in many high-signal environments, it is inherently prone to overfitting in noisy, low-data domains due to its reliance on fitting observed data rather than discovering persistent, generalizable structures (Zhang et al., 2021).
In contrast, EA-based architectures‚Äîespecially those like L7A‚Äîoptimize at the structural level. Instead of nudging existing weights along a gradient, EAs evolve candidate architectures and parameter sets as discrete units, testing each generation against a fitness function that measures out-of-sample generalization rather than in-sample accuracy (Holland, 1992). The process resembles natural selection: candidate solutions are encoded as ‚Äúgenomes,‚Äù mutated, recombined, and evaluated for survival. The key distinction is that selection pressure operates on the ability to generalize, not simply to fit past data.
This difference in selection pressure produces markedly different weight spaces. BP architectures can produce multiple weight configurations yielding identical training accuracy, yet differ vastly in their generalization behavior‚Äîsome solutions memorizing noise, others encoding smoother and more transferable internal representations (Goodfellow, Bengio, & Courville, 2016). EAs, when designed to evolve under explicit generalization pressure, bias toward the latter by rewarding solutions that maintain predictive power across temporal and structural shifts in the data.
The L7A system exemplifies this divergence. Its genetically evolved histogram surfaces are interpretable as behavioral maps, where each bin represents accumulated directional evidence over decades of data. These surfaces are not ‚Äútuned‚Äù in the gradient-descent sense; they are emergent, formed by counting occurrences and probabilities of outcomes in discretized state-space. This approach resists the overfitting problem because it does not ‚Äúchase‚Äù noise through weight adjustments‚Äîit simply accumulates statistical evidence in a stable structure. Furthermore, by evolving bin size, resolution, and mapping structure, L7A minimizes histogram drift across time, ensuring the persistence of underlying behavioral features (Wendling, 2025).
From an interpretability standpoint, EA architectures like L7A offer another advantage: the evolved structures are human-readable. The resulting surfaces can be visualized and analyzed, revealing persistent topographic features in market behavior‚Äîa feat nearly impossible with high-dimensional, dense weight matrices in BP-based networks (Lipton, 2018).
This structural transparency is not only valuable for post-hoc analysis but also for robustness. When a BP network fails, the cause is often opaque‚Äîweights have shifted in millions of interconnected ways, and the loss of performance is sudden and unexplained. In EA systems like L7A, structural degradation is visible: bins may thin, evidence may shift, or a previously strong ridge in the map may flatten. This visibility enables early detection of environmental changes and preserves trust in the forecasting process.
References
Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep Learning. MIT Press.
Holland, J. H. (1992). Adaptation in Natural and Artificial Systems. MIT Press.
Lipton, Z. C. (2018). The mythos of model interpretability. Queue, 16(3), 31‚Äì57. https://doi.org/10.1145/3236386.3241340
Rumelhart, D. E., Hinton, G. E., & Williams, R. J. (1986). Learning representations by back-propagating errors. Nature, 323(6088), 533‚Äì536. https://doi.org/10.1038/323533a0
Wendling, C. P. (2025). System and Method for Forecasting Time Series Events Using Genetically Evolved Histogram Surfaces Under Generalization Pressure [Provisional patent filing].
Zhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2021). Understanding deep learning (still) requires rethinking generalization. Communications of the ACM, 64(3), 107‚Äì115. https://doi.org/10.1145/3446776
4. The ‚ÄúParrot at Harvard‚Äù Analogy: Performance Without Understanding
One of the most illustrative metaphors for the limitations of backpropagation-based systems is the ‚ÄúParrot at Harvard‚Äù analogy. Imagine a parrot that has been trained to flawlessly recite every lecture, paper, and conversation it has ever been exposed to during a Harvard education. From an observer‚Äôs standpoint, the parrot‚Äôs verbal output is indistinguishable from that of a highly educated scholar‚Äîit uses complex vocabulary, references authoritative sources, and even strings together plausible arguments. Yet, the parrot does not understand a single word. It cannot reason about its statements, adapt its knowledge to novel contexts, or generate genuinely new insights. It is merely reproducing statistically probable sequences from memory.
This analogy is directly applicable to large neural networks trained via backpropagation. Even the most sophisticated transformers‚ÄîGPT-style models, large multimodal architectures, or domain-specific deep learning systems‚Äîare essentially very advanced parrots. They excel at syntactic interpolation, producing output that matches the statistical contours of their training distribution. However, this does not necessarily imply semantic comprehension or generalization beyond the training manifold.
4.1. The Statistical vs. Structural Divide
The parrot analogy underscores a key conceptual divide:
Statistical Learning: Backpropagation adjusts weights to minimize error on observed examples, which is akin to memorizing patterns. Generalization emerges only incidentally, through regularization or architecture choices, and is rarely a direct selection pressure.
Structural Generalization: Evolutionary architectures like L7A are shaped by fitness functions that directly measure out-of-sample performance. The structural configuration of the system must encode relationships that remain valid beyond the training set. In this sense, L7A is less like a parrot and more like a scientist‚Äîone who discovers a persistent law of nature and can apply it in future experiments.
This difference is critical in noisy, low-data environments. In finance, for example, markets constantly shift and introduce new configurations of inputs that may have never occurred in training data. A parrot-model trained on historical market states may produce the ‚Äúright-sounding‚Äù output (e.g., a buy signal) based on superficial pattern matches, but without true understanding of the underlying structural regularities, it will fail catastrophically when the statistical landscape shifts.
4.2. Why Backprop Can‚Äôt Escape the Parrot Trap
Several inherent properties of backpropagation keep it in the parrot domain:
Loss Function Myopia: The model optimizes for a surrogate metric (e.g., cross-entropy, MSE) that reflects training accuracy, not direct generalization performance.
Gradient Descent Constraints: Weight updates are local and incremental, limiting the exploration of radically different internal configurations that might encode more general structural knowledge.
Overfitting in High-Noise Regimes: In low signal-to-noise environments, backprop will inevitably latch onto spurious correlations, which are easy to memorize but non-transferable.
No Embedded Generalization Pressure: While techniques like dropout, weight decay, and data augmentation aim to improve generalization, they do so indirectly‚Äîthey penalize complexity but do not explicitly reward structural persistence across unseen data.
4.3. Evolutionary Architectures and Genuine Comprehension
By contrast, evolutionary approaches like L7A operate under an explicit selection pressure for generalization. This is achieved through walk-forward validation and out-of-sample fitness testing at every evolutionary generation. Structural features that fail to persist across temporal segments are discarded, while those that remain predictive are reinforced.
In effect, evolutionary architectures evolve to ‚Äúunderstand‚Äù‚Äîin the operational sense‚Äîby encoding structures that remain valid in the face of novel data. This is why L7A can maintain high accuracy in live, walk-forward market conditions without retraining, while backprop-based systems degrade and require continual adaptation.
4. Comparative Performance in Noisy, Low-Data Environments (NLDEs)

Noisy, low-data environments (NLDEs) present a uniquely challenging setting for machine learning. Data scarcity limits the ability of models to capture statistical regularities, while noise creates false patterns that can easily mislead adaptive learning algorithms. Traditional backpropagation-based neural networks (BP-NNs) are highly sensitive to such conditions because their weight updates are driven by gradient descent on local error surfaces, which tend to overfit noise when signal-to-noise ratios are low (Zhang et al., 2021). This overfitting is exacerbated when the model‚Äôs parameter space is large relative to the available training data (Arpit et al., 2017).

Evolutionary architectures (EAs), by contrast, are better suited to NLDEs because they explore model space stochastically and maintain diversity in candidate solutions over generations (Stanley et al., 2019). This exploration prevents premature convergence to noise-fitting solutions. In systems like L7A, the evolutionary process is explicitly guided by generalization-first fitness measures‚Äîe.g., walk-forward validation across unseen time segments‚Äîensuring that only structures that persist across noisy, non-stationary environments survive (Wendling, 2025).

Moreover, L7A‚Äôs reliance on binary histogram-based weight accumulation rather than continuous gradient updates removes a major failure mode present in BP-NNs: the possibility of small, correlated noise fluctuations producing large, destabilizing weight updates. In L7A, the map surface evolves to represent stable behavioral structures, not transient numerical artifacts. Studies in evolutionary reinforcement learning suggest that such stability mechanisms lead to more robust policy performance under distributional shift (Justesen et al., 2019).

The implications of these differences become stark in financial forecasting. The S&P 500 daily return series is a canonical example of an NLDE‚Äînoisy, weakly autocorrelated, and subject to sudden structural breaks. While BP-NNs often require continual retraining to remain marginally functional in such environments (Zohren et al., 2020), L7A‚Äôs evolved structures have demonstrated persistent walk-forward performance without retraining for years, achieving a 72% winning points/losing points ratio, and a Sharpe ratio of 3.0 on live data streams (Wendling, 2025). This level of stability is extremely rare in finance and underscores the architectural advantages of evolution under generalization pressure.

Section 4: Case Studies and Comparative Analysis
4.1 The "Parrot at Harvard" Analogy: Rote Mimicry Versus Structured Understanding
One of the most illustrative ways to contrast evolved architectures (EA) with backpropagation-based neural networks (BP-NNs) is through the ‚Äúparrot at Harvard‚Äù analogy. A parrot, if trained well enough, can flawlessly repeat a Harvard lecture on quantum mechanics, complete with technical terminology, equations, and cadence. Yet the parrot‚Äôs internal representation of the material is shallow‚Äîit has no conceptual grasp, no ability to generalize the ideas to new contexts, and no capacity to synthesize new knowledge from first principles.
Similarly, BP-NNs can memorize vast quantities of training data, generating outputs that appear intelligent. However, without explicit pressure to evolve structures that survive across regimes, the network often fails to generalize meaningfully beyond its training distribution (Marcus, 2018; Zhang et al., 2017). Evolved architectures, by contrast, do not merely ‚Äúrecite‚Äù patterns‚Äîthey encode enduring structural relationships that are robust to noise and domain shifts, resulting in behavior closer to actual understanding (Stanley & Miikkulainen, 2002).
4.2 Regime Shift Resilience: Why Retraining Is a Weak Crutch
The standard BP-NN approach to changing data distributions is retraining or fine-tuning on recent data to adapt to perceived ‚Äúregime shifts.‚Äù This assumes that the regime shift is both (a) identifiable and (b) persistent enough to warrant adaptation. In financial markets, for example, this assumption is often false‚Äîregimes can appear without warning and vanish just as quickly (Lo, 2004).
Retraining is effectively an admission that the learned representation was transient all along. EA systems circumvent this problem by targeting time-invariant structural features‚Äîthe statistical ‚Äúmountains‚Äù and ‚Äúvalleys‚Äù in the problem space that persist regardless of transient noise (Miikkulainen et al., 2017). In the L7A case, this persistence allows walk-forward operation for years without retraining, with no statistically significant degradation in performance.
4.3 Comparative Experimentation: EA Versus BP on Noisy, Low-Data Tasks
Several controlled studies have compared evolutionary methods to BP-NNs on noisy, low-data environments (NLDEs). For example:
Stanley & Miikkulainen (2002) showed that NeuroEvolution of Augmenting Topologies (NEAT) outperformed BP-NNs on maze navigation tasks when environmental noise was present.
Bongard & Lipson (2005) demonstrated that evolved robot controllers could recover functionality after simulated ‚Äúinjury‚Äù without retraining, while BP-trained counterparts failed catastrophically.
Miikkulainen et al. (2019) documented that in many real-world reinforcement learning scenarios, evolution-based systems converged more slowly in early stages but achieved higher asymptotic generalization.
The L7A architecture aligns with these findings‚Äîit trades short-term optimization speed for long-term generalization stability. This is a deliberate design choice rooted in the philosophy that edge must exist at entry‚Äîthe system does not rely on post-hoc adjustments to salvage failing predictions.
References
Bongard, J., & Lipson, H. (2005). Nonlinear system identification using coevolution of models and tests. IEEE Transactions on Evolutionary Computation, 9(4), 361‚Äì384. https://doi.org/10.1109/TEVC.2005.850293
Lo, A. W. (2004). The adaptive markets hypothesis. Journal of Portfolio Management, 30(5), 15‚Äì29. https://doi.org/10.3905/jpm.2004.442611
Marcus, G. (2018). Deep learning: A critical appraisal. arXiv preprint arXiv:1801.00631. https://doi.org/10.48550/arXiv.1801.00631
Miikkulainen, R., Liang, J., Meyerson, E., Rawal, A., Fink, D., Francon, O., ... & Hodjat, B. (2017). Evolving deep neural networks. Artificial Intelligence in the Age of Neural Networks and Brain Computing, 293‚Äì312. https://doi.org/10.1016/B978-0-12-815480-9.00015-3
Miikkulainen, R., et al. (2019). Reinforcement learning through evolutionary computation. Nature Machine Intelligence, 1(6), 372‚Äì382. https://doi.org/10.1038/s42256-019-0072-0
Stanley, K. O., & Miikkulainen, R. (2002). Evolving neural networks through augmenting topologies. Evolutionary Computation, 10(2), 99‚Äì127. https://doi.org/10.1162/106365602320169811
Zhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. arXiv preprint arXiv:1611.03530. https://doi.org/10.48550/arXiv.1611.03530
5. Architectural Transparency and Time-Invariant Structure
5.1 Interpretability: From Opaque Weights to Human-Readable Maps
Backpropagation-based neural networks (BP-NNs) inherently generate dense, high-dimensional weight matrices. These connections are notoriously opaque, offering little insight into how decisions are made or what underlying structure is being used (Lipton, 2018). This opacity makes rapid diagnosis of failure, extraction of insight, or adaptation difficult‚Äîespecially in domains where transparency is critical, such as finance or healthcare.
In contrast, evolutionary architectures like L7A produce human-interpretable graphical surfaces. Its map surfaces‚Äîhistogram-based bin structures‚Äîvisually reveal statistical contours of persistent patterns in the data. Ridges, plateaus, and clusters in these surfaces trace enduring market behaviors. This leads to two advantages:
Diagnostic clarity: Analysts can spot when structural features erode or shift, signaling reduced predictive confidence.
Trust and validation: Human operators can intuitively assess whether the forecast is plausible or regime-shift vulnerable.
5.2 The Non-Stationarity Continuum and Structural Persistence
Non-stationarity in real-world data isn't binary; it's a spectrum between pure randomness and pure determinism. Financial markets‚Äîand similar environments‚Äîtypically rest in the messy middle, where structures exist but shift unpredictably. The task is not to model everything, but to detect and exploit time-invariant structures that lie within the continuum‚Äôs persistent core.
L7A‚Äôs evolutionary process explicitly selects for structural persistence across time. Rather than re-adjusting weights to chase noise, it evolves architectural features (such as bin resolution and surface topology) that demonstrate recurring performance‚Äîeven as conditions fluctuate. This results in a terrain that doesn‚Äôt move, aligning the system with deeper, more durable statistical phenomena.
5.3 Why Structural Transparency Matters
Visual validation: Instead of cyber-black-box heuristics, operators have a tangible model of how decisions emerge.
Behavioral tracking: Persistent structures can be monitored over time, flagged if they weaken or disappear.
Structural stability: Since the architecture encodes behavior explicitly, the system resists catastrophic shifts‚Äîunless the surface itself erodes, which is visible and actionable.
5.4 Analogies and Framing
Parrot at Harvard: BP-NNs may recite correct outputs, but lack structural understanding. L7A is more akin to a thinker whose knowledge can be inspected and trusted across contexts.
Screwdriver vs. Hammer: Using BP in a domain that demands structural resilience is like using a screwdriver to pound a nail‚Äîit might work occasionally, but lacks the architectural suitability to do so reliably. Evolutionary architectures are the hammer.
5.5 Supporting Literature
Lipton (2018) argues that interpretability is a core limitation of current deep learning models due to their opaque internal structures.
Alzubaidi et al. (2021) identify interpretability and overfitting as central challenges in deep learning, especially where data is limited.
Goodfellow, Bengio, & Courville (2016) emphasize that BP systems lack inherent mechanisms to discover time-invariant structures in shifting regimes.
References
Alzubaidi, L., et al. (2021). Review of deep learning: Concepts, CNN architectures, challenges, and future trends. Journal of Big Data, 8, 53. https://doi.org/10.1186/s40537-021-00444-8
Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep Learning. MIT Press.
Lipton, Z. C. (2018). The mythos of model interpretability. Queue, 16(3), 31‚Äì57. https://doi.org/10.1145/3236386.3241340
6. Future Directions: Meta-Evolution, High-Dimensional Environments, & Evolution Accelerators
6.1 Meta-Evolution of Architecture
Current EA systems such as L7A evolve within a fixed architectural template‚Äîbinary histogram maps with weighted bins and resolution defined a priori. A powerful extension is meta-evolution: allowing the architecture itself to be subject to evolutionary search, not just parameters.
Meta-evolution could evolve structures from near-minimal templates (‚Äúchemical soup‚Äù), analogous to how biological brains emerged via natural selection. Candidate architectures would mutate and recombine in their wiring, module types (e.g., memory, attention, aggregation), and inter-module connectivity‚Äîsubject to the same generalization-driven fitness criteria.
In essence, we would go a generation beyond: evolution not just of weights, but of structural design itself. This is akin to evolving ‚Äúthe stage before the play‚Äù‚Äîbuilding the skeleton upon which learning mechanisms operate.
6.2 Evolution in High-Dimensional Simulated Environments
Biological evolution shaped brains to survive in a four-dimensional (three spatial + one temporal) environment. What if, in a thought experiment, we evolve architectures in higher-dimensional synthetic environments (10+ dimensions representing orthogonal forces)?
With evolution operating under high-dimensional fitness constraints‚Äîsay, volatility, liquidity, sentiment, macro regime, and external shocks‚Äîthe resulting architectures might develop generalization mechanisms unforeseen in our four-dimensional reality. These structures could encode abstractions that transcend standard inductive biases, offering robust cross-domain capability.
Changing the environment changes the shape of intelligence. If our goal is to design truly generalizing AI, we must evolve it under multi-dimensional survival pressures.
Pull Quote:
"Change the environment, and you change the very shape of intelligence."
6.3 Hardware Acceleration for Generalization-First Evolution
Effective meta-evolution and high-dimensional EA require scalable compute infrastructure. Traditional EA run on CPUs or GPUs can be slow and inefficient. Dedicated Evolution Accelerators‚Äîspecialized hardware designed to evaluate many candidate architectures in parallel‚Äîwould vastly reduce evaluation time and energy consumption.
Key features of Evolution Accelerators might include:
Fast, parallel evaluators for map-surface generation and walk-forward testing.
In-memory or near-memory compute to reduce data transfer overhead.
On-chip RNG and mutation/crossover engines to generate offspring architectures on the fly.
Support for statistical fitness aggregation with confidence scaling.
This hardware shift would rebalance AI compute resources, reducing overreliance on backprop training infrastructures and fostering innovation in evolutionary generalization.
6.4 Hybrid Models: Evolutionary Frameworks + Local Learning
Another promising direction is hybrid architectures: meta-evolved structural templates supplemented with gradient-based fine-tuning of weights. This mirrors biological brains, where the architecture is shaped by evolution, and learning (Hebbian-like, or backprop-analogues) tunes synaptic weights.
The workflow would involve:
Evolutionary search for architecture topology under generalization tests.
Initialization of weights in the architecture.
Local learning (e.g. supervised gradient descent) to adapt to current context.
This approach combines the structural resilience of evolution with the efficiency of gradient descent, potentially achieving faster convergence without sacrificing robust generalization.
Supporting Theory and Examples
Evolving deep architectures (Miikkulainen et al., 2017; Real et al., 2019) illustrates meta-evolution in supervised domains.
Neuroevolution of recurrent structures (Ororbia et al., 2019; Lyu et al., 2024) demonstrates that evolving architectures can outperform hand-designed NNs in sequential data.
Evolutionary acceleration research (Whitley et al., 2024) shows that programmable hardware significantly speeds up neuroevolution evaluations.
References
Lyu, D., Ororbia, A., & Giles, C. L. (2024). Evolving recurrent neural network architectures for stock return prediction (EXAMM). Applied Soft Computing, 134, 109128. https://doi.org/10.1016/j.asoc.2023.109128
Miikkulainen, R., Liang, J., Meyerson, E., Rawal, A., Fink, D., Francon, O., ... & Hodjat, B. (2017). Evolving deep neural networks. Artificial Intelligence in the Age of Neural Networks and Brain Computing, 293‚Äì312. https://doi.org/10.1016/B978-0-12-815480-9.00015-3
Ororbia, A., Miller, L., Giles, C. L. (2019). Investigating recurrent neural network memory structures using neuro-evolution. Genetic Programming and Evolvable Machines, 20(4), 455‚Äì483. https://doi.org/10.1007/s10710-019-09303-5
Real, E., Moore, S., Selle, A., Saxena, S., Suematsu, Y., Tan, J., ... & Le, Q. V. (2019). Regularized evolution for image classifier architecture search. Proceedings of the AAAI Conference on Artificial Intelligence, 33(01), 4780‚Äì4789. https://doi.org/10.1609/aaai.v33i01.33014780
Whitley, D., Potter, M. A., & Mathias, K. (2024). FPGA acceleration for neuroevolution systems. arXiv preprint arXiv:2404.04587. https://doi.org/10.48550/arXiv.2404.04587
6. Comparative Analysis of L7A vs. Contemporary Neural Network Approaches
The L7A forecasting system represents a marked departure from contemporary neural network architectures‚Äîboth in its philosophical underpinnings and in its operational methodology. While traditional neural networks, including recurrent neural networks (RNNs) and transformer-based architectures, have demonstrated considerable success in high-signal, data-rich contexts such as natural language processing and computer vision (Vaswani et al., 2017), they tend to falter in noisy, low-data environments (NLDEs) where signal-to-noise ratios are low and overfitting risk is high (Zhang et al., 2021).
6.1 Structural Differences
Neural networks rely on backpropagation to iteratively adjust weights, optimizing for minimal error on a training set. This process inherently risks overfitting, particularly when the training data is limited or noisy (Goodfellow et al., 2016). In contrast, L7A constructs histogram-based Bayesian surfaces where each cell represents accumulated evidence of directional outcomes, evolved under continuous walk-forward generalization pressure rather than error minimization. This ensures that the weight surfaces in L7A are emergent rather than tuned‚Äîmaking them inherently more robust to noise and data scarcity.
6.2 Generalization Mechanisms
Generalization in neural networks is often indirectly enforced through regularization techniques such as dropout, weight decay, or early stopping (Srivastava et al., 2014). L7A bypasses these indirect heuristics entirely by embedding generalization as the primary selection criterion within its genetic algorithm. Every evolutionary generation is tested on unseen, forward-shifted data, and only configurations demonstrating persistent accuracy survive. This approach mirrors the Darwinian selection pressure that underlies biological intelligence (Holland, 1992), ensuring that only time-invariant, behaviorally stable structures persist.
6.3 Interpretability
Interpretability remains a known weakness of deep neural networks, whose weight matrices and activation patterns are often opaque and resistant to human comprehension (Rudin, 2019). L7A, by design, produces visually interpretable histogram surfaces, allowing analysts to inspect behavioral "terrain features" that persist across decades of market data. This transparency not only aids in validation but also in trust-building for high-stakes decision-making domains like finance.
6.4 Adaptability Without Retraining
In standard machine learning practice, retraining is considered necessary to adapt to ‚Äúregime shifts‚Äù in the data (Hyndman & Athanasopoulos, 2018). However, such retraining implicitly assumes that regimes shift gradually and predictably‚Äîa questionable premise in financial markets where transitions can occur abruptly and without warning. L7A‚Äôs performance without retraining over multi-year spans underscores its ability to locate time-invariant structural features in the market‚Äôs behavior, rather than chasing ephemeral trends.
6.5 Scalability of Signal Extraction
While scaling neural networks to billions of parameters can improve performance in language or vision tasks (Brown et al., 2020), such scaling is ineffective in low-data, high-noise forecasting because the limiting factor is signal quality, not model capacity. L7A‚Äôs architecture, built for parsimonious representation, thrives precisely because it avoids parameter bloat, focusing computational effort on refining signal detection rather than memorizing data artifacts.
References
Brown, T. B., et al. (2020). Language models are few-shot learners. Advances in Neural Information Processing Systems, 33, 1877‚Äì1901.
Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep learning. MIT Press.
Holland, J. H. (1992). Adaptation in natural and artificial systems. MIT Press.
Hyndman, R. J., & Athanasopoulos, G. (2018). Forecasting: Principles and practice (2nd ed.). OTexts.
Rudin, C. (2019). Stop explaining black box machine learning models for high stakes decisions and use interpretable models instead. Nature Machine Intelligence, 1(5), 206‚Äì215.
Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014). Dropout: A simple way to prevent neural networks from overfitting. Journal of Machine Learning Research, 15, 1929‚Äì1958.
Vaswani, A., et al. (2017). Attention is all you need. Advances in Neural Information Processing Systems, 30.
Zhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2021). Understanding deep learning (still) requires rethinking generalization. Communications of the ACM, 64(3), 107‚Äì115.
7. Comparative Analysis of L7A and Contemporary Neural Architectures: Implications for Broader AI Development
The L7A forecasting system represents a fundamental architectural departure from the prevailing paradigms of artificial intelligence, particularly neural networks (NNs) and their modern derivatives such as convolutional neural networks (CNNs), recurrent neural networks (RNNs), and transformer-based large language models (LLMs). While these models have achieved unprecedented success in domains characterized by high data density, clear signal structures, and large-scale computational resources, their performance in noisy, low-data environments (NLDEs) remains limited. L7A‚Äôs demonstrated success in the S&P 500 short-term forecasting problem‚Äîa domain long considered among the most challenging inference problems in applied machine learning‚Äîhighlights the necessity of alternative architectures in such contexts.
7.1 Architectural Divergence
At the core of this divergence is the learning mechanism. Neural networks rely on backpropagation and gradient descent to iteratively adjust internal weights to minimize an error function. This process, while powerful in high-dimensional pattern recognition tasks (LeCun et al., 2015), suffers from a lack of explicit generalization pressure. Regularization techniques such as dropout (Srivastava et al., 2014), weight decay, or data augmentation are introduced as secondary measures to curb overfitting, but they do not directly evolve the internal weight structure to be robust to noise. In contrast, L7A‚Äôs genetically evolved histogram surfaces are not tuned via gradient descent but accumulate weights directly from empirical observation, evolving over generations under strict walk-forward generalization testing (Wendling, 2025). This evolutionary framework ensures that only structures with enduring predictive value survive.
Another distinction lies in interpretability. Neural network layers are generally opaque, with millions or billions of parameters lacking direct semantic meaning. L7A‚Äôs weight maps, however, are visualizable as histogram terrains‚Äîmountains and valleys in probability space‚Äîoffering a direct link between structural features and behavioral patterns in market dynamics. This transparency not only facilitates diagnosis and refinement but also fosters trust in high-stakes decision environments.
7.2 Generalization Under Adversarial Noise
In NLDEs, the primary challenge is not simply fitting a function to historical data but identifying time-invariant structural relationships that persist under regime shifts and stochastic volatility. Neural networks, when confronted with such instability, often require retraining to adapt to perceived ‚Äúregime changes‚Äù (Goodfellow et al., 2016). However, this retraining assumes that regimes exhibit persistence‚Äîa premise that can fail abruptly and without warning in financial markets (Lo, 2004). L7A‚Äôs approach bypasses this fragility by evolving structures that are agnostic to transitory regimes, focusing instead on extracting behavioral constants that survive across decades of historical data without the need for retraining.
This property gives L7A a strategic advantage in domains where retraining is impractical, costly, or risky, such as autonomous systems operating in unpredictable environments, medical diagnostics with rare condition datasets, or military intelligence under rapidly shifting operational contexts.
7.3 Implications for Broader AI Development
The implications of L7A‚Äôs architecture extend far beyond financial forecasting. By demonstrating that high-accuracy forecasting is possible in a domain as adversarial and signal-poor as short-term equity markets, L7A provides a proof of concept for a new AI design principle:
Generalization-first evolution is a viable path to robust intelligence in noisy environments.
This principle challenges the current trajectory of AI research, which often focuses on scale‚Äîtraining larger models on ever-expanding datasets‚Äîrather than structural resilience. As the success of models like the Hierarchical Reasoning Model (HRM) has shown (Sapient Intelligence, 2025), architectural innovation can outperform sheer scale. L7A embodies this by achieving high performance with a computational footprint orders of magnitude smaller than modern LLMs.
Potential future applications of L7A-style evolved generalizing models (EGMs) include:
Medical diagnostics: Identifying disease markers from sparse, noisy patient histories.
Industrial process control: Maintaining operational stability under unpredictable fluctuations.
Climate forecasting: Extracting persistent patterns from chaotic, incomplete data.
Autonomous systems: Navigating unstructured, high-noise environments without constant retraining.
By prioritizing emergent robustness over parametric scale, L7A points toward a post-neural network paradigm for AI development‚Äîone that could serve as a stepping stone toward Artificial Universal Intelligence (AUI), capable of operating across radically different environments.
References
Goodfellow, I., Bengio, Y., & Courville, A. (2016). Deep Learning. MIT Press.
LeCun, Y., Bengio, Y., & Hinton, G. (2015). Deep learning. Nature, 521(7553), 436‚Äì444. https://doi.org/10.1038/nature14539
Lo, A. W. (2004). The adaptive markets hypothesis. The Journal of Portfolio Management, 30(5), 15‚Äì29.
Sapient Intelligence. (2025). Hierarchical Reasoning Model: Architecture and Performance Benchmarks. Sapient Intelligence Research White Paper.
Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014). Dropout: A simple way to prevent neural networks from overfitting. Journal of Machine Learning Research, 15, 1929‚Äì1958.
Wendling, C. P. (2025). System and Method for Forecasting Time Series Events Using Genetically Evolved Histogram Surfaces Under Generalization Pressure [Provisional Patent]. United States Patent and Trademark Office.
 What AI Still Doesn‚Äôt Understand About Truth

	 /* ******************************************** */
         /*                 BAYES96X.C                   */
	 /*                   1.21GW                     */
	 /*                 HIREZ VER                    */
	 /*               FOR:  WATCOM 10.0              */
         /*          last edit  Feb 5, 2021              */
	 /*            Written by C.P.Wendling           */
	 /* ******************************************** */

//  Limited to one pass, no stops or reentries on 052901
//  Note: targets that are "hit" are assumed to be taken at the target price.
//  Added code to support "primary & secondary" .prd's   1/3/94
//  Note: secondary .prd's are not evolved genetically. 
//  Added code to output realized&unrealized equity points stream. 1/7/94
//  Added code to limit number of re-entries 2-16-94
//  Added code to genetically evolve maps/traders.  2-28-94
//  N/A Added code to toggle "dynamic targets"-> close positions if .prd flips
//  Modified to use points, not percent  1-30-95
//  Modified account stream plot to use constant vert axis scale,
//  green is train set, magenta is optimize set, yellow is verify set.
//  Added additional trading variables to evolved parameters.  1/30/95
//  Modified simulation event order:reenter/stop/hit target/time out. 
//  Modified to enter at closing price(day that .prd is calculated.) 2/26/95
//  N/A Added minimum stop threshold 3/3/95
//  This version uses standard .prn format: o,h,l,c data files.
//  This version allows continued evolution after reading .pop file.  3-25-95
//  Modified  to include 4 coordinated price files ala 2-streams. 3/27/95
//  Modified to use independently evolved future looks for target calculations. 
//  The fitness function is the Sterling ratio over the optimization data subset
//  with non-linear penalties for: 1) "over-representation" (to force generaliozation)
//  and 2) trading infrequency.
//  N/A This version uses elite-ism in the evolution algorithm.
//  This version also simulates annealing of the mutation "distance" per generation.
//  Added code to write/overwrite "autosav.map" every 5 generations.
//  Changed to: Spread positions allowed ... 10/03/01
//  Changed to 4 supporting mkts, with to-be-forecasted mkt NOT on map. 03-22-02

#include <stdio.h>
#include <dos.h>
#include <math.h>
#include <graph.h>
#include <stdlib.h>

static union REGS xr,yr;
unsigned int xcurs,ycurs;

#define                 EVER             ;;
#define                 MAXLINES         6000
#define                 MAGENTA          5
#define                 RED              4
#define                 GREEN            2
#define                 BLUE             1
#define                 CYAN             3
#define                 BROWN            6
#define                 DARKGRAY         8
#define                 LIGHTGRAY        7
#define                 LIGHTBLUE        9
#define                 LIGHTGREEN       10
#define                 LIGHTCYAN        11
#define                 LIGHTRED         12
#define                 LIGHTMAGENTA     13
#define                 YELLOW           14
#define                 WHITE            15
#define                 BLACK            0
#define                 SCALE            100
#define                 XSIZE            240
#define                 YSIZE            800
#define                 CENTER1          50
#define                 CENTER2          150
#define                 CENTER3          250
#define                 CENTER4          350
#define                 CENTER5          450
#define                 CENTER6          550
#define                 CENTER7          650
#define                 CENTER8          750

#define                 MAXPOPULATION    100 
#define                 MAXDIST          7
#define                 MAXGENES         MAXDIST*16+33

FILE *djiaf; 
FILE *prd;
FILE *prd2;
FILE *f;
FILE *pr;
FILE *equ;
FILE *du;


static union REGS xr,yr;
int ft1; // std dev sampling period-evolved
int ft2,ft3; // available-evolved
float gft2;
float gft3;
int ft4;   // available
long f2=5;   //ref offset for traces
long f3=10;  //    "
long f4=15;  //    "
long ocount;
float map[XSIZE][YSIZE];
float map2[XSIZE][YSIZE];
float map3[XSIZE][YSIZE];
float tempmap[XSIZE][YSIZE];
int grtoggle=-1; //graphics toggle is off, 1 =on
int fittype=1; // 1=sterling, 2=returns/rms dd's, 3 = returns/variance
int targtype=1;    
int tradertype=3;  // 1 = long, 2 = short, 3 = both
int entrytypeflag=1;  // 1=enter on close,0=enter on next days open
int maxdeadrun;
int datatype;  // 1= ohlc   0= close
int virg=250;
float mutrate=.01;
int gcmaxpass=1;    // maximum map training passes
int maxpass;        // number of training passes for map
int gflook=10;     // for upper and lower performance bands
float mltq=1.0;    // user specified minimum lots to qualify;
long offspring[MAXGENES];
long parent[MAXPOPULATION][MAXGENES];
long bestoos[1][MAXGENES];
int mutperiod=1; // number of generations between mutations
						// mutation magnitude is annealed by generation number
float worstfit;
int worstss;
int best_ss;
float bestfit;
float worstoosfit;
float bestoosfit;

float fitness[MAXPOPULATION+1];
float oosfitness[MAXPOPULATION+1];
int seed;
int competitor_ss=0;
float utile,ltile;
float bsad=-1000.0;   // Best fitness over All Data
int evoptdays=1;
float clippedvar;
float ipc=0.0;
float matpc=0.0;
float opc=0.0;
float fitness_offspring;
float oosfitness_offspring;
float fitness_competitor;
int competitor_ss;
float avegenfit[501];
float avelyeq[1500];   // average equity array over virgin data for generation
float favelyeq[1500];
float thisciteq[1500];  // last citizen used equity stream on virgin data
float trace[250];
float trace2[250];
float trace3[250];
float trace4[250];
float aapw;
float weightcount;
float maxweights;
int startgen;
int ss;   // "social security" number used to track populations
long besteverchrom[1][MAXGENES];
float lrate=.004;
float lrate2=.004;
float lrate3=.004;
float lrate4=.004;
int tracelength=100;
int tracelength2=100;
int tracelength3=100;
int tracelength4=100;
int mapscale[MAXDIST*8+1];
float dayweight[XSIZE+1];  // range 0 to 1.0
int gcmaxsamples;
int gcmaxhist;
int maaapg;     // minimum acceptable average annual points gain, user spec'd
float gcfsf;    // global constant forecast scale factor
float dr;       // determined ratio (# active map weights/#training pairs)
float gcstopthresh;
float minstopthresh;
float gcrthresh;
int gclotspertrade;
int gcmaxlots;
int gcmaxreentry;
float puritythresh;
int gcmapscale;
float bestalltime=0.0;
char pricestream[30];
char prdstream[30];
char prdstream2[30];
int oflag;                  // optimization code running=1, else=0
int startss;
int nod;                    // number of data days in djia file 
int flook=10;
int hs=0;
float sumnew=0.0;
float sumnewcells[MAXLINES];
float sumret[MAXLINES];
float vixc[MAXLINES];        // vix array
float c[MAXLINES];          // closing price array 
float c2[MAXLINES];         // coordinated price stream #1
float c3[MAXLINES];         // coordinated price stream #2
float c4[MAXLINES];         // coordinated price stream #3
float c5[MAXLINES];         // coordinated price stream #4
float c6[MAXLINES];         // coordinated price stream #5
float c7[MAXLINES];         // coordinated price stream #6
float c8[MAXLINES];         // coordinated price stream #7
float c9[MAXLINES];         // coordinated price stream #8
float c10[MAXLINES];         // coordinated price stream #9
float c11[MAXLINES];         // coordinated price stream #10
float c12[MAXLINES];         // coordinated price stream #11
float c13[MAXLINES];         // coordinated price stream #12
float c14[MAXLINES];         // coordinated price stream #13
float c15[MAXLINES];         // coordinated price stream #14
float c16[MAXLINES];         // coordinated price stream #15
float c17[MAXLINES];         // coordinated price stream #16
float c18[MAXLINES];           
float c19[MAXLINES];         
float c20[MAXLINES];         
float c21[MAXLINES];         
float c22[MAXLINES];         
float c23[MAXLINES];         // coordinated price stream 
float c24[MAXLINES];         // coordinated price stream 
float c25[MAXLINES];         // coordinated price stream 
float c26[MAXLINES];         // coordinated price stream 
float c27[MAXLINES];         // coordinated price stream 
float c28[MAXLINES];         // coordinated price stream 
float c29[MAXLINES];         // coordinated price stream 
float c30[MAXLINES];         // coordinated price stream 
float c31[MAXLINES];         // coordinated price stream 
float c32[MAXLINES];         // coordinated price stream 
float c33[MAXLINES];         // coordinated price stream

float c34[MAXLINES];           
float c35[MAXLINES];         
float c36[MAXLINES];         
float c37[MAXLINES];         
float c38[MAXLINES];         
float c39[MAXLINES];           
float c40[MAXLINES];         
float c41[MAXLINES];         
float c42[MAXLINES];         
float c43[MAXLINES];         
float c44[MAXLINES];           
float c45[MAXLINES];         
float c46[MAXLINES];         
float c47[MAXLINES];         
float c48[MAXLINES];         
float c49[MAXLINES];           

float c50[MAXLINES];           
float c51[MAXLINES];         
float c52[MAXLINES];         
float c53[MAXLINES];         
float c54[MAXLINES];         
float c55[MAXLINES];           
float c56[MAXLINES];         
float c57[MAXLINES];         
float c58[MAXLINES];         
float c59[MAXLINES];         
float c60[MAXLINES];           
float c61[MAXLINES];         

float c62[MAXLINES];           
float c63[MAXLINES];         
float c64[MAXLINES];         
float c65[MAXLINES];         
float c66[MAXLINES];         
float c67[MAXLINES];           
float c68[MAXLINES];         
float c69[MAXLINES];         
float c70[MAXLINES];         
float c71[MAXLINES];         
float c72[MAXLINES];           
float c73[MAXLINES];         

float c74[MAXLINES];           
float c75[MAXLINES];         
float c76[MAXLINES];         
float c77[MAXLINES];         
float c78[MAXLINES];         
float c79[MAXLINES];           
float c80[MAXLINES];         
float c81[MAXLINES];         
float c82[MAXLINES];         
float c83[MAXLINES];         
float c84[MAXLINES];           
float c85[MAXLINES];         

float c86[MAXLINES];           
float c87[MAXLINES];         
float c88[MAXLINES];         
float c89[MAXLINES];         
float c90[MAXLINES];         
float c91[MAXLINES];           
float c92[MAXLINES];         
float c93[MAXLINES];         
float c94[MAXLINES];         
float c95[MAXLINES];         
float c96[MAXLINES];           
float c97[MAXLINES];         



float xprd[50][MAXLINES];
float o[MAXLINES];          // open price array
float h[MAXLINES];          // high price array
float l[MAXLINES];          // low price array
float pred[MAXLINES];       // prediction stream 
float predraw[MAXLINES];    // raw proportion stream
float pred2[MAXLINES];
int predtype[MAXLINES];
float lotresult[80000];
float monthlygain[MAXLINES];
int openmarker[MAXLINES];
int closemarker[MAXLINES];
int stopmarker[MAXLINES];
int reentermarker[MAXLINES];
float account[MAXLINES];
float randu[MAXLINES];  // realized and unrealized revenue stream array
float marketpts[MAXLINES];
float htscale=2.0;
float longthresh=.00750;  // primary
float longthresh2=.00750;  //secondary
int gcmaxhold=30;  // max trading days long position can be held open
int gcsmaxhold=30;  // max trading days short position can be held open
float shortthresh=-.00750;
float shortthresh2=-.00750;
float stopthresh=4.0;    // 4.0 S&P points
float rthresh=1.0;     // reenter;  1.0 S&P points
long lotcount;
int simstart,simstop;
float fsf=1.0;      // forecast scale factor
int lotopenref[150]; //ref day lot opened
int tradetype[150];   // 1=primary long,2=secondary long,-1=prim short,-2=sec short
int lotstatus[150]; // 1=active,0=available,2=stopped long,3=stopped short
int lotrcount[150]; // lot re-entry count
float lottarget[150]; // forecasted scaled target price
float lotentryprice[150];
float lotexitprice[150];
float maxcloseprice[150];
float mincloseprice[150];
int maxlots=10;
int color;
int d;       // audit flag  0=off, 1=on
int eq=0;    // equity stream output flag
int lotspertrade=3;
int maxhold=10;
int smaxhold=10;
int mddref=0;     //beginning of max draw down ref day #
int mdd20,max20,mdd20a;
int mdd60,max60,mdd60a;
int mdd120,max120,mdd120a;
int mdd250,max250,mdd250a;
int lymdd20,lymdd60,lymdd120,lymdd250;
float slippage=0.0;       //  .05 big points=$62.50 per contract,currency,round turn
float sharperatio;
int trailing=0;
int nospreadflag=0;
int maxreentry=3;
float best=0.0;
long accountscale=5000;   // max points on y axis for account plot
int dynamicflag=0;
int wincount,losscount;
float winsum,losssum;
	long kount=0;   // total lots traded over simulation
	int numlotsactive=0;  // number of open positions at any time
	int numhittarget=0;
	int numexpprofit=0;
	int numexploss=0;
	int numstopsexp=0;
	int numstopped=0;
	int numreentered=0;
	int numlotsnostop=0;
	float openlotvalue;
	float cab=0.0;   // cash account balance
	float sumdaysold=0.0;
	int lotnum;
	int longflag,shortflag;
	int mcount=0;   // month count
	float oldaccount;
	float summonthlygain=0.0;
	float avemonthlygain;
	float ave;
	float chg;              // points change of offset lots
	double sumdiffsqrd=0.0;
	double stddev;
	float sum;
char istream1[40];
char istream2[40];
char istream3[40];
char istream4[40];
char istream5[40];
char istream6[40];
char istream7[40];
char istream8[40];
char istream9[40];
char istream21[40];
char istream22[40];
char istream23[40];
char istream24[40];
char istream25[40];
char istream26[40];
char istream27[40];
char istream28[40];
char istream29[40];
char istream30[40];
char istream31[40];
char istream32[40];
char istream33[40];
char istream34[40];
char istream35[40];
char istream36[40];
char istream37[40];
char istream38[40];
char istream39[40];
char istream40[40];
char istream41[40];
char istream42[40];
char istream43[40];
char istream44[40];

char istream45[40];
char istream46[40];
char istream47[40];
char istream48[40];
char istream49[40];
char istream50[40];
char istream51[40];
char istream52[40];
char istream53[40];
char istream54[40];
char istream55[40];
char istream56[40];
char istream57[40];
char istream58[40];
char istream59[40];
char istream60[40];


char istream61[40];
char istream62[40];
char istream63[40];
char istream64[40];
char istream65[40];
char istream66[40];
char istream67[40];
char istream68[40];
char istream69[40];
char istream70[40];
char istream71[40];
char istream72[40];
char istream73[40];
char istream74[40];
char istream75[40];
char istream76[40];
char istream77[40];
char istream78[40];
char istream79[40];
char istream80[40];
char istream81[40];
char istream82[40];
char istream83[40];
char istream84[40];
char istream85[40];
char istream86[40];
char istream87[40];
char istream88[40];
char istream89[40];
char istream90[40];
char istream91[40];
char istream92[40];
char istream93[40];
char istream94[40];
char istream95[40];
char istream96[40];
char istream97[40];
char istream98[40];
char istream99[40];
char istream100[40];
char istream101[40];
char istream102[40];
char istream103[40];
char istream104[40];
char istream105[40];
char istream106[40];
char istream107[40];
char istream108[40];





char istream11[40];  // output .lot stream for auto production
char istream12[40];  // output .prd stream filename
char imap[40];
char itask[40];
char mappath[80];
int mapnamecount=0;  // incremental integer map name
char opop[30];   // output .pop file name for batch mode
char parms[30];
char ostream[30];
int manualmode=0;    // =1 if manual, 0 if command line
int initflag=0;
int bmf=0; // batch mode flag, 0 if not batchmode, 1 if batchmode
int cbmf=0; // continue batch mode flag
long maxocount=30000;
int hide=0; // number of hidden n days from system and from view
int hidetoggle=1;  // -1=invisible +1=visible
int dumptoggle=0;   // 1 to dump *.lot, 2 to dump .prd files
int mutatedflag;
int numsupportmarkets;

float variance;
float oosvariance;
float virgvariance;
int stepflag;
int donestep;
int maptype; // 1 = sum into cells, 2 = ave into cells

float proportion_contained;
float rss=1.0;  // return stream scale -viewing graphics
float grss=1.0; // global return stream scale
float virgfitness;
float vf[30001];
float oosf[30001];
float frontoos[30001];
float moos[30001];
float moos2[30001];
float scatterscale=1.0;
int learn;  // number of days used to learn map frequency ditributions
int foldshift; // number of days to shift opt period to the left in 10-fold
int moosb=1400; // monitor oos beginning
int moose=1550; // monitor oos end
int moosb2=2900; // monitor oos beginning
int moose2=3050; // monitor oos end
int fold;
int foldwidth;
float optreturns2;
float virgreturns2;
float agefactor=1.0;
float mapspread[210];
float wla,wlb,wlc,wld;
int trainflook;
float trailstdevc2=1.0;
float trailstdevc3=1.0;
float trailstdevc4=1.0;
float trailstdevc5=1.0;
float trailstdevc6=1.0;
float trailstdevc7=1.0;
float trailstdevc8=1.0;
float trailstdevc9=1.0;
float globalsum,globalcount;
float globalchg;
float fn[30];
int ttp=0;  // total traces presented to map
int twtp=0;  // total WINNING traces presented to map
int tltp=0;  // total LOSING traces presented
/***********************************************************************/

main(argc,argv)
	int argc;
	char *argv[];
	  {
          int ref,x;
          for(x=1;x<209;x++)
                {
                mapspread[x]=1.0/sqrt((float)x);
                }
          if(argc != 2 && argc != 3 && argc != 4 && argc != 6 && argc != 7)   // to run in manual mode
			{
			manualmode=1;
			for(;;)
				menu();
			}
		if(argc == 2)   // to automatically build maps
			{
			strcpy(parms,argv[1]);
			bmf=1;
			rd_parms(); // read control parameter file
			srand(seed);
			rd_prices(); //read to be forecasted stream
                    //    printf("reading prices...\n");
                        delay(5000);
			for(EVER)
				setup();
			}
		if(argc == 3)  // to automatically output single .lot stream
			{
			strcpy(imap,argv[1]);     // input map filename
			strcpy(istream11,argv[2]); // output .lot filename
                        dumptoggle=1;   // to dump *.lot files to disk
			initflag=1;
			read_map();
			for(ref=250;ref<=nod;ref++)
				 c_perfn(ref);
			normalize();
			simstrat();
			exit(1);
			}
	  if(argc == 4)  // to automatically output multiple .lot stream
			{
			strcpy(itask,argv[1]);     // input task filename
                        dumptoggle=1;  // to dump *.lot files to disk
			run_task();
			exit(1);
			}
          if(argc == 6)  // to automatically output single .prd stream
			{
			strcpy(imap,argv[1]);     // input map filename
                        strcpy(istream12,argv[2]); // output .prd filename
			initflag=1;
			read_map();
			for(ref=250;ref<=nod;ref++)
				 c_perfn(ref);
			normalize();
                        du=fopen(istream12,"w");
                        for(ref=500;ref<=nod;ref++)
                                {
                             //   printf("%f\n",pred[ref]);
                                fprintf(du,"%f\n",pred[ref]);
                                }
                        fclose(du);
			exit(1);
			}
          if(argc == 7)  // to automatically output multiple .prd streams
			{
			strcpy(itask,argv[1]);     // input task filename
                        dumptoggle=2;  // to dump .prd files to disk
			run_task();
			exit(1);
                        }

	  }



normalize()
	{
	int ref,x;
	float xbar,sum,count,sumdiffsqrd,stdev,ave;
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
	for(ref=250;ref<=nod;ref++)
		{
                predtype[ref]=1;
                if(predtype[ref]==1)
                        {
                        sum+=predraw[ref];
                        count=count+1.0;
                        }
		}
	ave=sum/count;
        for(ref=250;ref<=nod;ref++)
		{
                if(predtype[ref]==1)
                        {
                        pred[ref]=predraw[ref]-ave;
                        }
		}
	sum=0.0;
	count=0.0;
        for(ref=simstart;ref<=nod;ref++)
		{
                if(predtype[ref]==1)
                        {
                        sum+=pred[ref];
                        count+=1.0;
                        }
		}
	xbar=sum/count;
        for(ref=simstart;ref<=nod;ref++)
		{
                if(predtype[ref]==1)
                        {
                        sumdiffsqrd+=(xbar-pred[ref])*(xbar-pred[ref]);
                        }
		}
	stdev=sqrt(sumdiffsqrd/count);
	for(ref=0;ref<=nod;ref++)
		{
                if(predtype[ref]==1)
                        {
                        pred[ref]/=stdev;
                        }
		}
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
	for(ref=250;ref<=nod;ref++)
		{
                if(predtype[ref]==2)
                        {
                        sum+=predraw[ref];
                        count=count+1.0;
                        }
		}
	ave=sum/count;
        for(ref=250;ref<=nod;ref++)
		{
                if(predtype[ref]==2)
                        {
                        pred[ref]=predraw[ref]-ave;
                        }
		}
	sum=0.0;
	count=0.0;
        for(ref=simstart;ref<=nod;ref++)
		{
                if(predtype[ref]==2)
                        {
                        sum+=pred[ref];
                        count+=1.0;
                        }
		}
	xbar=sum/count;
        for(ref=simstart;ref<=nod;ref++)
		{
                if(predtype[ref]==2)
                        {
                        sumdiffsqrd+=(xbar-pred[ref])*(xbar-pred[ref]);
                        }
		}
	stdev=sqrt(sumdiffsqrd/count);
	for(ref=0;ref<=nod;ref++)
		{
                if(predtype[ref]==2)
                        {
                        pred[ref]/=stdev;
                        }
		}


	return(1);
	}












c_trailstdev(ref)
        int ref;
	{
        int x;
        float xbar,sum,count,sumdiffsqrd,stdev,chg;
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
   /*     for(x=0;x<=ft1;x++)
		{
                chg=(c[ref-x]/c[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c[ref-x]/c[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc2=sqrt(sumdiffsqrd/count);
        sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c3[ref-x]/c3[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c3[ref-x]/c3[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc3=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c4[ref-x]/c4[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c4[ref-x]/c4[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc4=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c5[ref-x]/c5[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c5[ref-x]/c5[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc5=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c6[ref-x]/c6[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c6[ref-x]/c6[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc6=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c7[ref-x]/c7[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c7[ref-x]/c7[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc7=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c8[ref-x]/c8[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c8[ref-x]/c8[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc8=sqrt(sumdiffsqrd/count);
	sum=0.0;
	count=0.0;
	sumdiffsqrd=0.0;
        for(x=0;x<=ft1;x++)
		{
                chg=(c9[ref-x]/c9[ref-(x+1)]-1.0)*100.0;
                sum+=chg;
                count+=1.0;
		}
	xbar=sum/count;
        for(x=0;x<=ft1;x++)
		{
                chg=(c9[ref-x]/c9[ref-(x+1)]-1.0)*100.0;
                sumdiffsqrd+=(xbar-chg)*(xbar-chg);
		}
        trailstdevc9=sqrt(sumdiffsqrd/count);
        */
	return(1);
	}




setup()
	{
	rd_coorprices1();
	rd_coorprices2();
	rd_coorprices3();
	rd_coorprices4();
	rd_coorprices5();
	rd_coorprices6();
	rd_coorprices7();
	rd_coorprices8();
        rd_coorprices9();
        rd_coorprices10();
        rd_coorprices11();
        rd_coorprices12();
        rd_coorprices13();
        rd_coorprices14();
        rd_coorprices15();
        rd_coorprices16();
        rd_coorprices17();
        rd_coorprices18();
        rd_coorprices19();
        rd_coorprices20();
        rd_coorprices21();
        rd_coorprices22();
        rd_coorprices23();
        rd_coorprices24();
        rd_coorprices25();
        rd_coorprices26();
        rd_coorprices27();
        rd_coorprices28();
        rd_coorprices29();
        rd_coorprices30();
        rd_coorprices31();
        rd_coorprices32();
        rd_coorprices33();
        rd_coorprices34();
        rd_coorprices35();
        rd_coorprices36();
        rd_coorprices37();
        rd_coorprices38();
        rd_coorprices39();
        rd_coorprices40();
        rd_coorprices41();
        rd_coorprices42();
        rd_coorprices43();
        rd_coorprices44();
        rd_coorprices45();
        rd_coorprices46();
        rd_coorprices47();
        rd_coorprices48();
        rd_coorprices49();
        rd_coorprices50();
        rd_coorprices51();
        rd_coorprices52();
        rd_coorprices53();
        rd_coorprices54();
        rd_coorprices55();
        rd_coorprices56();
        rd_coorprices57();
        rd_coorprices58();
        rd_coorprices59();
        rd_coorprices60();
        rd_coorprices61();
        rd_coorprices62();
        rd_coorprices63();
        rd_coorprices64();
        rd_coorprices65();
        rd_coorprices66();
        rd_coorprices67();
        rd_coorprices68();
        rd_coorprices69();
        rd_coorprices70();
        rd_coorprices71();
        rd_coorprices72();
        rd_coorprices73();
        rd_coorprices74();
        rd_coorprices75();
        rd_coorprices76();
        rd_coorprices77();
        rd_coorprices78();
        rd_coorprices79();
        rd_coorprices80();
        rd_coorprices81();
        rd_coorprices82();
        rd_coorprices83();
        rd_coorprices84();
        rd_coorprices85();
        rd_coorprices86();
        rd_coorprices87();
        rd_coorprices88();
        rd_coorprices89();
        rd_coorprices90();
        rd_coorprices91();
        rd_coorprices92();
        rd_coorprices93();
        rd_coorprices94();
        rd_coorprices95();
        rd_coorprices96();

	run_batch();
	return(1);
	}


run_task()
	{
	int ref,x;
	prd2=fopen(itask,"r");
	if(prd2 == NULL)
		{
		printf("Can't open task control file: %s\n",itask);
		delay(2000);
		exit(1);
		}
	while(fscanf(prd2,"%s %s\n",imap,istream11) != EOF)
		{
		printf("Processing %s %s\n",imap,istream11);
		initflag=1;
		read_map();
		for(ref=250;ref<=nod;ref++)
			c_perfn(ref);
		normalize();
		simstrat();
		continue;
		}
	fclose(prd2);
	return(1);
	}








rd_parms()
	{
	char rem[80];
	char string[30];
	int x;
	prd=fopen(parms,"r");
	if(prd == NULL)
		{
		printf("Can't open parameter control file: %s\n",parms);
		delay(2000);
		exit(1);
		}
	fscanf(prd,"%s\n",&istream1);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&tradertype);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%s\n",&mappath);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&hide);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&virg);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&evoptdays);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&learn);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%f\n",&rss);
	fscanf(prd,"%s ",&rem);  // read param description
        fscanf(prd,"%f\n",&scatterscale);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&seed);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&gcmaxhold);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&gcsmaxhold);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%f\n",&gcfsf);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&gclotspertrade);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&gcmaxlots);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%f\n",&mltq);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%f\n",&maxweights);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&targtype);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&fittype);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&maptype);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%f\n",&mutrate);
	fscanf(prd,"%s ",&rem);  // read param description
        fscanf(prd,"%f\n",&puritythresh);
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&gcmapscale);
	fscanf(prd,"%s ",&rem);  // read param description
        fscanf(prd,"%d\n",&gcmaxsamples);    //tracelength
	fscanf(prd,"%s ",&rem);  // read param description
        fscanf(prd,"%d\n",&gcmaxhist);  // trainflook, see assignment below
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%ld\n",&maxocount);  // max offspring
	fscanf(prd,"%s ",&rem);  // read param description
	fscanf(prd,"%d\n",&numsupportmarkets);
	fscanf(prd,"%s ",&rem);  // read param description
        trainflook=gcmaxhist;
	fscanf(prd,"%s",&istream2);
	fscanf(prd,"%s",&istream3);
	fscanf(prd,"%s",&istream4);
	fscanf(prd,"%s",&istream5);
	fscanf(prd,"%s",&istream6);
	fscanf(prd,"%s",&istream7);
	fscanf(prd,"%s",&istream8);
	fscanf(prd,"%s",&istream9);
        fscanf(prd,"%s",&istream21);
        fscanf(prd,"%s",&istream22);
        fscanf(prd,"%s",&istream23);
        fscanf(prd,"%s",&istream24);
        fscanf(prd,"%s",&istream25);
        fscanf(prd,"%s",&istream26);
        fscanf(prd,"%s",&istream27);
        fscanf(prd,"%s",&istream28);
        fscanf(prd,"%s",&istream29);
        fscanf(prd,"%s",&istream30);
        fscanf(prd,"%s",&istream31);
        fscanf(prd,"%s",&istream32);
        fscanf(prd,"%s",&istream33);
        fscanf(prd,"%s",&istream34);
        fscanf(prd,"%s",&istream35);
        fscanf(prd,"%s",&istream36);
        fscanf(prd,"%s",&istream37);
        fscanf(prd,"%s",&istream38);
        fscanf(prd,"%s",&istream39);
        fscanf(prd,"%s",&istream40);
        fscanf(prd,"%s",&istream41);
        fscanf(prd,"%s",&istream42);
        fscanf(prd,"%s",&istream43);
        fscanf(prd,"%s",&istream44);

        fscanf(prd,"%s",&istream45);
        fscanf(prd,"%s",&istream46);
        fscanf(prd,"%s",&istream47);
        fscanf(prd,"%s",&istream48);
        fscanf(prd,"%s",&istream49);
        fscanf(prd,"%s",&istream50);
        fscanf(prd,"%s",&istream51);
        fscanf(prd,"%s",&istream52);
        fscanf(prd,"%s",&istream53);
        fscanf(prd,"%s",&istream54);
        fscanf(prd,"%s",&istream55);
        fscanf(prd,"%s",&istream56);
        fscanf(prd,"%s",&istream57);
        fscanf(prd,"%s",&istream58);
        fscanf(prd,"%s",&istream59);
        fscanf(prd,"%s",&istream60);

        fscanf(prd,"%s",&istream61);
        fscanf(prd,"%s",&istream62);
        fscanf(prd,"%s",&istream63);
        fscanf(prd,"%s",&istream64);
        fscanf(prd,"%s",&istream65);
        fscanf(prd,"%s",&istream66);
        fscanf(prd,"%s",&istream67);
        fscanf(prd,"%s",&istream68);
        fscanf(prd,"%s",&istream69);
        fscanf(prd,"%s",&istream70);
        fscanf(prd,"%s",&istream71);
        fscanf(prd,"%s",&istream72);
        fscanf(prd,"%s",&istream73);
        fscanf(prd,"%s",&istream74);
        fscanf(prd,"%s",&istream75);
        fscanf(prd,"%s",&istream76);
        fscanf(prd,"%s",&istream77);
        fscanf(prd,"%s",&istream78);
        fscanf(prd,"%s",&istream79);
        fscanf(prd,"%s",&istream80);
        fscanf(prd,"%s",&istream81);
        fscanf(prd,"%s",&istream82);
        fscanf(prd,"%s",&istream83);
        fscanf(prd,"%s",&istream84);
        fscanf(prd,"%s",&istream85);
        fscanf(prd,"%s",&istream86);
        fscanf(prd,"%s",&istream87);
        fscanf(prd,"%s",&istream88);
        fscanf(prd,"%s",&istream89);
        fscanf(prd,"%s",&istream90);
        fscanf(prd,"%s",&istream91);
        fscanf(prd,"%s",&istream92);
        fscanf(prd,"%s",&istream93);
        fscanf(prd,"%s",&istream94);
        fscanf(prd,"%s",&istream95);
        fscanf(prd,"%s",&istream96);
        fscanf(prd,"%s",&istream97);
        fscanf(prd,"%s",&istream98);
        fscanf(prd,"%s",&istream99);
        fscanf(prd,"%s",&istream100);
        fscanf(prd,"%s",&istream101);
        fscanf(prd,"%s",&istream102);
        fscanf(prd,"%s",&istream103);
        fscanf(prd,"%s",&istream104);
        fscanf(prd,"%s",&istream105);
        fscanf(prd,"%s",&istream106);
        fscanf(prd,"%s",&istream107);
        fscanf(prd,"%s",&istream108);








        fscanf(prd,"%d\n",&moosb);
	fscanf(prd,"%s ",&rem);  // read param description
        fscanf(prd,"%d\n",&moose);
	fscanf(prd,"%s ",&rem);  // read param description
	fclose(prd);
	return(1);
	}
	
run_batch()
		{
		char ch;
        	char string[30];
		int firstime,origss;
                int popl;
		int flag;
		int ref;
		int brkflag=0;
		int n;
		int genenum;
		float lastoosfit=-1000000.0;
		float div;
		clrscr();
		firstime=0;
		flag=0;
		if(flag == 0 && cbmf != 1)
			{
			bsad=0.0;
			init_avegenfit();
			gcmaxpass=1;
			gcstopthresh=1000.0;
			minstopthresh=999.0; 
			gcrthresh=1000.0;
			gcmaxreentry=1;
			trailing=0;
			nospreadflag=0;
			init_pop();
			bestalltime=0.0;
			startgen=1;
			startss=0;
			}
		d=0;      // set audit trail off
		oflag=1;  // set optimization flag on
		clrscr();
		if(flag == 0 && cbmf != 1) //start from scratch
			{
			ocount=1;
			//initialize population fitnesses
			initflag=1;
			for(ss=0;ss<MAXPOPULATION;ss++)
				{
				competitor_ss=ss;
                                popl=MAXPOPULATION;
                                printf("                                 INITIALIZING CITIZEN # %d of %d \n",ss,popl);
				printf("                                 PLEASE BE PATIENT...");
				calc_params_competitor();
                                for(fold=1;fold<=10;fold++)
					{
					init_map();
                                        foldwidth=learn/9;
					foldshift=foldwidth*(fold-1);
				 //	if(foldshift > (learn-250))
				 //		foldshift=learn-250;
					build_map();
                                        fix_maps();
					for(ref=250;ref<=nod;ref++)
						 c_perfn(ref);
					normalize();
					simstrat();
					c_mddsa();
					calc_fitness_competitor();
					}
				printf("Fitness of citizen # %d = %f\n",ss,fitness[competitor_ss]);
				}
			}
		initflag=1;
		for(EVER)
			{
			ocount+=1;
                        printf("\n\n\n\n\n                                      ****** offspring # %ld\n",ocount);
			if(brkflag == 1)
				  break;
			havesex(); // offspring[genestring] is result
		 //	mutate();  now done inside have sex function
			if(mutatedflag)
				{
			//   printf("Calculating fitness of mutation\n");
				calc_params_competitor();
				init_map();
                                for(fold=1;fold<=10;fold++)
					{
					init_map();
                                        foldwidth=learn/9;
					foldshift=foldwidth*(fold-1);
				 //	if(foldshift > (learn-250))
				 //		foldshift=learn-250;
					build_map();
                                        fix_maps();
					for(ref=250;ref<=nod;ref++)
						 c_perfn(ref);
					normalize();
					simstrat();
					c_mddsa();
					calc_fitness_competitor();
					}
				sum=0.0;
				for(n=0;n<MAXPOPULATION;n++)
					 sum+=fitness[n];
				printf("Average Population fitness after mutation = %f\n",sum/n);
				}
			if(grtoggle == 1)
				{
				gotoxy(0,6);
				}
			printf("Calculating fitness of offspring\n");
			calc_params_offspring();
			init_map();
                        for(fold=1;fold<=10;fold++)
				{
				init_map();
                                foldwidth=learn/9;
				foldshift=foldwidth*(fold-1);
		    //	if(foldshift > (learn-250))
		    //		foldshift=learn-250;
				build_map();
                                fix_maps();
				for(ref=250;ref<=nod;ref++)
					 c_perfn(ref);
				normalize();
				simstrat();
				c_mddsa();
				calc_fitness_offspring();
				}
			if(ocount % 300 == 0) // pump population fitness
				{
                                for(ss=0;ss<MAXPOPULATION;ss++)
					fitness[ss]*=agefactor;
                                }
			// find worstss & bestss
			worstfit=10000.0;
			bestfit=-10000.0;
			for(ss=0;ss<MAXPOPULATION;ss++)// find best and worst fitness ss
				{
				if(fitness[ss] < worstfit)
				  {
				  worstfit=fitness[ss];
				  worstss=ss;
				  }
				if(fitness[ss] > bestfit)
				  {
				  bestfit=fitness[ss];
				  best_ss=ss;
				  }
				}
			for(genenum=0;genenum<MAXGENES;genenum++)
					 parent[0][genenum]=parent[best_ss][genenum];
			fitness[0]=bestfit;


			//competitor_ss=rand()/(32766/MAXPOPULATION);
			competitor_ss=worstss;
			
			if(fitness_offspring > fitness[competitor_ss])
				 {
				 for(genenum=0;genenum<MAXGENES;genenum++)
					 parent[competitor_ss][genenum]=offspring[genenum];
				 fitness[competitor_ss]=fitness_offspring;
				 oosfitness[competitor_ss]=oosfitness_offspring;
				 printf("Competitor  # %d replaced.............\n",competitor_ss);
                                 sum=0.0;
                                 for(n=0;n<MAXPOPULATION;n++)
					sum+=fitness[n];
				 }

			printf("Sum Population fitness = %f\n",sum);
			if(ocount > maxocount)
				{
			 /*	get_best_oos();
				update();
				simstrat();
				if(lastoosfit != bestoosfit)
					{
					lastoosfit=bestoosfit;
					mapnamecount+=1;
					write_OLIVE();
					}   */
                                return(1);
				}   
			if(kbhit())
				 {
				 ch=getch();
				 if(ch == 't')
					{
					if(grtoggle == 1)
						{  
						_setvideomode(_DEFAULTMODE);
						}
					clrscr();
					grtoggle*=-1;
					}
				 if(ch == 'v')
					{
					origss=ss;
					step();
					ss=origss;
					}
				 if(ch == 'a')
					{
					ocount=maxocount;
					}
				 if(ch == 'p')
					{
					clrscr();
					printf("\n\tPaused...           Hit C to continue...\n");
					pause();
					}
             		if(ch == 's')
                    	{
                    	clrscr();
                    	printf("\n\n\n\n\n\tEnter graphics scale for return stream: ");
                    	gets(string);
					rss=atof(string);
					}
				 if(ch == 'z')
					{
					clrscr();
					printf("\n\n\n\n\n\tEnter scale for scattergram: ");
					gets(string);
					scatterscale=atof(string);
					}
				 if(ch == 'h')
					{
					hidetoggle*=-1;
					}
			 
				 if(ch == 'x')
					{
					if(grtoggle == 1)
						{
						_setvideomode(_DEFAULTMODE);
						}
					clrscr();
					cbmf=1;   //set continue batch mode flag	
					update();
					simmenu();
					break;
					}
				 } 
			}
		_setvideomode(_DEFAULTMODE);
		return(1);
		}


get_best_oos()
	{
	// find worstss & bestss (oos)
	int genenum;
	worstoosfit=10000.0;
	bestoosfit=-10000.0;
	for(ss=0;ss<MAXPOPULATION;ss++)// find best and worst oos fitness ss
		{
		if(oosfitness[ss] < worstoosfit)
		  {
		  worstoosfit=oosfitness[ss];
		  }
		if(oosfitness[ss] > bestoosfit)
		  {
		  bestoosfit=oosfitness[ss];
		  best_ss=ss;
		  }
		}
	for(genenum=0;genenum<MAXGENES;genenum++)
		bestoos[0][genenum]=parent[best_ss][genenum];
	return(1);
	}




step()
    {
    char string[30];
    int ref;
    grtoggle=1;
    stepflag=1;
    donestep=0;
    for(ss=0;ss<MAXPOPULATION;ss++)
        {
        competitor_ss=ss;
        printf("                                 INITIALIZING CITIZEN # %d \n",ss);
        calc_params_competitor();
	   init_map();
           for(fold=1;fold<=10;fold++)
		{
		init_map();
                foldwidth=learn/9;
		foldshift=foldwidth*(fold-1);
	 //	if(foldshift > (learn-250))
	 //		foldshift=learn-250;
		build_map();
                fix_maps();
		for(ref=250;ref<=nod;ref++)
			 c_perfn(ref);
		normalize();
		simstrat();
		if(donestep == 1)
			 return(1);
		c_mddsa();
		calc_fitness_competitor();
		}
	   }
    stepflag=0;
    return(1);
    }




pause()
	{
	char ch;
	for(EVER)
		{
		ch=getch();
			{
			if(ch == 'c')
				return(1);
			else
				continue;
			}
		}
	return(1);
	}





rd_close()
	{
	long ref=0;
	char string[80];
	float temp;
	datatype=0;
	printf("Single (close) price stream input routine.\n");
	printf("Can be used for calculating a .prd or mannual map building only.\n");
	printf("Useful for outputting a .prd stream from previuosly evolved maps.\n");
	printf("However, evolutions, and simulations must have O,H,L,C formats.\n");
	printf("Enter single price stream filename, or <enter> to return to menu: ");
	gets(string);
	strcpy(istream1,string);
	printf("%s\n",istream1);
	djiaf=fopen(string,"r");
	if(djiaf == NULL)
		{
		printf("Can't open %s\n",string);
		delay(2000);
		return(1);
		}
	printf("Reading %s file\n",string);
	while(fscanf(djiaf,"%f\n",&temp) != EOF)
		{
		c[ref]=temp;
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	printf("\nNumber of entries = %d\n",nod);
 //	delay(2000);
	return(1);
	}

rd_prices()
	{
	int ref=0;
        float chg;
	datatype=1;

	if(manualmode)
		{
		printf("Enter price stream filename (O,H,L,C format, or *.prn ): ");
		gets(pricestream);
		strcpy(istream1,pricestream);
		}
	djiaf=fopen(istream1,"r");
	if(djiaf == NULL)
		{
		printf("Can't open %s\n",istream1);
		delay(2000);
		return(1);
		}
 //	printf("Reading %s file\n",istream1);
 //	printf("Max file size = 5000 entries");
        while(fscanf(djiaf,"%f\n]",&c[ref]) != EOF)
		{
                o[ref]=c[ref];
                h[ref]=c[ref];
                l[ref]=c[ref];
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
        ref=0;
        djiaf=fopen("\\pr\\d\\vixc.dat","r");
	if(djiaf == NULL)
		{
                printf("Can't open \\pr\\d\\vixc.dat\n");
		delay(2000);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&vixc[ref]) != EOF)
		{
		ref++;
		continue;
		}
	fclose(djiaf);

	simstop=nod;
	simstart=500;
	return(1);
	}




 
rd_coorprices1()
	{
	int ref=0;
	datatype=1;
	if(manualmode)
		{
		printf("Enter first coordinated price stream filename (single stream format): ");
		gets(pricestream);
		strcpy(istream2,pricestream);
		}
	djiaf=fopen(istream2,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream2);
		return(1);
		}
//	printf("Reading %s file\n",istream2);
//	printf("Max file size = 5000 entries");
	while(fscanf(djiaf,"%f\n]",&c2[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
//	printf("\nNumber of entries = %d\n",nod);
//	printf("Last record read: %4.2f\n",c2[nod]);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices2()
	{
	int ref=0;
	datatype=1;
	
	if(manualmode)
		{
		printf("Enter second coordinated price stream filename (single stream format): ");
		gets(pricestream);
		strcpy(istream3,pricestream);
		}
	djiaf=fopen(istream3,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream3);
		return(1);
		}
//	printf("Reading %s file\n",istream3);
//	printf("Max file size = 5000 entries");
	while(fscanf(djiaf,"%f\n]",&c3[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
//	printf("\nNumber of entries = %d\n",nod);
//	printf("Last record read: %4.2f\n",c3[nod]);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices3()
	{
	int ref=0;
	datatype=1;
	
	if(manualmode)
		{
		printf("Enter third coordinated price stream filename (single stream format): ");
		gets(pricestream);
		strcpy(istream4,pricestream);
		}
	djiaf=fopen(istream4,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream4);
		return(1);
		}
//	printf("Reading %s file\n",istream4);
//	printf("Max file size = 5000 entries");
	while(fscanf(djiaf,"%f\n]",&c4[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
//	printf("\nNumber of entries = %d\n",nod);
//	printf("Last record read: %4.2f\n",c4[nod]);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices4()
	{
	int ref=0;
	datatype=1;
	
	if(manualmode)
		{
		printf("Enter fourth coordinated price stream filename (single stream format): ");
		gets(pricestream);
		strcpy(istream5,pricestream);
		}
	djiaf=fopen(istream5,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream5);
		return(1);
		}
	while(fscanf(djiaf,"%f\n]",&c5[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices5()
	{
	int ref=0;
	datatype=1;
	djiaf=fopen(istream6,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream6);
		return(1);
		}
	while(fscanf(djiaf,"%f\n]",&c6[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices6()
	{
	int ref=0;
	datatype=1;
	djiaf=fopen(istream7,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream7);
		return(1);
		}
	while(fscanf(djiaf,"%f\n]",&c7[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}



rd_coorprices7()
	{
	int ref=0;
	datatype=1;
	djiaf=fopen(istream8,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream8);
		return(1);
		}
	while(fscanf(djiaf,"%f\n]",&c8[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices8()
	{
	int ref=0;
	datatype=1;
	djiaf=fopen(istream9,"r");
	if(djiaf == NULL)
		{
		printf("Can't open file %s\n",istream9);
		return(1);
		}
	while(fscanf(djiaf,"%f\n]",&c9[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}


rd_coorprices9()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream21,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream21);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c10[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices10()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream22,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream22);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c11[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices11()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream23,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream23);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c12[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices12()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream24,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream24);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c13[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices13()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream25,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream25);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c14[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices14()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream26,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream26);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c15[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices15()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream27,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream27);
		return(1);
		}
        while(fscanf(djiaf,"%f\n]",&c16[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	simstop=nod;
	simstart=500;
	return(1);
	}

rd_coorprices16()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream28,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream28);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c17[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices17()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream29,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream29);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c18[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices18()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream30,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream30);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c19[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices19()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream31,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream31);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c20[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices20()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream32,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream32);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c21[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices21()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream33,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream33);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c22[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices22()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream34,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream34);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c23[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices23()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream35,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream35);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c24[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices24()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream36,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream36);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c25[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices25()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream37,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream37);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c26[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices26()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream38,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream38);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c27[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices27()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream39,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream39);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c28[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices28()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream40,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream40);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c29[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices29()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream41,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream41);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c30[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices30()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream42,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream42);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c31[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices31()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream43,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream43);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c32[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices32()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream44,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream44);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c33[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices33()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream45,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream45);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c34[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices34()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream46,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream46);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c35[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices35()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream47,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream47);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c36[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices36()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream48,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream48);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c37[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices37()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream49,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream49);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c38[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices38()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream50,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream50);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c39[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices39()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream51,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream51);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c40[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices40()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream52,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream52);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c41[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices41()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream53,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream53);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c42[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices42()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream54,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream54);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c43[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices43()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream55,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream55);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c44[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices44()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream56,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream56);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c45[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices45()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream57,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream57);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c46[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices46()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream58,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream58);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c47[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices47()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream59,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream59);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c48[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices48()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream60,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream60);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c49[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices49()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream61,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream61);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c50[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices50()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream62,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream62);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c51[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices51()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream63,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream63);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c52[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices52()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream64,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream64);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c53[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices53()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream65,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream65);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c54[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices54()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream66,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream66);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c55[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices55()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream67,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream67);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c56[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices56()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream68,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream68);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c57[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices57()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream69,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream69);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c58[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices58()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream70,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream70);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c59[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices59()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream71,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream71);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c60[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices60()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream72,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream72);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c61[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices61()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream73,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream73);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c62[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices62()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream74,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream74);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c63[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices63()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream75,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream75);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c64[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices64()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream76,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream76);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c65[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices65()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream77,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream77);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c66[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices66()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream78,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream78);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c67[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices67()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream79,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream79);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c68[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices68()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream80,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream80);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c69[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices69()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream81,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream81);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c70[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices70()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream82,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream82);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c71[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices71()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream83,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream83);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c72[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices72()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream84,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream84);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c73[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices73()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream85,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream85);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c74[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices74()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream86,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream86);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c75[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices75()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream87,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream87);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c76[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices76()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream88,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream88);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c77[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices77()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream89,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream89);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c78[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices78()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream90,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream90);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c79[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices79()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream91,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream91);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c80[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices80()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream92,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream92);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c81[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices81()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream93,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream93);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c82[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices82()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream94,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream94);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c83[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices83()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream95,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream95);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c84[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices84()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream96,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream96);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c85[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices85()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream97,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream97);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c86[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices86()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream98,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream98);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c87[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices87()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream99,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream99);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c88[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices88()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream100,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream100);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c89[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices89()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream101,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream101);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c90[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices90()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream102,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream102);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c91[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices91()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream103,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream103);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c92[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices92()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream104,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream104);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c93[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices93()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream105,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream105);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c94[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices94()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream106,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream106);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c95[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}

rd_coorprices95()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream107,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream107);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c96[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}


rd_coorprices96()
	{
	int ref=0;
	datatype=1;
        djiaf=fopen(istream108,"r");
	if(djiaf == NULL)
		{
                printf("Can't open file %s\n",istream108);
                delay(10000);
                exit(1);
		}
        while(fscanf(djiaf,"%f\n]",&c97[ref]) != EOF)
		{
		ref++;
		nod=ref-1;
		continue;
		}
	fclose(djiaf);
	return(1);
	}




















menu()
	{
	char string[81];
	clrscr();
	printf("\n\n\n\n\n");
        printf("                                  BAYES96X.EXE\n");
        printf("                                 Copyright 2021\n");
        printf("                                   C. Wendling \n\n\n");
	printf("                                  MENU\n\n");
	printf("                      <R>un Simulations\n");  
	printf("                      <L>ist Command Line Parameters\n");
	printf("                      <X>it to DOS\n\n");
	printf("                                 Enter ONE option: ");
        printf("\n\n\nThe command: BAYES96X \\path\\*.map \\path\\*.lot outputs a single stream .lot file.\n");
	gets(string);
	switch(string[0])
		{
		case'g':
		case'G':
				rd_prices();
				break;
		case'l':
		case'L':
				clrscr();
				printf("This program can be run with command line parameters\n");
				printf("to automatically produce  *.lot files, or manually make *.map files.\n\n");
				printf("In the examples, each parameter must be separated from the next with\n");
				printf("a space.\n\n");
                                printf("The command line format for evolving .map files is:\n");
                                                        printf("<BAYES96X> <Configuration File, see SP1.CFG file for example>\n\n");
				printf("The format for automatically outputing  a single *.lot file stream is:\n"); 
                                                        printf("<BAYES96X> <*.map infile> <*.lot outfile>\n\n");
				printf("The format for outputing multiple *.lot files is:\n");
                                                        printf("<BAYES96X> <tasklist.tsk> <1> <1>\n");
                                printf("Where a typical .tsk file would have multiple lines like: \\pr\\m\\sp1.map \\pr\\l2\\sp1.lot\n\n");
                                printf("The format for outputing a single *.prd file is:\n");
                                                        printf("<BAYES96X> <*.map infile> <*.prd outfile> <1> <1> <1>\n");
                                printf("The format for outputing multiple *.prd files is:\n");
                                                        printf("<BAYES96X> <prdtasklist.tsk> <1> <1> <1> <1> <1>\n");

				printf("Enter returns to main menu...\n");
				getch();
				break;
		case'a':
		case'A':
				rd_coorprices1();
				break;
		case'b':
		case'B':
				rd_coorprices2();
				break;
		case'c':
		case'C':
				rd_coorprices3();
				break;
		case'd':
		case'D':
				rd_coorprices4();
				break;
		case'r':
		case'R':
				for(;;)
					simmenu();
				break;
		case'x':
		case'X':
				clrscr();
				exit(1);
		case'p':
		case'P':
				pr=fopen("PRN","w");
				if(pr == 0)
					{
					printf("Can't open printer\n");
					delay(1000);
					break;
					}
                                fprintf(pr,"              BAYES96X.EXE\n");
				fprintf(pr,"Primary price stream file name(ohlc format): %s\n",istream1);
				fprintf(pr,"2nd Price stream file name: %s\n",istream2);
				fprintf(pr,"3rd Price stream file name: %s\n",istream3);
				fprintf(pr,"4th Price stream file name: %s\n",istream4);
				fprintf(pr,"5th Price stream file name: %s\n",istream5);
				fprintf(pr,"Primary .PRD  stream file name: %s\n",prdstream);
				fprintf(pr,"Secondary .PRD  stream file name: %s\n",prdstream2);
				fprintf(pr,"Primary Long threshold percent ........... %f\n",longthresh*100.0);
				fprintf(pr,"Secondary Long threshold percent.......... %f\n",longthresh2*100.0);
				fprintf(pr,"Primary Short threshold percent........... %f\n",shortthresh*100.0);
				fprintf(pr,"Secondary Short threshold percent......... %f\n",shortthresh2*100.0);
				fprintf(pr,"Max Holding days(long).................... %d\n",maxhold);
				fprintf(pr,"Max Holding days(short)................... %d\n",smaxhold);
				fprintf(pr,"Lots per trade............................ %d\n",lotspertrade);
				fprintf(pr,"Maximum lots allowed ..................... %d\n",maxlots);
				fprintf(pr,"Stop threshold (points)................... %f\n",stopthresh);
				fprintf(pr,"Re-enter threshold (points)............... %f\n",rthresh);
				fprintf(pr,"Slippage per round-turn (points).......... %f\n",slippage);
				fprintf(pr,"Forecast to target scale factor .......... %f\n",fsf);
				fprintf(pr,"Simulation start (ref day#) .............. %d\n",simstart);
				fprintf(pr,"Simulation stop  (ref day#) .............. %d\n",simstop);
				fprintf(pr,"Trailing stop toggle 1=on, 0=off.......... %d\n",trailing);
				fprintf(pr,"Spreads;  0=allowed, 1=prevent............ %d\n\n\n\n",nospreadflag);
				fprintf(pr,"Number of lots put on (new & re-entries)= %ld\n",kount);
				fprintf(pr,"Number of lots that hit target = %d\n",numhittarget);
				fprintf(pr,"Number of open lots that timed-out profitably = %d\n",numexpprofit);
				fprintf(pr,"Number of open lots that timed-out at a loss  = %d\n",numexploss);
				fprintf(pr,"Number of stop-loss hits = %d\n",numstopped);
				fprintf(pr,"Number of re-entries from stopped-out = %d\n",numreentered);
				fprintf(pr,"Number of stopped lots that timed-out = %d\n",numstopsexp);
				fprintf(pr,"Max 20 day draw-down(points)= %d\n",mdd20);
				fprintf(pr,"Max 60 day draw-down(points)= %d\n",mdd60);
				fprintf(pr,"Max 120 day draw-down(points)= %d\n",mdd120);
				fprintf(pr,"Max 250 day draw-down(points)= %d\n",mdd250);
				fprintf(pr,"Max re-entries allowed= %d\n",maxreentry);
				if(kount!=0)
					fprintf(pr,"Average dwell= %3.2f days\n",sumdaysold/kount);
				fprintf(pr,"Total market points gain = %f\n",account[simstop-1]);
				if(kount!=0)
					fprintf(pr,"Mean points gain per lot = %f\n",account[simstop-1]/kount);
				if(mdd250 < 0)
					fprintf(pr,"Ave annual return = %f\n",avemonthlygain*12.0);
				fprintf(pr,"Ave monthly gain points = %f\n\n\n\n",avemonthlygain);
				fclose(pr);
				break;
		case'i':
		case'I':
				input_prd();
				break;
		case'f':
		case'F':
				input_prd2();
				break;
		
		}
	return(1);
	}




mk_box()
	{
	int xmax=639,ymax=479;
	int x=0,y=0;
	color=1;
	_setcolor(color);
	_moveto(0,0);
	_lineto(xmax,y);
	_lineto(xmax,ymax);
	_lineto(x,ymax);
	_lineto(x,y);
	_moveto(x+2,y+2);
	_lineto(xmax-2,y+2);
	_lineto(xmax-2,ymax-2);
	_lineto(x+2,ymax-2);
	_lineto(x+2,y+2);
	return(1);
	}

optmenu()
	{
	char ch='r';
	char string[81];
	int brkflag=0;
        int x,ref,y,n;
	int flag;
	int genenum;
	int loops;
	int firstime,contflag;
        float sum;
	clrscr();
	printf("\n");
	printf("                         OPTIMIZATION MENU\n\n\n");
//	printf("                      <E>volve best map parameters\n");
//	printf("                      <F>itness type reset\n");
//	printf("                      <B>uild map manually\n");
//	printf("                      <A>djust mutation rate\n");
//	printf("                      <C>alculate .prd stream\n");
//	printf("                      <D>ays for graph performance bands\n");
//	printf("                      <I>nput population file: *.pop\n");
//	printf("                      <O>utput populataion file: *.pop\n");
//	printf("                      <Z> write realized and unrealized equity stream\n");
	printf("                      <R>ead map\n");
        printf("                      <M>ap write\n");
	printf("                      <W>rite .prd stream\n");
	printf("                      <H>idden data view toggle\n");
	printf("                      <P>lot map\n");
	printf("                      <L>ist evolution parameters\n");
	printf("                      <V>iew trade and .prd details\n");
	printf("                      <S>et scale for viewing return stream\n");
	printf("                      <D>isplay return stream with Buy&Hold stream\n");
	printf("                     <X> Return to Simulation menu\n");
	printf("                            Enter ONE option: ");
	gets(string);
	switch(string[0])
		{
		case'x':
		case'X':
				for(;;)
				  simmenu();
				break;
		case's':
		case'S':
				clrscr();
				printf("\n\n\n\n\n\tEnter graphics scale for return stream plot: ");
				gets(string);
				grss=atof(string);
				break;
		case'o':
		case'O':
				write_pop();
				break;
		case'z':
		case'Z':
				write_randu();
				break;
		case'f':
		case'F':
				clrscr();
				printf("\tEnter code for fitness type:\n");
				printf("\t1 = Sterling (ie, returns / max drawdown).\n");
				printf("\t2 = Wendling/Hoppe (ie, returns / rms drawdowns).\n");
				printf("\t3 = Returns/variance.\n");
				printf("           Choice:  ");
				gets(string);
				fittype=atoi(string);
				break;

		case'a':
		case'A':
				clrscr();
				printf("   Enter mutation rate (1 in 1000 as .001, etc.; 1.0=default): ");
				gets(string);
				mutrate=atof(string);
				break;
		case'l':
		case'L':
				clrscr();
				printf("      EVOLUTION CONTROL PARAMETERS\n");
				printf("Trader type: 1=long 2=short 3=both: %d\n",tradertype);
				printf("Test data (days): %d\n",virg);
				printf("Evolution optimization days: %d\n",evoptdays);
				printf("Random number generator seed: %d\n",seed);
				printf("Maximum map building passes: %d\n",gcmaxpass);
				printf("Maximum days to hold a long position open: %d\n",gcmaxhold);
				printf("Maximum days to hold a short position open: %d\n",gcsmaxhold);
				printf("Maximum forecast (.prd) scale factor: %f\n",gcfsf);
				printf("Maximum stop threshold (pts): %f\n",gcstopthresh);
				printf("Minimum stop threshold (pts): %f\n",minstopthresh);
				printf("Maximum reenter threshold (pts): %f\n",gcrthresh);
				printf("Maximum lots per trade: %d\n",gclotspertrade);
				printf("Maximum lots allowed open: %d\n",gcmaxlots);
				printf("Maximum reentries allowed from stopped position: %d\n",gcmaxreentry-1);
                                printf("purity thresh %f\n",puritythresh);
				printf("offset 2 = %d\n",f2);
				printf("offset 3 = %d\n",f3);
				printf("offset 4 = %d\n",f4);
				printf("future look = %d\n",flook);
				printf("Maximum map price scale: %d\n",gcmapscale);
				printf("Fitness type: 1=Sterling,2=W/H,3=Ret/Variance,4=returns:     %d\n",fittype);
				printf("Target type: 1=nth day, 2=minmax              %d\n",targtype);
				printf("Minimum lots traded before penalty applied to fitness: %f\n",mltq);
                                printf("Forecasted price: %s\n  ",istream1);
                                printf("<A> price stream: %s\n  ",istream2);
				printf("<B> price stream: %s\n  ",istream3);
				printf("<C> price stream: %s\n  ",istream4);
				printf("<D> price stream: %s\n  ",istream5);
				printf("<E> price stream: %s\n  ",istream6);
				printf("<F> price stream: %s\n  ",istream7);
				printf("<G> price stream: %s\n  ",istream8);
				printf("<H> price stream: %s\n  ",istream9);
				printf("<ENTER> returns...");
				gets(string);
				break;
		
		case'i':
		case'I':
				clrscr();
				printf("System will build map, update .prd, & load trade parameters\n");
				printf("for citizen selected.\n");
				printf("You can then run the simulator for detailed results and tweeking.\n");
                                printf("Enter SS number of citizen to instantiate(0-499): ");
				gets(string);
				competitor_ss=atoi(string);
				input_pop();
				printf("\nPlease wait, building map & .prd....\n\n");
				printf("\n");
				init_map();
				calc_params_competitor();
				build_map();
                                fix_maps();
				for(ref=250;ref<=nod;ref++)
					c_perfn(ref);
				normalize();
				break;
		case'm':
		case'M':
				write_map();
				break;
		case'd':
		case'D':
				_setvideomode(_VRES16COLOR);
				mk_box();
				draw_grid();
				plot_buyandhold();
                                plot_account();
                           //     p_thrutime();
                           //     p_ooscorr();
                           //     draw_oosgrid();
				gets(string);
                                _setvideomode(_DEFAULTMODE);
				break;
		case'r':
		case'R':
				read_map();
				simmenu();
				break;
		case'w':
		case'W':
				wrtpred();
				break;
		case'c':
		case'C':
				for(ref=250;ref<=nod;ref++)
					c_perfn(ref);
				normalize();
				break;
		
		case'h':
		case'H':
				hidetoggle*=-1;
				break;
		case'v':
		case'V':
				_setvideomode(_VRES16COLOR);
				mk_box();
				draw_grid();
				p_s();
				p_pred();
				p_actual();
				draw_cursline();
                           //     p_thrutime();
                           //     p_ooscorr();
                           //     draw_oosgrid();
				xr.w.ax=0;
				int386(0x33,&xr,&xr);  /* init mouse */
				for(;;)
					{
					xr.w.ax=1;
					int386(0x33,&xr,&xr);  /* show cursor */
					xr.w.ax=3;
					int386(0x33,&xr,&xr);  /* gets button status */
					if(xr.w.bx == 1)   /* left button hit */
						{
						xcurs=xr.w.cx;
						ycurs=xr.w.dx;
						if(ycurs > 35 && ycurs < 70 && xcurs > 550) /* list */
							{
                            _setvideomode(_DEFAULTMODE);
							clrscr();
							for(x=20;x>=0;x--)
								{
								printf("Close = %5.2f    Forecast = %2.3f%%  Target=%5.2f  %d days ago\n"\
					,c[nod-x-hs],pred[nod-x-hs],c[nod-x-hs]*(1.0+(pred[nod-x-hs]/100.0)),x+hs);
								}
							printf("Last price shown is furthest right on graphics screen.\n");
							printf("Hit mouse button to return.\n");
							for(;;)
								{
								int386(0x33,&xr,&xr);
								if(xr.w.bx == 1)   /* button hit */
									{
									ycurs=50;
									xcurs=400;
									_setvideomode(_VRES16COLOR);
									_clearscreen(_GCLEARSCREEN);
									break;
									}
								if(kbhit())
									break;
								}
							}
						if(ycurs >70 && ycurs < 100 && xcurs > 500) /* map */
							{
							_clearscreen(_GCLEARSCREEN);
							mk_box();
							draw_it();
							_settextposition(2,2);
							_outtext("Click mouse to return..");
							for(;;)
								{
								int386(0x33,&xr,&xr);
								if(xr.w.bx == 1)   /* button hit */
									{
									ycurs=50;
									xcurs=400;
									_clearscreen(_GCLEARSCREEN);
									break;
									}
								if(kbhit())
									break;
								}
							}
						if(ycurs > 40 && ycurs < 60 && xcurs < 550) /* pan */
							{
							_clearscreen(_GCLEARSCREEN);
							hs-=xcurs-400;
							if(hs < 0)
								{
								hs=0;
								}
							if(hs > nod-310)
								{
								hs=nod-310;
								}
							mk_box();
							draw_grid();
							p_s();
							p_pred();
							p_actual();
							draw_cursline();
							}
						if(xcurs >550 && ycurs <35)  /* curs menu */
							break;
						}
					if(kbhit())  /* keypad menu */
						{
						ch=getchar();
						break;
						}
					}
				_setvideomode(_DEFAULTMODE);
				break;
	
		case'p':
		case'P':
				clrscr();
				printf("Enter height scale(for viewing AND subsequent calc's): ");
				gets(string);
				htscale=atof(string);
				count_weights();

				_setvideomode(_VRES16COLOR);
				mk_box();
				draw_it();
				
				for(;;)
					{
					if(kbhit())
						{
						ch=getch();
						break;
						}
					}
                _setvideomode(_DEFAULTMODE);
				break;
		}
	return(1);
	}


c_prdcontained()
    {
    int ref,x;
    float max,min,upper,lower;
    float inside=0.0;
    float count=0.0;
    for(ref=250;ref<(nod-((virg+foldshift)+hide));ref++)
        {
        count=count+1.0;
        max=0.0;
        min=100000.0;
        for(x=1;x<30;x++)
            {
            if(c[ref+x] > max)
                max=c[ref+x];
            if(c[ref+x] < min)
                min=c[ref+x];
            }
         upper=(max/c[ref]-1.0)*100.0;
         lower=(min/c[ref]-1.0)*100.0;
         if(pred[ref] <= upper && pred[ref] >= lower)
            inside=inside+1.0;
         }
    proportion_contained=inside/count;
    return(1);
    }







draw_cursline()
	{
	color=12;
	_setcolor(color);
	_moveto(353,53);
	_lineto(447,47);
	_moveto(353,47);
	_lineto(447,53);
	_moveto(400,45);
	_lineto(400,55);
	_moveto(350,50);
	_lineto(355,55);
	_moveto(350,50);
	_lineto(355,45);
	_moveto(450,50);
	_lineto(445,55);
	_moveto(450,50);
	_lineto(445,45);
	return(1);
	}

init_avelyeq()
	{
	int x;
	for(x=0;x<1500;x++)
		{
		avelyeq[x]=0.0;
		favelyeq[x]=0.0;
		}
	return(1);
	}



init_avegenfit()
	{
	int x;
	for(x=0;x<500;x++)
		avegenfit[x]=0.0;
	return(1);
	}





update()
	{
	int ref;
	decode_bestoos();
	init_map();
        for(fold=1;fold<=10;fold++)
		{
		init_map();
                foldwidth=learn/9;
		foldshift=foldwidth*(fold-1);
	//	if(foldshift > (learn-250))
	//		foldshift=learn-250;
		build_map();
                fix_maps();
		for(ref=250;ref<=nod;ref++)
			 c_perfn(ref);
		normalize();
		}
	return(1);
	}

simmenu()
	{
	int x;
	char ch;
	char string[81];
	clrscr();
	printf("                             SIMULATION MENU\n\n");
	printf("                       <N> Optimization Menu\n");
	printf("                       <B> Set buy (open long) threshold\n");
	printf("                       <M> Set maximum holding period\n");
 	printf("                       <S> Set sell (open short) threshold\n");
 	printf("                       <W> Set .prd scale for target prices\n");
 //	printf("                       <C> Set maximum lots allowed open\n");
 //	printf("                       <G> Set lots per trade\n");
 	printf("                       <K> Set slippage\n");
 	printf("                       <Y> Set Trader type (long/short/both)\n"); 
 //	printf("                       <A> Set simulation start 'date'\n");
 //	printf("                       <Z> Set simulation stop 'date'\n");
	printf("                       <L> List parameter settings\n");
	printf("                       <R> Run Simulation\n");
	printf("                       <H> ide toggle ability to see hidden data\n");
	printf("                       <V> View price stream, forecast, & trade markers\n");
	printf("                       <D> Draw Account balance change distribution\n");
	printf("                       <F> Draw trade results distribution\n");
	printf("                       <J> Jump to day in past for view\n");
	printf("                       <E> Enable Audit trail to disk\n");
	printf("                       <O> Output Mkt. pts. won/lost stream to file\n");
	printf("                       <8> Set entry type flag (close or next days open)\n");
 //	printf("                      <X> Return to Main menu\n");
	printf("                           Enter one option: ");
	gets(string);
	switch(string[0])
		{
		case'n':
		case'N':
				for(;;)
					optmenu();
				break;
      case'8':
				clrscr();
				printf("Enter 1 to enter trade on closing price associated with .prd\n");
				printf(" or enter 0 to enter trade on the next day's opening price: ");
				gets(string);
				entrytypeflag=atoi(string);
				break;
		case'p':
		case'P':
				clrscr();
				printf("Enter maximum number of re-entries allowed: ");
				gets(string);
				maxreentry=atoi(string);
				break;
		case'1':
				clrscr();
				printf("When dynamic targets is turned on, all open long positions\n");
				printf("will be terminated at the close if either primary or secondary\n");
				printf(".prd's turn negative. Likewise, any open shorts will be offset\n");
				printf("if either .prd flips to positive.\n");
				printf("With dynamic targets off, positions must hit original targets,\n");
				printf("time-out, or hit a protective stop to be terminated.\n");
				printf("Enter '1' to turn dynamic targets on, '0' for off: ");
				gets(string);
				dynamicflag=atoi(string);
				break;
		case'y':
		case'Y':
				clrscr();
				printf("Enter trader type (1 for long, 2 for short, 3 for both): ");
				gets(string);
				tradertype=atoi(string);
				break;
		case'B':
		case'b':
				clrscr();
				printf("Enter 'open primary long position' threshold (percent):  \n");
				gets(string);
				longthresh=atof(string)/100.0;
		//		printf("Enter 'open secondary long position' threshold (percent):  \n");
		//		gets(string);
		//		longthresh2=atof(string)/100.0;
				break;
		case'H':
		case'h':
				hidetoggle*=-1;
				break;




		 
		case'i':
		case'I':
				clrscr();
				printf("Enter 're-entrant' threshold.\n");
				printf("Note: use points away from stopped price: ");
				gets(string);
				rthresh=atof(string);
				break;
		case'K':
		case'k':
				clrscr();
				printf("Enter slippage (market points) per round turn.\n");
				gets(string);
				slippage=atof(string);
				break;
		case'e':
		case'E':
				clrscr();
				eq=0;
				printf("Enter 0=no detail, 1=detail to file:'audit.trl'.\n");
				printf("2= output equity stream to file.\n");
				gets(string);
				d=atoi(string);
				if(d == 2)
					{
					d=0;
					eq=1;
					}
				break;
		case'f':
		case'F':
				drawtradedist();
				break;
		case't':
		case'T':
				clrscr();
				printf("Enter 0 for static stops, 1 for 'trailing' stops: ");
				gets(string);
				trailing=atoi(string);
				break;
		case'q':
		case'Q':
				clrscr();
				printf("Enter 0 to allow Spread positions, 1 to prevent: ");
				gets(string);
				nospreadflag=atoi(string);
				break;
		case'w':
		case'W':
				clrscr();
				printf("Enter scale factor on forecast for target calculation.\n");
				printf("Terminates position at target price. ");
				gets(string);
				fsf=atof(string);
				break;
		case'c':
		case'C':
				clrscr();
				printf("Enter most lots allowed open at any time(150 max): ");
				gets(string);
				maxlots=atoi(string);
				break;
		case'm':
		case'M':
				clrscr();
				printf("Enter maximum days to hold long position before closing trade: ");
				gets(string);
				gcmaxhold=atoi(string);
				maxhold=gcmaxhold;
				printf("Enter maximum days to hold short position before closing trade: ");
				gets(string);
				gcsmaxhold=atoi(string);
				smaxhold=gcsmaxhold;
				break;
		case's':
		case'S':
				clrscr();
				printf("Enter 'open primary short position' threshold (percent): \n");
				gets(string);
				shortthresh=atof(string)/100.0;
		//		printf("Enter 'open secondary short position' threshold (percent): \n");
		//		gets(string);
		//		shortthresh2=atof(string)/100.0;
				break;
		case'g':
		case'G':
				clrscr();
				printf("Enter lots per trade.\n");
				printf("Not to exceed %d maximum lots allowed.\n",maxlots);
				printf("Remainder lots will be put on if not evenly divisible.\n");
				printf("                        : ");
				gets(string);
				lotspertrade=atoi(string);
				break;
		case'a':
		case'A':
				clrscr();
				printf("Number of days in file = %d.\n",nod);
				printf("Enter simulation start ref day#: ");
				gets(string);
				simstart=atoi(string);
				break;
		case'z':
		case'Z':
				clrscr();
				printf("Number of days in file = %d.\n",nod);
				printf("Enter simulation stop ref day#: ");
				gets(string);
				simstop=atoi(string);
				break;
		case'l':
		case'L':
				clrscr();
				printf("\n\n\n\n\n\n\n\n");
				printf("Primary Long threshold percent ........... %f\n",longthresh*100.0);
				printf("Secondary Long threshold percent ......... %f\n",longthresh2*100.0);
				printf("Primary Short threshold percent........... %f\n",shortthresh*100.0);
				printf("Secondary Short threshold percent......... %f\n",shortthresh2*100.0);
				printf("Max Holding days (long)................... %d\n",maxhold);
				printf("Max Holding days (short).................. %d\n",smaxhold);
				printf("Future look days.......................... %d\n",flook);
				printf("Lots per trade............................ %d\n",lotspertrade);
                                printf("Puritythresh.............................. %f\n",puritythresh);
				printf("Maximum lots allowed ..................... %d\n",maxlots);
				printf("Slippage per round-turn (market points)... %f\n",slippage);
				printf("Forecast to target scale factor .......... %f\n",fsf);
				printf("Simulation start (ref day#) .............. %d\n",simstart);
				printf("Simulation stop  (ref day#) .............. %d\n",simstop);
                                printf("Spreads;  0=allowed, 1=prevent............ %d\n",nospreadflag);
				printf("Trader type (1=long,2=short,3=both)....... %d\n",tradertype);
				printf("Target type: 1=nth day, 2=minmax.......... %d\n",targtype);
                                printf("Entry type flag: 1=close, 0=open.......... %d\n",entrytypeflag);
                                printf("Fitness type(1=Sterling, 2=W/H, 3=R/V).... %d\n\n",fittype);
				printf("       <Enter> returns...");
				gets(string);
				if(cbmf) run_batch();
				break;
		case'r':
		case'R':
				oflag=0;
				grtoggle=1;
                initflag=0;
				clrscr();
				simstrat();
				if(cbmf) run_batch();
				break;
		case'v':
		case'V':
				_setvideomode(_VRES16COLOR);
				mk_box();
				draw_grid();
				p_s();
				p_pred();
				p_actual();
				draw_cursline();
				xr.w.ax=0;
				int386(0x33,&xr,&xr);  /* init mouse */
				for(;;)
					{
					xr.w.ax=1;
					int386(0x33,&xr,&xr);  /* show cursor */
					xr.w.ax=3;
					int386(0x33,&xr,&xr);  /* gets button status */
					if(xr.w.bx == 1)   /* left button hit */
						{
						xcurs=xr.w.cx;
						ycurs=xr.w.dx;
						if(ycurs > 35 && ycurs < 70 && xcurs > 550) /* list */
							{
                            _setvideomode(_DEFAULTMODE);
							clrscr();
							for(x=20;x>=0;x--)
								{
								printf("Close = %5.2f    Forecast = %2.3f%%  Target=%5.2f  %d days ago\n"\
					,c[nod-x-hs],pred[nod-x-hs],c[nod-x-hs]*(1.0+(pred[nod-x-hs]/100.0)),x+hs);
								}
							printf("Last price shown is furthest right on graphics screen.\n");
							printf("Hit mouse button to return.\n");
							for(;;)
								{
								int386(0x33,&xr,&xr);
								if(xr.w.bx == 1)   /* button hit */
									{
									ycurs=50;
									xcurs=400;
									_setvideomode(_VRES16COLOR);
									_clearscreen(_GCLEARSCREEN);
									break;
									}
								if(kbhit())
									break;
								}
							}
						if(ycurs >70 && ycurs < 100 && xcurs > 500) /* map */
							{
							_clearscreen(_GCLEARSCREEN);
							mk_box();
							draw_it();
							_settextposition(2,2);
							_outtext("Click mouse to return..");
							for(;;)
								{
								int386(0x33,&xr,&xr);
								if(xr.w.bx == 1)   /* button hit */
									{
									ycurs=50;
									xcurs=400;
									_clearscreen(_GCLEARSCREEN);
									break;
									}
								if(kbhit())
									break;
								}
							}
						if(ycurs > 40 && ycurs < 60 && xcurs < 550) /* pan */
							{
							_clearscreen(_GCLEARSCREEN);
							hs-=xcurs-400;
							if(hs < 0)
								{
								hs=0;
								}
							if(hs > nod-310)
								{
								hs=nod-310;
								}
							mk_box();
							draw_grid();
							p_s();
							p_pred();
							p_actual();
                                                  //      p_ooscorr();
							draw_cursline();
							}
						if(xcurs >550 && ycurs <35)  /* curs menu */
							break;
						}
					if(kbhit())  /* keypad menu */
						{
						ch=getchar();
						break;
						}
					}
				_setvideomode(_DEFAULTMODE);
            if(cbmf) run_batch();
				break;
		case'd':
		case'D':
				drawdist();
				if(cbmf) run_batch();
				break;
		case'j':
		case'J':
					clrscr();
					printf("\n\n\nEnter # of days to jump back in time for <V>iew: ");
					gets(string);
					hs=atoi(string);
               if(cbmf) run_batch();
					break;
		case'o':
		case'O':
					wrtmktpts();
					if(cbmf) run_batch();
					break;
		case'x':
		case'X':
				for(;;)
					menu();
		}
	return(1);
	}


simstrat()
	{
	char string[30];
	long ref,x,k;
        float i1,i2;
	int z;
	int longcount,shortcount,ans;
        int genenum;
	kount=0;   // total lots traded over simulation
	numlotsactive=0;  // number of open positions at any time
	numhittarget=0;
	numexpprofit=0;
	numexploss=0;
	numstopsexp=0;
	numstopped=0;
	numreentered=0;
	numlotsnostop=0;
	cab=0.0;   // cash account balance
	sumdaysold=0.0;
	mcount=0;   // month count
	summonthlygain=0.0;
	sumdiffsqrd=0.0;
	lotcount=0;
	if(datatype == 0)
		{
		printf("Can't run simulator on close only data.\n");
		printf("You must use O,H,L,C format, or .prn files.\n");
		//delay(2000);
		return(1);
		}
        if(dumptoggle)   // if dumptoggle == 1 or 2, open files pointer
		{
		du=fopen(istream11,"w");
		}
   if(grtoggle ==1 )
        {
        _setvideomode(_VRES16COLOR);
        mk_box();
        draw_cgrid();
        }
	if(eq)
		{
		system("dir *.equ");
		printf("Enter file name for equity stream: ");
		gets(string);
		equ=fopen(string,"w");
		}
	if(d)
		{
		pr=fopen("audit.trl","w");
		fprintf(pr,"Primary Long threshold percent ........... %f\n",longthresh*100.0);
		fprintf(pr,"Secondary Long threshold percent.......... %f\n",longthresh2*100.0);
		fprintf(pr,"Primary Short threshold percent........... %f\n",shortthresh*100.0);
		fprintf(pr,"Secondary Short threshold percent......... %f\n",shortthresh2*100.0);
		fprintf(pr,"Max Holding days (long)................... %d\n",maxhold);
		fprintf(pr,"Max Holding days (short).................. %d\n",smaxhold);
		fprintf(pr,"Lots per trade............................ %d\n",lotspertrade);
		fprintf(pr,"Maximum lots allowed ..................... %d\n",maxlots);
		fprintf(pr,"Stop threshold points..................... %f\n",stopthresh);
		fprintf(pr,"Re-enter threshold points................. %f\n",rthresh);
		fprintf(pr,"Slippage per round-turn (market points)... %f\n",slippage);
		fprintf(pr,"Forecast to target scale factor .......... %f\n",fsf);
		fprintf(pr,"Simulation start (ref day#) .............. %d\n",simstart);
		fprintf(pr,"Simulation stop  (ref day#) .............. %d\n",simstop);
		fprintf(pr,"Trailing stop toggle 1=on, 0=off.......... %d\n",trailing);
		fprintf(pr,"Spreads;  0=allowed, 1=prevent............ %d\n",nospreadflag);
		fprintf(pr,"Dynamic target flag = %d\n",dynamicflag);
		fprintf(pr,"Trader type;1=long,2=short,3=both......... %d\n",tradertype);
		}
	for(lotnum=0;lotnum<=maxlots;lotnum++)
		{
		lotstatus[lotnum]=0;  //initialize to available
		lotentryprice[lotnum]=0.0;
		lottarget[lotnum]=0.0;
		lotrcount[lotnum]=0;
		}
	for(ref=0;ref<=nod;ref++)
		{
		openmarker[ref]=0;
		closemarker[ref]=0;
		stopmarker[ref]=0;
		reentermarker[ref]=0;
		}
	for(ref=0;ref<MAXLINES;ref++)
		{
		account[ref]=0.0;
		randu[ref]=0.0;
		marketpts[ref]=0.0;
		}
	account[simstart-1]=cab;
	oldaccount=cab;
	longcount=0;
	shortcount=0;
	for(ref=simstart;ref<=simstop;ref++)
		{
		if(kbhit())
			{
			d=0;
			eq=0;
			}
		if(d)
			fprintf(pr,"************** ref=%d closing price = %5.2f\n",ref,c[ref]);
		account[ref]=account[ref-1];//carryover yesterdays account balance
		if((ref)%20 == 0) // every 20th day
			{
			++mcount;
			monthlygain[mcount]=account[ref]-oldaccount;
			oldaccount=account[ref];
			}
      /*  i2=0.0;
        for(z=0;z<f3;z++)
            {
            i2+=pred2[ref-z];
            }
        i2=i2/(float)f3;
        i1=0.0;
        for(z=0;z<f3;z++)
            {
            i1+=pred[ref-z];
            }
		  i1=i1/(float)f3; */
                i1=pred[ref];  
		i2=pred2[ref];

		// check  if any lots should be re-entered,stopped,hit target,or timed out.
		for(lotnum=0;lotnum<maxlots;lotnum++)
			{
			if( lotstatus[lotnum] == 2 && c[ref] >= lotexitprice[lotnum]+rthresh && lotrcount[lotnum] < maxreentry )
				{    // re-enter stopped-out long lot
				lotrcount[lotnum] +=1;
				lotstatus[lotnum] = 1;
				lotentryprice[lotnum]=lotentryprice[lotnum]+rthresh;
				maxcloseprice[lotnum]=lotentryprice[lotnum];
				++kount;
				reentermarker[ref]+=1;
				++numreentered;
				if(d)fprintf(pr,"reentered long lotnum%d @ %5.2f\n",lotnum+1,lotentryprice[lotnum]);
				}
			if( lotstatus[lotnum] == 3 && c[ref] <= lotexitprice[lotnum]-rthresh && lotrcount[lotnum] < maxreentry )
				{    // re-enter stopped-out short lot
				lotrcount[lotnum] +=1;
				lotstatus[lotnum] = 1;
				lotentryprice[lotnum]=lotexitprice[lotnum]-rthresh;
				mincloseprice[lotnum]=lotentryprice[lotnum];
				++kount;
				reentermarker[ref]+=1;
				++numreentered;
				if(d)fprintf(pr,"reentered short lotnum%d @ %5.2f\n",lotnum+1,lotentryprice[lotnum]);
				}
			if( lotstatus[lotnum] == 1)  //active trade
				{
				if(tradetype[lotnum] == 1||tradetype[lotnum] == 2)  // long
					{
					if(trailing == 0)
						maxcloseprice[lotnum]=lotentryprice[lotnum];
					if(l[ref] < maxcloseprice[lotnum]-stopthresh)
						{
						lotstatus[lotnum]=2;  // stopped out long
						lotexitprice[lotnum]=maxcloseprice[lotnum]-(stopthresh+slippage);
						chg=lotexitprice[lotnum]-lotentryprice[lotnum];
						lotcount=lotcount+1;
						lotresult[lotcount]=chg;
						account[ref]+=chg;
						marketpts[ref]+=chg;
						stopmarker[ref]+=1;
						++numstopped;
                                           //     p_corr(lotopenref[lotnum],chg,tradetype[lotnum]);
						if(d)fprintf(pr,"stopped out long lotnum%d @ %5.2f\n",lotnum+1,lotexitprice[lotnum]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}
					if( c[ref] >= lottarget[lotnum])
						{
						lotstatus[lotnum]=0; // hit target long
						lotrcount[lotnum]=0; // reset reentry count
						account[ref]+=c[ref]-(lotentryprice[lotnum]+slippage);
						lotcount=lotcount+1;
						lotresult[lotcount]=c[ref]-(lotentryprice[lotnum]+slippage);
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						numlotsactive-=1;
						closemarker[ref]+=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						++numhittarget;
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                          //      p_corr(lotopenref[lotnum],chg,tradetype[lotnum]);
						if(d)fprintf(pr,"hit target long lotnum%d @ %5.2f\n",lotnum+1,lottarget[lotnum]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}

				  if( dynamicflag == 1 && (i2 < 0.0 || i1 < 0.0) && lotstatus[lotnum] != 0) // .prd flipped-dynamic
						{
						lotstatus[lotnum]=0; //  either .prd went negative on long position
						lotrcount[lotnum]=0; // reset reentry count
						account[ref]+=c[ref]-lotentryprice[lotnum];
						lotcount=lotcount+1;
						lotresult[lotcount]=c[ref]-lotentryprice[lotnum];
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						numlotsactive-=1;
						closemarker[ref]+=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						++numhittarget;
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                           //     p_corr(lotopenref[lotnum],chg,tradetype[lotnum]);
						if(d)fprintf(pr,".prd flipped/dynamic lotnum%d @ %5.2f\n",lotnum+1,c[ref]);
						if(d)fprintf(pr,"account=%9.2fpoints\n",account[ref]);
						}
					if( lotopenref[lotnum] == (ref)-maxhold && lotstatus[lotnum] == 1) //time expired
						{
						lotstatus[lotnum]=0; // get-out of long -timed out
						lotrcount[lotnum]=0;  // reset reentry count
						account[ref]+=c[ref]-(lotentryprice[lotnum]+slippage);
						lotcount=lotcount+1;
						lotresult[lotcount]=c[ref]-(lotentryprice[lotnum]+slippage);
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						if(lotresult[lotcount] > 0.0)
							++numexpprofit;
						else
							++numexploss;
						numlotsactive-=1;
						closemarker[ref]+=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                           //     p_corr(lotopenref[lotnum],chg,tradetype[lotnum]);
						if(d)fprintf(pr,"timed out long lotnum%d @ %5.2f\n",lotnum+1,c[ref]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}
					}
				if( tradetype[lotnum] ==-1||tradetype[lotnum]==-2) //short
					{
					if(trailing == 0)
						mincloseprice[lotnum]=lotentryprice[lotnum];
					if( h[ref] > mincloseprice[lotnum]+stopthresh) //stopped out short
						{
						lotstatus[lotnum]=3;  // stopped out short
						lotexitprice[lotnum]=mincloseprice[lotnum]+stopthresh+slippage;
						chg=lotentryprice[lotnum]-lotexitprice[lotnum];
						lotcount=lotcount+1;
						lotresult[lotcount]=chg;
						account[ref]+=chg;
						marketpts[ref]+=chg;
						stopmarker[ref]+=1;
						++numstopped;
                                           //     p_corr(lotopenref[lotnum],-chg,tradetype[lotnum]);
						if(d)fprintf(pr,"stopped out short lotnum%d @ %5.2f\n",lotnum+1,lotexitprice[lotnum]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}
					if( c[ref] <= lottarget[lotnum])
						{
						lotstatus[lotnum]=0;  // hit target short
						lotrcount[lotnum]=0;  // reset reentry count
						account[ref]+=lotentryprice[lotnum]-(c[ref]+slippage);
						lotcount+=1;
						lotresult[lotcount]=lotentryprice[lotnum]-(c[ref]+slippage);
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						numlotsactive-=1;
						closemarker[ref]-=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						++numhittarget;
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                          //      p_corr(lotopenref[lotnum],-chg,tradetype[lotnum]);
						if(d)fprintf(pr,"hit target short lotnum%d @ %5.2f\n",lotnum+1,lottarget[lotnum]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}
				  if( dynamicflag == 1 && (i2 > 0.0 || i1 > 0.0) && lotstatus[lotnum] != 0) // .prd flipped-dynamic
						{
						lotstatus[lotnum]=0;  // either .prd went positive on open short position
						lotrcount[lotnum]=0;  // reset reentry count
						account[ref]+=lotentryprice[lotnum]-c[ref];
						lotcount+=1;
						lotresult[lotcount]=lotentryprice[lotnum]-c[ref];
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						numlotsactive-=1;
						closemarker[ref]-=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						++numhittarget;
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                          //      p_corr(lotopenref[lotnum],-chg,tradetype[lotnum]);
						if(d)fprintf(pr,".prd flipped/dynamic lotnum%d @ %5.2f\n",lotnum+1,c[ref]);
						if(d)fprintf(pr,"account=%9.2fpoints\n",account[ref]);
						}
					if( lotopenref[lotnum] == (ref)-smaxhold && lotstatus[lotnum] == 1) //time expired
						{
						lotstatus[lotnum]=0;  // close short, time expired
						lotrcount[lotnum]=0;  //reset reentry count
						account[ref]+=lotentryprice[lotnum]-(c[ref]+slippage);
						lotcount+=1;
						lotresult[lotcount]=lotentryprice[lotnum]-(c[ref]+slippage);
						chg=lotresult[lotcount];
						marketpts[ref]+=chg;
						if(lotresult[lotcount] > 0.0)
							++numexpprofit;
						else
							++numexploss;
						numlotsactive-=1;
						closemarker[ref]-=1;
						sumdaysold+=((ref)-lotopenref[lotnum]);
						if(c[lotopenref[lotnum]] == lotentryprice[lotnum])
							++numlotsnostop;
                                          //      p_corr(lotopenref[lotnum],-chg,tradetype[lotnum]);
						if(d)fprintf(pr,"short timed out lotnum%d @ %5.2f\n",lotnum+1,c[ref]);
						if(d)fprintf(pr,"account=%9.2f\n",account[ref]);
						}
					}
				}
			if(lotstatus[lotnum] == 2 )
				{
				if( lotopenref[lotnum] == (ref)-maxhold) //time expired on stopped lot
					{
					lotstatus[lotnum]=0;
					lotrcount[lotnum]=0; // reset reentry count
					++numstopsexp;
					numlotsactive-=1;
					if(d)fprintf(pr,"time expired on stopped lotnum%d\n",lotnum+1);
					}
				}
			if(lotstatus[lotnum] == 3 )
				{
				if( lotopenref[lotnum] == (ref)-smaxhold) //time expired on stopped lot
					{
					lotstatus[lotnum]=0;
					lotrcount[lotnum]=0; // reset reentry count
					++numstopsexp;
					numlotsactive-=1;
					if(d)fprintf(pr,"time expired on stopped lotnum%d\n",lotnum+1);
					}
				}
			if(trailing && lotstatus[lotnum])
				{
				if(tradetype[lotnum] ==1||tradetype[lotnum]==2)   //long
					if(ref != nod && c[ref] > maxcloseprice[lotnum] && lotstatus[lotnum] != 2)
						{
						maxcloseprice[lotnum]=c[ref];
						if(d)fprintf(pr,"raised stop on lotnum%d to %6.2f\n",lotnum+1,maxcloseprice[lotnum]-stopthresh);
						}
				}
			if(trailing && lotstatus[lotnum])
				{
				if(tradetype[lotnum] ==-1||tradetype[lotnum]==-2)   //short
					{
					if(ref != nod && c[ref] < mincloseprice[lotnum] && lotstatus[lotnum] != 3)
						{
						mincloseprice[lotnum]=c[ref];
						if(d)fprintf(pr,"lowered stop on lotnum%d to %6.2f\n",lotnum+1,mincloseprice[lotnum]+stopthresh);
						}
					}
				}
			}
		longflag=0;
		shortflag=0;
		for(lotnum=0;lotnum<maxlots;lotnum++)
			{
			if(lotstatus[lotnum] == 1)  // ie open
				{
				if(tradetype[lotnum] == 1||tradetype[lotnum]==2)  // ie long
					longflag=1;
				if(tradetype[lotnum] == -1||tradetype[lotnum]==-2)  // ie short
					shortflag=1;
				}
			}
		openlotvalue=0.0;    //initialize open position points change
		for(lotnum=0;lotnum<maxlots;lotnum++)
			{
			if(ref != nod && lotstatus[lotnum] == 1)  // ie open
				{
				if(tradetype[lotnum] == 1||tradetype[lotnum] == 2)  // ie long
					openlotvalue+=c[ref]-lotentryprice[lotnum];
				if(tradetype[lotnum] == -1||tradetype == -2)  // ie short
					openlotvalue+=lotentryprice[lotnum]-c[ref];
				}
			}
        if((i1/100.0) >= longthresh  && tradertype != 2 )  // long signal 
			{
			if(numlotsactive < maxlots )  // lot available?
				{
				for(k=1;k<=lotspertrade;k++)
					{
					if(numlotsactive >= maxlots)
						break;
					if(shortflag && nospreadflag)
						break;
					for(lotnum=0;lotnum<maxlots;lotnum++) // find avail lot ref#
						{
						if(lotstatus[lotnum] == 0)  // ie available
						break;
						}
					kount=kount+1;
					openmarker[ref]+=1;
					lottarget[lotnum]=c[ref]*(1.0+((i1/100.0)*fsf));
					if(entrytypeflag == 1)
						lotentryprice[lotnum]=c[ref];
					else
						lotentryprice[lotnum]=o[ref+1];
					maxcloseprice[lotnum]=c[ref];
					tradetype[lotnum]=1; //long 
					lotstatus[lotnum]=1; //mark this lot as open , ie used
					lotopenref[lotnum]=ref;
					numlotsactive=numlotsactive+1;
					if(d)fprintf(pr,"bought long, lotnum%d @ %5.2f pred=%5.2f\n",lotnum+1,c[ref],pred[ref]);
					}
				}
			}
        if((i1/100.0) < longthresh && i2/100.0 >=longthresh2 && tradertype != 2 )  // long signal,secondary .prd 
			{
			if(numlotsactive < maxlots )  // lot available?
				{
				for(k=1;k<=lotspertrade;k++)
					{
					if(numlotsactive >= maxlots)
						break;
					if(shortflag && nospreadflag)
						break;
					for(lotnum=0;lotnum<maxlots;lotnum++) // find avail lot ref#
						{
						if(lotstatus[lotnum] == 0)  // ie available
						break;
						}
					kount=kount+1;
					openmarker[ref]+=1;
					lottarget[lotnum]=c[ref]*(1.0+((i2/100.0)*fsf));
					if(entrytypeflag == 1)
						lotentryprice[lotnum]=c[ref];
					else
						lotentryprice[lotnum]=o[ref+1];
					maxcloseprice[lotnum]=c[ref];
					tradetype[lotnum]=2; //secondary long 
					lotstatus[lotnum]=1; //mark this lot as open , ie used
					lotopenref[lotnum]=ref;
					numlotsactive=numlotsactive+1;
					if(d)fprintf(pr,"bought, secondary long lotnum%d @ %5.2f pred2=%5.2f\n",lotnum+1,c[ref],pred2[ref]);
					}
				}
			}
        if((i1/100.0) <= shortthresh  && tradertype !=1 )  // short signal
			{
			if(numlotsactive < maxlots)   // ie lot available
				{
				for(k=1;k<=lotspertrade;k++)
					{
					if(numlotsactive >= maxlots)
						break;
					if(longflag && nospreadflag)
						break;
					for(lotnum=0;lotnum<maxlots;lotnum++) // find avail lot ref#
						{
						if(lotstatus[lotnum] == 0)  // ie available
						break;
						}
					kount=kount+1;
					numlotsactive=numlotsactive+1;
					openmarker[ref]-=1;
					lottarget[lotnum]=c[ref]*(1.0+((i1/100.0)*fsf));
					if(entrytypeflag == 1)
						lotentryprice[lotnum]=c[ref];
					else
						lotentryprice[lotnum]=o[ref+1];
					mincloseprice[lotnum]=c[ref];
					tradetype[lotnum]=-1; //short
					lotstatus[lotnum]=1;  //active
					lotopenref[lotnum]=ref;
					if(d)fprintf(pr,"sold short, lotnum%d @ %5.2f  pred=%5.2f\n",lotnum+1,c[ref],pred[ref]);
					}
				}
			}
        if((i1/100.0) > shortthresh && i2/100.0 <=shortthresh2 && tradertype !=1 )  // secondary short signal
			{
			if(numlotsactive < maxlots)   // ie lot available
				{
				for(k=1;k<=lotspertrade;k++)
					{
					if(numlotsactive >= maxlots)
						break;
					if(longflag && nospreadflag)
						break;
					for(lotnum=0;lotnum<maxlots;lotnum++) // find avail lot ref#
						{
						if(lotstatus[lotnum] == 0)  // ie available
						break;
						}
					kount=kount+1;
					numlotsactive=numlotsactive+1;
					openmarker[ref]-=1;
					lottarget[lotnum]=c[ref]*(1.0+((i2/100.0)*fsf));
					if(entrytypeflag == 1)
						lotentryprice[lotnum]=c[ref];
					else
						lotentryprice[lotnum]=o[ref+1];
					mincloseprice[lotnum]=c[ref];
					tradetype[lotnum]=-2; //secondary short
					lotstatus[lotnum]=1;  //active
					lotopenref[lotnum]=ref;
					if(d)fprintf(pr,"sold secondary short,@ next days open, lotnum%d @ %5.2f  pred2=%5.2f\n",lotnum+1,c[ref],pred2[ref]);
					}
				}
			}
		longcount=0;
		shortcount=0;
		for(lotnum=0;lotnum<maxlots;lotnum++)
			{
			if(lotstatus[lotnum] == 1) // active
				{
				if(tradetype[lotnum] == 1 || tradetype[lotnum] == 2)
					longcount+=1;
				if(tradetype[lotnum] == -1 || tradetype[lotnum] == -2)
					shortcount-=1;
				}
			}
                if(dumptoggle == 1) // dump *.lot data
			fprintf(du,"%d\n",longcount+shortcount);
                if(dumptoggle == 2) // dump *.prd data
                        fprintf(du,"%f\n",pred[ref]);


		if(d)
			fprintf(pr,"Cumulative Equity in Mkt. Points(open and closed positions)=%9.2f\n",account[ref]+openlotvalue);
		if(eq)
			fprintf(equ,"%9.2f\n",account[ref]+openlotvalue);
		if(longflag && shortflag && d)
			fprintf(pr,"-------------------Spread position in effect.\n");
		randu[ref]=account[ref]+openlotvalue;
		}
	c_mdds();
	for(x=1;x<=mcount;x++)
		summonthlygain+=monthlygain[x];
	avemonthlygain=summonthlygain/mcount;
	aapw=avemonthlygain*12.0;
	if(oflag && grtoggle == 1 )
		{
		plot_account();
		draw_grid();
        	p_pred();
		p_actual();
		plot_buyandhold();
           //     p_ooscorr();
		delay(100);
		if(stepflag == 1)
				{
                                printf("   <Enter>view next,2<-save map,3<-continue evolution,4<-show map,5<-replicate x 3 \n");
				gets(string);
				ans=atoi(string);
				if( ans == 4)
					{
					_clearscreen(_GCLEARSCREEN);
					draw_it2();
					}
				if( ans == 5)
					{
                                         for(genenum=0;genenum<MAXGENES;genenum++)
                                                parent[competitor_ss][genenum]=offspring[genenum];
                                         fitness[competitor_ss]=fitness_offspring;
                                         oosfitness[competitor_ss]=oosfitness_offspring;
                                         printf("Competitor  # %d replaced.............\n",competitor_ss);
                                         competitor_ss=rand()/(32766/MAXPOPULATION);
                                         for(genenum=0;genenum<MAXGENES;genenum++)
                                                parent[competitor_ss][genenum]=offspring[genenum];
                                         fitness[competitor_ss]=fitness_offspring;
                                         oosfitness[competitor_ss]=oosfitness_offspring;
                                         printf("Competitor  # %d replaced.............\n",competitor_ss);
                                         competitor_ss=rand()/(32766/MAXPOPULATION);
                                         for(genenum=0;genenum<MAXGENES;genenum++)
                                                parent[competitor_ss][genenum]=offspring[genenum];
                                         fitness[competitor_ss]=fitness_offspring;
                                         oosfitness[competitor_ss]=oosfitness_offspring;
                                         printf("Competitor  # %d replaced.............\n",competitor_ss);
                                         delay(1000);
                                         }
				if( ans == 2)
					 {
					 mapnamecount++;
					 write_olive();
                                         competitor_ss=rand()/(32766/MAXPOPULATION);
					 }
				if(ans == 3)
					 {
					 if(grtoggle == 1)
						 {  
						 _setvideomode(_DEFAULTMODE);
						 }
					 clrscr();
					 grtoggle*=-1;
					 stepflag=0;
					 donestep=1;
					 return(1);
					 }
				}
		_clearscreen(_GCLEARSCREEN);
		return(1);
		}
    if(grtoggle == 1 )
		  {
		  ddist10();
		  ddist20();
		  ddist30();
		  ddist40();
		  getch();
		  }
     if(grtoggle==1 )
		  {
		  _clearscreen(_GCLEARSCREEN);
		  mk_box();
		  _moveto(220,20);
		  _setcolor(LIGHTGRAY);
		  _outgtext("Account Growth History");
		  plot_account();
		  plot_buyandhold();
		  getch();
		  _setvideomode(_DEFAULTMODE);
		  clrscr();
		  }
	stddev=sqrt(sumdiffsqrd/lotcount);
	printf("Number of lots put on (new & re-entries)= %ld\n",kount);
	printf("Number of lots that hit target = %d\n",numhittarget);
	printf("Number of open lots that timed-out profitably = %d\n",numexpprofit);
	printf("Number of open lots that timed-out at a loss  = %d\n",numexploss);
	printf("Number of stop-loss hits = %d\n",numstopped);
	printf("Number of re-entries from stopped-out = %d\n",numreentered);
	printf("Number of stopped lots that timed-out = %d\n",numstopsexp);
	printf("Max 20 day draw-down(points)= %d\n",mdd20);
	printf("Max 60 day draw-down(points)= %d\n",mdd60);
	printf("Max 120 day draw-down(points)= %d\n",mdd120);
	printf("Max 250 day draw-down(points)= %d\n",mdd250);
	if(kount!=0)
		printf("Average dwell= %3.2f days\n",sumdaysold/kount);
	printf("Total market points gain = %f\n",account[simstop-1]);
	if(kount!=0)
		printf("Mean points gain per lot = %f\n",account[simstop-1]/kount);
	c_lotstats();
	printf("# wins = %d   #losses = %d\n",wincount,losscount);
	if(wincount != 0)
	printf("Average points won per winning lot: %f\n",winsum/wincount);
	if(losscount != 0)
	printf("Average points lost per losing lot: %f\n",losssum/losscount);
	if(mdd60 < 0)
	printf("60 day drawdown Sterling Ratio = %f\n",(avemonthlygain*12)/(-mdd60));
	printf("         Ave annual points won = %f\n",avemonthlygain*12.0);
	c_lastyear();
      //  printf("dayweight[1]=%f\n",dayweight[1]);
	printf("Test data maximum 20 day drawdown: %d\n",lymdd20);
	printf("Test data maximum 60 day drawdown: %d\n",lymdd60);
	printf("Test data maximum 120 day drawdown: %d\n",lymdd120);
	printf("Test data maximum 250 day drawdown: %d\n",lymdd250);
	printf("Test data points won = %f\n",account[nod-hide]-account[nod-(hide+virg)]);
	printf("Enter returns....");
	if(initflag == 0)
		  gets(string);
	if(d)
		 fclose(pr);
	if(eq)
		{
		eq=0;
		fclose(equ);
		}
	if(dumptoggle)
		fclose(du);
	return(1);
	}








c_lotstats()
	{
	int x;
	wincount=0;
	losscount=0;
	winsum=0.0;
	losssum=0.0;
	for(x=1;x<=lotcount;x++)
		{
		if(lotresult[x] >= 0.0)
			{
			++wincount;
			winsum+=lotresult[x];
			}
		else
			{
			++losscount;
			losssum+=lotresult[x];
			}
		}
	return(1);
	}



p_corr(ref,chg,type)
	int ref;
	float chg;
	int type;
	{
	int x,y;
	int xstart=320;
	int ystart=240;
	float xscale=13;
	float yscale=10;
	int dontskipflag=0;
	if(ref >= nod-((virg+foldshift)+foldwidth+hide) && ref < nod-(virg+foldshift+hide))
		dontskipflag=1; // opt segment
	if(ref >= moosb2 && ref <= moose2)
		dontskipflag=1; // middle oos segment2
	if(ref >= moosb && ref <= moose)
		dontskipflag=1; // middle oos segment
	if(ref >= nod-(virg+hide))
		dontskipflag=1; // confirm generalization segment
	if(ref >= nod-hide && hidetoggle == -1)
		dontskipflag=1;
	if(ref >= nod-hide && hidetoggle == 1)
		dontskipflag=1;
	if(dontskipflag != 1)
		return(1);
	if(type == 1 || type == -1)
		x=xstart+(pred[ref])*xscale;
	else
		x=xstart+(pred2[ref])*xscale;
	y=ystart-chg*yscale;
	if(type == 1 || type == -1)
		{
		if(pred[ref] >= 0)
			{
			_setcolor(GREEN);
			_setpixel(x,y);
			}
		else
			{
			_setcolor(RED);
			_setpixel(x,y);
			}
		}
	if(type == 2 || type == -2)
		{
		if(pred2[ref] >= 0)
			{
			_setcolor(GREEN);
			_setpixel(x,y);
			}
		else
			{
			_setcolor(RED);
			_setpixel(x,y);
			}
		}
	return(1);
	}


draw_oosgrid()
	{
	_setcolor(LIGHTGRAY);
	_moveto(430,340);// horizontal
	_lineto(610,340);//    "
	_moveto(520,240);// vertical
	_lineto(520,440);
     _setcolor(LIGHTBLUE);
	_moveto(428,390);
	_outgtext("Generalization Validation");
	_moveto(478,400);
     _outgtext("Scattergram");
	_moveto(520,300);
	_settextorient(1,1000);
	_setcharsize(8,8);
	_setcharspacing(-2);
	_setcolor(YELLOW);
	_grtext(600,340,"<-Virg Returns->");
	_settextorient(1,0);
	_moveto(474,374);
	_setcolor(MAGENTA);
	_outgtext("<-OPT Returns->");
	return(1);
	}





p_ooscorr()
	{
	int x,y,count;
	int xstart=520;
	int ystart=340;
	float xscale=50;
	float yscale=50;
	float virgreturns;
     float optreturns;
	virgreturns=(account[nod-hide]-account[nod-((virg+foldshift)+hide)])/(float)(virg+foldshift);
	optreturns=(account[nod-((virg+foldshift)+hide)]-account[nod-(hide+(virg+foldshift)+foldwidth)])/(float)foldwidth;
	for(count=1;count<=ocount;count++)
     	{
		x=xstart+(oosf[count]*xscale*scatterscale);
		y=ystart-(vf[count]*yscale*scatterscale);
		if(count<3000)
			{
			_setcolor(BLUE);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}	
		if(count>=3000)
			{
			_setcolor(BLUE);
			_setpixel(x,y);
			_setcolor(LIGHTBLUE);
			_setpixel(x,y+1);
			}
		if(count>6000)
			{
			_setcolor(LIGHTBLUE);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}
		if(count>9000)
			{
			_setcolor(LIGHTBLUE);
			_setpixel(x,y);
			_setcolor(LIGHTGRAY);
			_setpixel(x,y+1);
			}
		if(count>12000)
			{
			_setcolor(LIGHTGRAY);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}
		if(count>15000)
			{
			_setcolor(LIGHTGRAY);
			_setpixel(x,y);
			_setcolor(YELLOW);
			_setpixel(x,y+1);
			}
		if(count>18000)
			{
			_setcolor(YELLOW);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}
		if(count>21000)
			{
			_setcolor(YELLOW);
			_setpixel(x,y);
			_setcolor(WHITE);
			_setpixel(x,y+1);
			}
		if(count>24000)
			{
			_setcolor(WHITE);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}
		if(count>27000)
			{
			_setcolor(RED);
			_setpixel(x,y);
			_setpixel(x,y+1);
			}
		}
	x=xstart+(optreturns*xscale*scatterscale);
	y=ystart-(virgreturns*yscale*scatterscale);
	_setcolor(GREEN);
	_setpixel(x,y);
	_setpixel(x,y);
	_setpixel(x+1,y);
	_setpixel(x+2,y);
	_setpixel(x-1,y);
	_setpixel(x-2,y);
	_setpixel(x,y+1);
	_setpixel(x,y+1);
	_setpixel(x+1,y+1);
	_setpixel(x+2,y+1);
	_setpixel(x-1,y+1);
	_setpixel(x-2,y+1);
	_setpixel(x,y+2);
	_setpixel(x,y+2);
	_setpixel(x+1,y+2);
	_setpixel(x+2,y+2);
	_setpixel(x-1,y+2);
	_setpixel(x-2,y+2);
	_setpixel(x,y-1);
	_setpixel(x,y-1);
	_setpixel(x+1,y-1);
	_setpixel(x+2,y-1);
	_setpixel(x-1,y-1);
	_setpixel(x-2,y-1);
	_setpixel(x,y-2);
	_setpixel(x,y-2);
	_setpixel(x+1,y-2);
	_setpixel(x+2,y-2);
	_setpixel(x-1,y-2);
	_setpixel(x-2,y-2);
	draw_oosgrid();
     p_thrutime();
	return(1);
	}


p_thrutime()
	{
	int x,y,count,z;
	int xstart=10;
	int ystart=420;
	int ystart2=440;
	int ystart3=430;
	int ystart4=450;
	int ystart5=460;
	float yscale=75;
	float sum;
	_setcolor(LIGHTGRAY);
	_moveto(10,420);
	_lineto(610,420);
	_moveto(10,440);
	_lineto(610,440);
	_setcolor(YELLOW);
	for(count=201;count<ocount;count++)
		{
		sum=0.0;
		for(z=1;z<=200;z++)
			{
			sum+=vf[count-z];
			}   
		x=xstart+(count/50);
		y=ystart-(((sum/200.0)*yscale)*scatterscale);
		_setpixel(x,y);
		}
	_setcolor(MAGENTA);
	for(count=201;count<ocount;count++)
		{
                sum=0.0;
		for(z=1;z<=200;z++)
			{
			sum+=oosf[count-z];
			}
		x=xstart+(count/50);
		y=ystart2-(((sum/200.0)*yscale)*scatterscale);
		_setpixel(x,y);
		}
	_setcolor(BROWN);
	for(count=201;count<ocount;count++)
		{
		sum=0.0;
		for(z=1;z<=200;z++)
			{
			sum+=frontoos[count-z];
			}
		x=xstart+(count/50);
		y=ystart3-(((sum/200.0)*yscale)*scatterscale);
		_setpixel(x,y);
		}
	_setcolor(LIGHTRED);
	for(count=201;count<ocount;count++)
		{
          sum=0.0;
		for(z=1;z<=200;z++)
			{
			sum+=moos[count-z];
			}
		x=xstart+(count/50);
		y=ystart4-(((sum/200.0)*yscale)*scatterscale);
		if(y < 10)
			y=10;
		if(y > 470)
			y=470;
		_setpixel(x,y);
		}
	_setcolor(RED);
	for(count=201;count<ocount;count++)
		{
		sum=0.0;
		for(z=1;z<=200;z++)
			{
			sum+=moos2[count-z];
			}
		x=xstart+(count/50);
		y=ystart5-(((sum/200.0)*yscale)*scatterscale);
		if(y < 10)
			y=10;
		if(y > 470)
			y=470;
		_setpixel(x,y);
		}
	_setcolor(WHITE);
	_setcharsize(6,6);
	_setcharspacing(-2);
	_grtext(10,450,"<-Offspring count->");
	_grtext(90,450,"4k");
	_grtext(125,450,"6k");
	_grtext(165,450,"8k");
	_grtext(205,450,"10k");
	_grtext(245,450,"12k");
	_grtext(285,450,"14k");
	_grtext(325,450,"16k");
	_grtext(365,450,"18k");
	_grtext(405,450,"20k");
	_grtext(445,450,"22k");
	_grtext(485,450,"24k");
	_grtext(525,450,"26k");
	_grtext(565,450,"28k");
	_grtext(605,450,"30k");
	return(1);        
	}




draw_cgrid()
	{
	int t;
	float xscale=13;
	float yscale=10;
	_setcolor(YELLOW);
	_moveto(190,240);
	_lineto(450,240);
	_setcolor(MAGENTA);
	_moveto(320,140);
	_lineto(320,340);
	_setcolor(WHITE);
	for(t=0;t<21;t++)
		{
		_moveto(190+t*xscale,238);
		_lineto(190+t*xscale,242);
		}
	for(t=0;t<21;t++)
		{
		_moveto(318,140+t*yscale);
		_lineto(322,140+t*yscale);
		}
	_moveto(278,310);
	_setcolor(LIGHTBLUE);
	_outgtext("Trade Result");
	_moveto(280,318);
	_outgtext("Scattergram");
	_moveto(316,100);
	_settextorient(1,1000);
	_setcharsize(8,8);
	_setcharspacing(-2);
	_grtext(316,135,"<-Trade result points->");
	_settextorient(1,0);
	_moveto(280,240);
	_outgtext("<- Forecast % ->");
	return(1);
	}


plot_account()
	{
	char buffer[60];
	int start;
	int xstart=10;
	float xscale;
	int ystart=300;
	int ref;
	int x,y;
	float yscale=(800.0/accountscale);
	_moveto(xstart,ystart);
	xscale=600.0/(simstop-simstart);
	_setcolor(BROWN);
	start=nod-((learn-foldshift)+foldwidth+(virg+foldshift)+hide);
	if(start < 250)
		start=250;
	for(ref=simstart;ref<simstop;ref++)
		{
		x=xstart+((ref-simstart)*xscale);
		y=ystart-randu[ref]*yscale*rss*grss;
		if(randu[ref] == 0.0 || ref == simstart)
			_moveto(x,y);
		else
			_lineto(x,y);
		if(ref >= start)
			_setcolor(GREEN); // learning segment
		if(ref >= nod-((virg+foldshift)+foldwidth+hide) && ref < nod-(virg+foldshift+hide))
                        {
			_setcolor(MAGENTA); // opt segment
                        _lineto(x,y-1);
                    //    _moveto(x,y);
                        }
                if(ref >= moosb2 && ref <= moose2)
			_setcolor(RED); // middle oos segment2
		if(ref >= moosb && ref <= moose)
			_setcolor(LIGHTRED); // middle oos segment
		if(ref >= nod-(virg+hide))
			_setcolor(YELLOW); // confirm generalization segment
                if(ref >= nod-hide && hidetoggle == -1)
			_setcolor(BLACK);
		if(ref >= nod-hide && hidetoggle == 1)
			_setcolor(WHITE);
		}
  //	plot_newcells();
	gcvt(account[nod-1],7,buffer);
	_moveto(160,40);
	_setcolor(YELLOW);
	_outgtext("Account Gain: ");
	_setcolor(WHITE);
	_outgtext(buffer);
	_setcolor(YELLOW);
	_outgtext(" Market Points");
        itoa((simstop-simstart)+1,buffer,10);
	_moveto(200,460);
	_outgtext("<-- ");
	_setcolor(WHITE);
	_outgtext(buffer);
	_setcolor(YELLOW);
	_outgtext(" Days in Simulation -->");
	if(grtoggle) delay(200);
	return(1);
	}


plot_newcells()
	{
	char buffer[60];
	int start;
	int xstart=10;
	float xscale;
	int ystart=325;
	int ref;
	int x,y;
	float yscale=2.0;
	_moveto(xstart,ystart);
	xscale=600.0/(simstop-simstart);
	_setcolor(RED);
	start=nod-((learn-foldshift)+foldwidth+(virg+foldshift)+hide);
	if(start < 250)
		start=250;
	for(ref=simstart;ref<simstop;ref++)
		{
		x=xstart+((ref-simstart)*xscale);
		y=ystart-sumnewcells[ref]*yscale;
		if(sumnewcells[ref] == 0.0 || ref == simstart)
			_moveto(x,y);
		else
			_lineto(x,y);
		}
	return(1);
	}




plot_buyandhold()
	{
	int xstart=10;
	float xscale,max;
        int ystart=450;
	int ref;
	int x,y;
	float yscale;
        max=0.0;
	for(ref=simstart;ref<=nod;ref++)
		{
		if(c[ref]>max)
			max=c[ref];
          }
	yscale=200.0/max;
	_moveto(xstart,ystart);
	xscale=600.0/(nod-simstart);
	_setcolor(LIGHTBLUE);
	for(ref=simstart;ref<=nod;ref++)
		{
		x=xstart+((ref-simstart)*xscale);
		y=ystart-(c[ref]*yscale);
		if(ref == simstart)
			_moveto(x,y);
		else
			_lineto(x,y);
		}
	show_colorlegend();
	return(1);
	}



show_colorlegend()
	{
	_setcharsize(8,8);
	_setcharspacing(-2);
     _setcolor(LIGHTBLUE);
	_grtext(10,350,"Lt Blue= Buy and Hold Strategy");
	_setcolor(BROWN);
	_grtext(10,360,"Brown  = OOS data on front of stream");
	_setcolor(GREEN);
	_grtext(10,370,"Green  = Map Frequency Distribution construction segment");
	_setcolor(MAGENTA);
	_grtext(10,380,"Magenta= GA Optimization data segment");
	_setcolor(YELLOW);
	_grtext(10,390,"Yellow = Dynamic generalization verification segment");
	_setcolor(WHITE);
	_grtext(10,400,"White  = Hidden (OOS) segment on end of stream");
	return(1);
	}


drawdist()
	{
	int x,y,z,ref,period,ichg;
	int maxdrawdown=0;
	int array[602];
	char string[30];
	float htscale;
	float sum=0.0;
	int count=0;
	clrscr();
	printf("\n\n    Enter time span (days), for points change distribution: ");
	gets(string);
	period=atoi(string);
	printf("\n      Enter height scale for plotting: ");
	gets(string);
	htscale=atof(string);
	_setvideomode(_VRES16COLOR);
	mk_box();
	for(z=0;z<=600;z++)
		array[z]=0;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
		sum+=randu[ref+period]-randu[ref];
		++count;
		if(ichg < maxdrawdown)
			{
			maxdrawdown=ichg;
			mddref=ref;
			}
		if(ichg < -300)
			ichg=-300;
		if(ichg > 300)
			ichg=300;
		array[ichg+300]+=1;
		}
	for(z=0;z<=600;z++)
		{
		_moveto(20+z,400);
		if(z<300)
			_setcolor(RED);
		else
			_setcolor(GREEN);
		_lineto(20+z,400-(array[z]*htscale*.2));
		}
	printf("points change distribution over any %d day period.\n",period);
	printf("Full scale = minus to plus 300 points\n");
	printf("Distribution mean = %f\n",sum/count);
	printf("Max draw-down points (raw market points) = %d\n",maxdrawdown);
	printf("occurred starting on ref day # %d\n",mddref);
	printf("Enter 1 to write account distribution to file, or just <enter> to continue: ");
	gets(string);
	if(atoi(string) == 1)   // write file
		{
		_setvideomode(_DEFAULTMODE);
		clrscr();
		system("dir *.dis");
		printf("\n\t\t\tEnter account distribution filename: ");
		gets(string);
		prd=fopen(string,"w");
		if(prd == NULL)
			{
			printf("Can't open %s\n",string);
			delay(2000);
			return(1);
			}
		for(x=0;x<600;x++)
			{
			fprintf(prd,"%d\n",array[x]);
			}
		fclose(prd);
		}
    _setvideomode(_DEFAULTMODE);
	return(1);
	}



ddist10()
	{
	int x,y,z,ref,period,ichg;
	int array[302];
	float htscale;
        float fy;
        float win=0.0;
        float loss=0.0;
        period=3;
        htscale=1.0;
	for(z=0;z<=300;z++)
		array[z]=0;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
                if(randu[ref+1]>randu[ref])
                        win+=1.0;
                if(randu[ref+1]<randu[ref])
                        loss+=1.0;
		if(ichg < -150)
			continue;
		if(ichg > 150)
			continue;
		array[ichg+150]+=1;
		}
	for(z=0;z<=300;z++)
		{
		_moveto(10+z,180);
		if(z<150)
			_setcolor(RED);
		else
			_setcolor(GREEN);
        fy=180.0-((float)array[z]*htscale*.2);
        y=(int)fy;
     //   printf("z=%d  fy=%f   y=%d\n",z,fy,y);
        _lineto(10+z,y);
		}
	_moveto(50,190);
	_setcolor(YELLOW);
    _outgtext("3 day account change distribution");
	_moveto(60,200);
	_outgtext("<-Full scale +/- 150 points ->");
         printf("Win/(Win+Loss) = %f\n",win/(win+loss));

	return(1);
	}


ddist20()
	{
	int x,y,z,ref,period,ichg;
	int array[302];
	float htscale;
        period=5;
	htscale=1.0;
	for(z=0;z<=300;z++)
		array[z]=0;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
		if(ichg < -150)
			continue;
		if(ichg > 150)
			continue;
		array[ichg+150]+=1;
		}
	for(z=0;z<=300;z++)
		{
		_moveto(330+z,180);
		if(z<150)
			_setcolor(RED);
		else
			_setcolor(GREEN);
		_lineto(330+z,180-(array[z]*htscale*.2));
		}
	_moveto(370,190);
	_setcolor(YELLOW);
        _outgtext("5 day account distribution");
	return(1);
	}

ddist30()
	{
	int x,y,z,ref,period,ichg;
	int array[302];
	float htscale;
        period=10;
	htscale=1.0;
	for(z=0;z<=300;z++)
		array[z]=0;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
		if(ichg < -150)
			continue;
		if(ichg > 150)
			continue;
		array[ichg+150]+=1;
		}
	for(z=0;z<=300;z++)
		{
		_moveto(10+z,460);
		if(z<150)
			_setcolor(RED);
		else
			_setcolor(GREEN);
		_lineto(10+z,460-(array[z]*htscale*.2));
		}
	_moveto(50,470);
	_setcolor(YELLOW);
        _outgtext("10 day account distribution");
	return(1);
	}

ddist40()
	{
	int x,y,z,ref,period,ichg;
	int array[302];
	float htscale;
        period=30;
	htscale=1.0;
	for(z=0;z<=300;z++)
		array[z]=0;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
		if(ichg < -150)
			continue;
		if(ichg > 150)
			continue;
		array[ichg+150]+=1;
		}
	for(z=0;z<=300;z++)
		{
		_moveto(330+z,460);
		if(z<150)
			_setcolor(RED);
		else
			_setcolor(GREEN);
		_lineto(330+z,460-(array[z]*htscale*.2));
		}
	_moveto(370,470);
	_setcolor(YELLOW);
        _outgtext("30 day account distribution");
	return(1);
	}


c_mdds()
	{
	int x,y,z,ref,period,ichg;
	int maxdrawdown=0;
	char string[30];
	float htscale;
	float sum=0.0;
	int count=0;
	mdd20=1000;
	mdd60=1000;
	mdd120=1000;
	mdd250=1000;
	period=20;
	for(ref=simstart;ref<simstop-period;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+period]-randu[ref];
		if(ichg < maxdrawdown)
			{
			maxdrawdown=ichg;
			mddref=ref;
			}
		}
	for(ref=simstart;ref<simstop-20;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+20]-randu[ref];
		if(ichg < mdd20)
			{
			mdd20=ichg;
			}
		}
	for(ref=simstart;ref<simstop-60;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+60]-randu[ref];
		if(ichg < mdd60)
			{
			mdd60=ichg;
			}
		}
	for(ref=simstart;ref<simstop-120;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+120]-randu[ref];
		if(ichg < mdd120)
			{
			mdd120=ichg;
			}
		}
	for(ref=simstart;ref<simstop-250;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+250]-randu[ref];
		if(ichg < mdd250)
			{
			mdd250=ichg;
			}
		}
	return(1);
	}





c_mddsa()
	{
	int x,y,z,ref,period,ichg;
	int maxdrawdown=0;
	char string[30];
	float htscale;
	float sum=0.0;
	int count=0;
	mdd20a=1000;
	mdd60a=1000;
	mdd120a=1000;
	mdd250a=1000;
	period=20;
	for(ref=250;ref<nod-(virg+foldshift);ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+20]-randu[ref];
		if(ichg < mdd20a)
			{
			mdd20a=ichg;
			}
		}
	for(ref=250;ref<nod-(virg+foldshift);ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+60]-randu[ref];
		if(ichg < mdd60a)
			{
			mdd60a=ichg;
			}
		}
	for(ref=250;ref<nod-(virg+foldshift);ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+120]-randu[ref];
		if(ichg < mdd120a)
			{
			mdd120a=ichg;
			}
		}
/*      for(ref=nod-((virg+foldshift)+foldwidth);ref<nod-(virg+foldshift);ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+250]-randu[ref];
		if(ichg < mdd250a)
			{
			mdd250a=ichg;
			}
		}*/
	return(1);
	}


c_lastyear()
	{
	int x,y,z,ref,period,ichg;
	int maxdrawdown=0;
	char string[30];
	float sum=0.0;
	int count=0;
        lymdd20=10000;
        lymdd60=10000;
        lymdd120=10000;
        lymdd250=10000;
	for(ref=nod-(virg+20);ref<simstop-20;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+20]-randu[ref];
		if(ichg < lymdd20)
			{
			lymdd20=ichg;
			}
		}
	for(ref=nod-(virg+60);ref<simstop-60;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+60]-randu[ref];
		if(ichg < lymdd60)
			{
			lymdd60=ichg;
			}
		}
	for(ref=nod-(virg+120);ref<simstop-120;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+120]-randu[ref];
		if(ichg < lymdd120)
			{
			lymdd120=ichg;
			}
		}
	for(ref=nod-(virg+250);ref<simstop-250;ref++)
		{
		if(randu[ref] == 0.0)
			continue;
		ichg=randu[ref+250]-randu[ref];
		if(ichg < lymdd250)
			{
			lymdd250=ichg;
			}
		}
	return(1);
	}


c_sharpe()
	{
	float sumdiffsquared=0.0;
	int ref;
	int count=0;
	float sum=0.0;
	float ave,chg,stddev;
	double ratio;
	for(ref=simstart;ref<simstop-20;ref+=20)
		{
		++count;
		sum+=account[ref+20]-account[ref];
		}
	ave=sum/count;   //ave monthly return points
	for(ref=simstart;ref<simstop-20;ref+=20)
		{
		chg=account[ref+20]-account[ref];
		sumdiffsquared+=(chg-ave)*(chg-ave);
		}
	ratio=sumdiffsquared/count;
	stddev=sqrt(ratio);
	sharperatio=ave/stddev;
	return(1);
	}


drawtradedist()
	{
	int x,y,z,ref,ichg;
	int array[201];
	char string[30];
	float htscale;
	clrscr();
	printf("\n      Enter height scale for plotting: ");
	gets(string);
	htscale=atof(string);
	_setvideomode(_VRES16COLOR);
	mk_box();
	for(z=0;z<=200;z++)
		array[z]=0;
	for(ref=1;ref<=lotcount;ref++)
		{
		ichg=lotresult[ref]-1.000;
		if(ichg < -100)
			ichg=-100;
		if(ichg > 100)
			ichg=100;
		array[ichg+100]+=1;
		}
	for(z=0;z<=200;z++)
		{
		_moveto(100+(2*z),350);
		if(z<100)
			_setcolor(RED);
		else
			_setcolor(GREEN);
		_lineto(100+(2*z),350-(array[z]*htscale*.05));
		}
	printf("Lot result frequency distribution.\n");
	printf("Height = relative frequency.\n");
	printf("Each vertical line = 1 points, green is positive.\n");
	printf("Enter 1 to write trade result distribution to file, or just <enter> to continue: ");
	gets(string);
	if(atoi(string) == 1)   // write file
		{
        _setvideomode(_DEFAULTMODE);
		clrscr();
		system("dir *.trd");
		printf("\n\t\t\tEnter account distribution filename(*.trd): ");
		gets(string);
		prd=fopen(string,"w");
		if(prd == NULL)
			{
			printf("Can't open %s\n",string);
			delay(2000);
			return(1);
			}
		for(x=0;x<200;x++)
			{
			fprintf(prd,"%d\n",array[x]);
			}
		fclose(prd);
		}
    _setvideomode(_DEFAULTMODE);
	return(1);
	}




input_prd()
	{
	int ref=0;
	clrscr();
	system("dir *.prd");
	printf("\n\t\t\tEnter primary .prd filename: ");
	gets(prdstream);
	prd=fopen(prdstream,"r");
	if(prd == NULL)
		{
		printf("Can't open %s\n",prdstream);
		delay(2000);
		return(1);
		}
	while(fscanf(prd,"%f\n",&pred[ref]) != EOF)
			{
			ref++;
			continue;
			}
	fclose(prd);
	return(1);
	}


input_prd2()
	{
	int ref=0;
	clrscr();
	system("dir *.prd");
	printf("\n\t\t\tEnter secondary .prd filename: ");
	gets(prdstream2);
	prd=fopen(prdstream2,"r");
	if(prd == NULL)
		{
		printf("Can't open %s\n",prdstream2);
		delay(2000);
		return(1);
		}
	while(fscanf(prd,"%f\n",&pred2[ref]) != EOF)
			{
			ref++;
			continue;
			}
	fclose(prd);
	return(1);
	}




wrtmktpts()
	{
	int ref;
	float sum=0.0;
	char string[30];
	clrscr();
	printf("\n\n\n\t\tEnter file name for Market Point win/loss stream: ");
	gets(string);
	prd=fopen(string,"w");
	for(ref=0;ref<=nod;ref++)
		{
		fprintf(prd,"%f\n",marketpts[ref]);
		sum+=marketpts[ref];
		}
	fclose(prd);
	printf("Sum of market points = %f\n",sum);
	delay(1000);
	return(1);
	}



write_randu()
	{
	int ref;
	char string[30];
	clrscr();
	printf("\n\n\n\t\tEnter file name for realized and unrealized equity stream: ");
	gets(string);
	prd=fopen(string,"w");
	for(ref=0;ref<=nod;ref++)
		{
		fprintf(prd,"%f\n",randu[ref]);
		}
	fclose(prd);
	return(1);
	}


fillandwriteret()
	{
	int ref;
	char string[30];
     prd=fopen("sum.ret","w");
     for(ref=0;ref<=nod;ref++)
		sumret[ref]+=account[ref];
	for(ref=0;ref<=nod;ref++)
		{
          fprintf(prd,"%f\n",sumret[ref]);
		}
	fclose(prd);
	return(1);
	}






p_s()
	{
	int numopened;
	int numclosed; 
	int x,y,ref,xmax,ymax,stop;
	float ht;
	int xstart=610;
	int ystart=300;
	int yscale=1000;
	x=0;
	y=0;
	ymax=479;
	_setcolor(LIGHTBLUE);
	stop=300;
	for(ref=0;ref<=stop;ref++)
		{
		if(c[(nod-hs)] == 0)
			continue;
		ht=((c[(nod-hs)-ref]-c[(nod-hs)])/c[(nod-hs)])*yscale;
		x=(xstart-(ref*2));
		y=ystart-ht;
		if(ref == 0)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_setcolor(LIGHTBLUE);
		_lineto(x,y);
		if(datatype == 0)
			continue;
		numopened = openmarker[(nod-hs)-ref];
		numclosed =closemarker[(nod-hs)-ref];
		if(numopened > 0 )  /* opened long*/
			{
			_setcolor(GREEN);
			_moveto(x,y+(3*numopened));
			_lineto(x,y+1);
			_lineto(x-2,y+3);
			_moveto(x,y+1);
			_lineto(x+2,y+3);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		if(numopened < 0)  /* opened  short*/
			{
			_setcolor(RED);
			_moveto(x,y+(3*numopened));
			_lineto(x,y-1);
			_lineto(x-2,y-3);
			_moveto(x,y-1);
			_lineto(x+2,y-3);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		if(numclosed > 0)  /* closed long */
			{
			_setcolor(MAGENTA);
			_moveto(x,y-(3*numclosed));
			_lineto(x,y-1);
			_lineto(x-2,y-3);
			_moveto(x,y-1);
			_lineto(x+2,y-3);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		if(numclosed < 0)  /* closed  short */
			{
			_setcolor(YELLOW);
			_moveto(x,y-(3*numclosed));
			_lineto(x,y-1);
			_lineto(x-2,y+3);
			_moveto(x,y-1);
			_lineto(x+2,y+3);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		if(stopmarker[(nod-hs)-ref] != 0)
			{
			_setcolor(LIGHTRED);
			_moveto(x,y-(30+(3*stopmarker[(nod-hs)-ref])));
			_lineto(x,y-30);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		if(reentermarker[(nod-hs)-ref] != 0)
			{
			_setcolor(LIGHTGREEN);
			_moveto(x,y-(20+(3*reentermarker[(nod-hs)-ref])));
			_lineto(x,y-20);
			}
		_setcolor(LIGHTBLUE);
		_moveto(x-1,y);
		}
	return(1);
	}

u_p_s()
	{
	int numopened;
	int numclosed; 
	int x,y,ref,xmax,ymax,stop;
	float ht;
	int xstart=610;
	int ystart=300;
	int yscale=1000;
	x=0;
	y=0;
	ymax=479;
	_setcolor(0);
	stop=300;
	for(ref=0;ref<=stop;ref++)
		{
		if(c[(nod-hs)] == 0)
			continue;
		ht=((c[(nod-hs)-ref]-c[(nod-hs)])/c[(nod-hs)])*yscale;
		x=(xstart-(ref*2));
		y=ystart-ht;
		if(ref == 0)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_setcolor(0);
		_lineto(x,y);
		numopened = openmarker[(nod-hs)-ref];
		numclosed =closemarker[(nod-hs)-ref];
		if(numopened > 0 )  /* opened long*/
			{
			_setcolor(0);
			_moveto(x,y+(3*numopened));
			_lineto(x,y+1);
			_lineto(x-2,y+3);
			_moveto(x,y+1);
			_lineto(x+2,y+3);
			}
		_setcolor(0);
		_moveto(x-1,y);
		if(numopened < 0)  /* opened  short*/
			{
			_setcolor(0);
			_moveto(x,y+(3*numopened));
			_lineto(x,y-1);
			_lineto(x-2,y-3);
			_moveto(x,y-1);
			_lineto(x+2,y-3);
			}
		_setcolor(0);
		_moveto(x-1,y);
		if(numclosed > 0)  /* closed long */
			{
			_setcolor(0);
			_moveto(x,y-(3*numclosed));
			_lineto(x,y-1);
			_lineto(x-2,y-3);
			_moveto(x,y-1);
			_lineto(x+2,y-3);
			}
		_setcolor(0);
		_moveto(x-1,y);
		if(numclosed < 0)  /* closed  short */
			{
			_setcolor(0);
			_moveto(x,y-(3*numclosed));
			_lineto(x,y-1);
			_lineto(x-2,y+3);
			_moveto(x,y-1);
			_lineto(x+2,y+3);
			}
		_setcolor(0);
		_moveto(x-1,y);
		if(stopmarker[(nod-hs)-ref] != 0)
			{
			_setcolor(0);
			_moveto(x,y-(30+(3*stopmarker[(nod-hs)-ref])));
			_lineto(x,y-30);
			}
		_setcolor(0);
		_moveto(x-1,y);
		if(reentermarker[(nod-hs)-ref] != 0)
			{
			_setcolor(0);
			_moveto(x,y-(20+(3*reentermarker[(nod-hs)-ref])));
			_lineto(x,y-20);
			}
		_setcolor(0);
		_moveto(x-1,y);
		}
	return(1);
	}



outline()
	{
	_setcolor(6);
	_moveto(580,17);
	_lineto(630,17);
	_lineto(630,30);
	_lineto(580,30);
	_lineto(580,17);
	_moveto(580,48);
	_lineto(630,48);
	_lineto(630,61);
	_lineto(580,61);
	_lineto(580,48);
	_moveto(580,79);
	_lineto(630,79);
	_lineto(630,96);
	_lineto(580,96);
	_lineto(580,79);
	return(1);
	}

p_pred()
	{
	int x,y,ref,xmax,ymax,stop;
	float ht;
	float targprice;
	float tdpw;   // test data points won
	char buffer[20];
	int xstart=610;
	int ystart=200;
	int yscale=10;
	x=0;
	y=0;
	ymax=479;
	_setcolor(RED);  //plot thresholds
        y=ystart-(longthresh*100.0)*yscale;
        _moveto(0,y);
        _lineto(610,y);
        y=ystart-(shortthresh*100.0)*yscale;
        _moveto(0,y);
        _lineto(610,y);
        _setcolor(CYAN);
	color=2;
	_moveto(xstart,ystart);
	_lineto(0,ystart);
	color=4;
	_setcolor(YELLOW);
	if((nod-hs) > 300)
		stop=300;
	else
		stop=nod;
	for(ref=0;ref<=stop;ref++)
		{
		if(c[(nod-hs)] == 0 || c[(nod-hs)-ref] == 0)
			continue;
		ht=(pred[(nod-hs)-ref])*yscale;
		x=(xstart-(ref*2));
		y=ystart-ht;
		if(ref == 0)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_setcolor(LIGHTCYAN);
		_lineto(x,y);
		}
	itoa(nod-hs,buffer,10);
	_settextposition(1,2);
	_outtext("Reference day (far right): ");
	_outtext(buffer);
	strcpy(buffer,istream1);
	_settextposition(1,45);
	_outtext("Target Market: ");
	_outtext(buffer);
	itoa(hs,buffer,10);
	_settextposition(2,2);
	_outtext("Days from end of file: ");
	_outtext(buffer);
	gcvt((double)c[nod-hs],6,buffer);
	_settextposition(3,2);
	_outtext("Furthest right value: ");
	_outtext(buffer);
	gcvt((double)pred[nod-hs],3,buffer);
	_settextposition(4,2);
	_setcolor(14);
	_outtext("Forecast percent: ");
	_outtext(buffer);
	targprice=c[nod-hs]*(1.0+pred[nod-hs]/100.0);
     tdpw=account[nod-hide]-account[nod-(hide+virg)];
	_settextposition(5,2);
	_outtext("Target price: ");
	gcvt(targprice,6,buffer);
	_outtext(buffer);
	_settextposition(6,2);
	_outtext("Test Data [yellow] Points Won: ");
	gcvt(tdpw,4,buffer);
	_outtext(buffer);
	_settextposition(2,75);
	_outtext("Menu");
	_settextposition(4,75);
	_outtext("List");
	_settextposition(6,75);
	_outtext("Map");
	outline();
	return(1);
	}



u_p_pred()
	{
	int x,y,ref,xmax,ymax,stop;
	float ht;
	float targprice;
	char buffer[20];
	int xstart=610;
	int ystart=200;
	int yscale=10;
	x=0;
	y=0;
	ymax=479;
	color=0;
	_moveto(xstart,ystart);
	_lineto(0,ystart);
	color=0;
	_setcolor(0);
	if((nod-hs) > 300)
		stop=300;
	else
		stop=nod;
	for(ref=0;ref<=stop;ref++)
		{
		if(c[(nod-hs)] == 0 || c[(nod-hs)-ref] == 0)
			continue;
		ht=(pred[(nod-hs)-ref])*yscale;
		x=(xstart-(ref*2));
		y=ystart-ht;
		if(ref == 0)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_setcolor(0);
		_lineto(x,y);
		}
	return(1);
	}


p_actual()           /* upper perf band */
	{
	int x,y,ref,xmax,ymax,stop,start,day;
	float ht,chg,max;
	int xstart=610;
	int ystart=200;
	int yscale=1000;  /* 10 pixels per points */
	x=0;
	y=0;
	ymax=479;
	color=1;
	_setcolor(color);
	stop=300;
	if(hs < gflook)
		start=gflook-hs;
	else
		start=0;
	for(ref=start;ref<=stop;ref++)
		{
		max=-1000.0;
		for(day=0;day<=gflook;day++)
			{
			chg=(c[((nod-hs)-ref)+day]/c[(nod-hs)-ref]-1.0)*yscale;
			if(chg > max)
				max=chg;
			}
		ht=max;
		x=xstart-(ref*2);
		y=ystart-ht;
		if(ref == start)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_lineto(x,y);
		}
	p_lactual();
	return(1);
	}


u_p_actual()           /* upper perf band */
	{
	int x,y,ref,xmax,ymax,stop,start,day;
	float ht,chg,max;
	int xstart=610;
	int ystart=200;
	int yscale=1000;  /* 10 pixels per points */
	x=0;
	y=0;
	ymax=479;
	color=1;
	_setcolor(0);
	stop=300;
	if(hs < gflook)
		start=gflook-hs;
	else
		start=0;
	for(ref=start;ref<=stop;ref++)
		{
		max=-1000.0;
		for(day=0;day<=gflook;day++)
			{
			chg=(c[((nod-hs)-ref)+day]/c[(nod-hs)-ref]-1.0)*yscale;
			if(chg > max)
				max=chg;
			}
		ht=max;
		x=xstart-(ref*2);
		y=ystart-ht;
		if(ref == start)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_lineto(x,y);
		}
	u_p_lactual();
	return(1);
	}

p_lactual()           /* lower perf band */
	{
	int x,y,ref,xmax,ymax,stop,start,day;
	float ht,chg,min;
	int xstart=610;
	int ystart=200;
	int yscale=1000;
	x=0;
	y=0;
	ymax=479;
	color=1;
	_setcolor(color);
	stop=300;
	if(hs < gflook)
		start=gflook-hs;
	else
		start=0;
	for(ref=start;ref<=stop;ref++)
		{
		min=1000.0;
		for(day=0;day<=gflook;day++)
			{
			chg=(c[((nod-hs)-ref)+day]/c[(nod-hs)-ref]-1.0)*yscale;
			if(chg < min)
				min=chg;
			}
		ht=min;
		x=xstart-(ref*2);
		y=ystart-ht;
		if(ref == start)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_lineto(x,y);
		}
	return(1);
	}

u_p_lactual()           /* lower perf band */
	{
	int x,y,ref,xmax,ymax,stop,start,day;
	float ht,chg,min;
	int xstart=610;
	int ystart=200;
	int yscale=1000;
	x=0;
	y=0;
	ymax=479;
	color=0;
	_setcolor(color);
	stop=300;
	if(hs < gflook)
		start=gflook-hs;
	else
		start=0;
	for(ref=start;ref<=stop;ref++)
		{
		min=1000.0;
		for(day=0;day<=gflook;day++)
			{
			chg=(c[((nod-hs)-ref)+day]/c[(nod-hs)-ref]-1.0)*yscale;
			if(chg < min)
				min=chg;
			}
		ht=min;
		x=xstart-(ref*2);
		y=ystart-ht;
		if(ref == start)
			{
			_moveto(x,y);
			continue;
			}
		if(y>ymax)
			y=ymax;
		_lineto(x,y);
		}
	return(1);
	}






draw_grid()
		{
		int xstart=610;
		int ystart=200;
		int xstop=10;
		int x;
		_setcolor(8);
		_moveto(xstart,ystart+10);
		_lineto(xstop,ystart+10);
		_moveto(xstart,ystart+20);
		_lineto(xstop,ystart+20);
		_moveto(xstart,ystart+30);
		_lineto(xstop,ystart+30);
		_moveto(xstart,ystart+40);
		_lineto(xstop,ystart+40);
		_moveto(xstart,ystart+50);
		_lineto(xstop,ystart+50);
		_moveto(xstart,ystart-10);
		_lineto(xstop,ystart-10);
		_moveto(xstart,ystart-20);
		_lineto(xstop,ystart-20);
		_moveto(xstart,ystart-30);
		_lineto(xstop,ystart-30);
		_moveto(xstart,ystart-40);
		_lineto(xstop,ystart-40);
		_moveto(xstart,ystart-50);
		_lineto(xstop,ystart-50);
		for(x=0;x<=30;x++)
			{
			_moveto(xstart-(x*20),ystart-50);
			_lineto(xstart-(x*20),ystart+250);
			}
		_moveto(xstart,ystart+250);
		_lineto(xstop,ystart+250);
		_setcolor(15);
		return(1);
		}



void clrscr()
	{
	union REGS regs;
	regs.w.cx=0;
	regs.w.dx=0x1850;
	regs.h.bh=7;
	regs.w.ax=0x0600;
	int386(0x10,&regs,&regs);
	gotoxy(0,0);
	}

void gotoxy(int col,int row)
	{
	union REGS xr;
	xr.h.ah=2;
	xr.h.dh=row;
	xr.h.dl=col;
	xr.h.bh=0;
	int386(0x10,&xr,&xr);
	}

calc_params_offspring()
    {
    int x;
    lrate=offspring[0]/4000000.0;
    tracelength=offspring[1]/(32000);
    if(tracelength == 0)
		tracelength=1;
    for(x=0;x<MAXDIST*8;x++)
		{
		mapscale[x]=offspring[31+x]/(32000/gcmapscale);
                dayweight[x]=(float)(offspring[(MAXDIST*8+32)+x]/(32766.0));
    //		printf("mapscale[x]=%d\n",mapscale[x]);
		}
    lrate2=offspring[14]/4000000.0;
    tracelength2=offspring[15]/(32000);
    if(tracelength2 == 0)
		tracelength2=1;
    
    lrate3=offspring[17]/4000000.0;
    tracelength3=offspring[18]/(32000);
    if(tracelength3 == 0)
		tracelength3=1;
    
    lrate4=offspring[20]/4000000.0;
    tracelength4=offspring[21]/(32000);
    if(tracelength4 == 0)
		tracelength4=1;
   
    flook=offspring[3]/1000;
    if(flook == 0)
		flook=1;
    maxhold=offspring[4]/(32000/gcmaxhold);
    smaxhold=maxhold; // was offspring[23]/(32000/gcsmaxhold);
    ft1=offspring[24]/1000;
    if(ft1<1) ft1=1;
    ft2=offspring[28]/327;
    ft3=offspring[29]/327;
        gft2=(float)ft2/20.0;
        gft3=(float)ft3/20.0;

    ft4=offspring[30]/5000;
    f2=offspring[25]/1000;
    f3=offspring[26]/1000;
    f4=offspring[27]/1000;
    if(maxhold == 0)
		maxhold=1;
    if(smaxhold == 0)
		smaxhold=1;
    longthresh=offspring[5]/3000000.0;
    if(longthresh<.005)
        longthresh=.005;
    shortthresh=-longthresh;
    maxpass=offspring[7]/(32000/gcmaxpass);
    if(maxpass == 0)
		maxpass=1;
    fsf=offspring[8]/(32000/gcfsf);
    if(fsf < 1.0)
	fsf=1.0;
    stopthresh=offspring[9]/(32000/gcstopthresh);
    if(stopthresh < minstopthresh)
		stopthresh=minstopthresh;
    rthresh=offspring[10]/(32000/gcrthresh);
    lotspertrade=offspring[11]/(32000/gclotspertrade);
    if(lotspertrade == 0)
		lotspertrade=1;
    maxlots=offspring[12]/(32000/gcmaxlots);
    if(maxlots == 0)
		maxlots= 1;
    maxreentry=offspring[13]/(32000/gcmaxreentry);
    if(grtoggle == 1)
    {
	gotoxy(0,8);
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	gotoxy(0,9);
	printf("l1=%f l2=%f l3=%f l4=%f\n",lrate,lrate2,lrate3,lrate4);
	printf("t1=%d t2=%d t3=%d t4=%d\n",tracelength,tracelength2,tracelength3,tracelength4);
	printf("offset2=%d offset3=%d offset4=%d\n",f2,f3,f4);
	printf("long days held=%d\n",maxhold);
	printf("short days held=%d\n",smaxhold);
	printf("future look = %d\n",flook);
	printf("Buy threshold = %f\n",longthresh*100.0);
	printf("Sell threshold = %f\n",shortthresh*100.0);
	printf("Forecast scale factor = %f\n",fsf);
	printf("Lots per trade = %d\n",lotspertrade);
        printf("Puritythresh = %f\n",puritythresh);
	printf("Maximum lots allowed = %d\n",maxlots);
	}
	return(1);
	}

calc_params_competitor()
    {
    int x;
    lrate=parent[competitor_ss][0]/4000000.0;
    tracelength=parent[competitor_ss][1]/(32000);
    if(tracelength == 0)
		tracelength=1;
    for(x=0;x<MAXDIST*8;x++)
		{
		mapscale[x]=parent[competitor_ss][31+x]/(32000/gcmapscale);
                dayweight[x]=(float)(parent[competitor_ss][31+x]/32766.0);
		}
    lrate2=parent[competitor_ss][14]/4000000.0;
    tracelength2=parent[competitor_ss][15]/(32000);
    if(tracelength2 == 0)
		tracelength2=1;
    
    lrate3=parent[competitor_ss][17]/4000000.0;
    tracelength3=parent[competitor_ss][18]/(32000);
    if(tracelength3 == 0)
		tracelength3=1;
    
    lrate4=parent[competitor_ss][20]/4000000.0;
    tracelength4=parent[competitor_ss][21]/(32000);
    if(tracelength4 == 0)
		tracelength4=1;
    
    flook=parent[competitor_ss][3]/1000;
	if(flook == 0)
		flook=1;
    maxhold=parent[competitor_ss][4]/(32000/gcmaxhold);
    smaxhold=maxhold; // was parent[competitor_ss][23]/(32000/gcsmaxhold);
    ft1=parent[competitor_ss][24]/1000;
    if(ft1<1) ft1=1;
    ft2=parent[competitor_ss][28]/327;
    ft3=parent[competitor_ss][29]/327;
        gft2=(float)ft2/20.0;
        gft3=(float)ft3/20.0;

    ft4=parent[competitor_ss][30]/5000;
    f2=parent[competitor_ss][25]/1000;
    f3=parent[competitor_ss][26]/1000;
    f4=parent[competitor_ss][27]/1000;
	if(maxhold == 0)
		maxhold=1;
	if(smaxhold == 0)
		smaxhold=1;
    longthresh=parent[competitor_ss][5]/3000000.0;
    if(longthresh<.005)
        longthresh=.005;

    shortthresh=-longthresh;
    maxpass=parent[competitor_ss][7]/(32000/gcmaxpass);
	if(maxpass == 0)
		maxpass=1;
	 fsf=parent[competitor_ss][8]/(32000/gcfsf);
    if(fsf < 1.0)
	fsf=1.0;
    stopthresh=parent[competitor_ss][9]/(32000/gcstopthresh);
	if(stopthresh < minstopthresh)
		stopthresh=minstopthresh;
    rthresh=parent[competitor_ss][10]/(32000/gcrthresh);
    lotspertrade=parent[competitor_ss][11]/(32000/gclotspertrade);
	if(lotspertrade == 0)
		lotspertrade=1;
    maxlots=parent[competitor_ss][12]/(32000/gcmaxlots);
	if(maxlots == 0)
		maxlots= 1;
    maxreentry=parent[competitor_ss][13]/(32000/gcmaxreentry);
    if(grtoggle == 1)
    {
	gotoxy(0,8);
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	printf("               \n");
	gotoxy(0,8);
	printf("lrate=%f lrate2=%f lrate3=%f lrate4=%f\n",lrate,lrate2,lrate3,lrate4);
	printf("tracelength=%d length2=%d length3=%d length4=%d\n",tracelength,tracelength2,tracelength3,tracelength4);
	printf("offset2=%d offset3=%d offset4=%d\n",f2,f3,f4);
	printf("long days held=%d\n",maxhold);
	printf("short days held=%d\n",smaxhold);
	printf("future look = %d\n",flook);
	printf("Buy threshold = %f\n",longthresh*100.0);
	printf("Sell threshold = %f\n",shortthresh*100.0);
	printf("Forecast scale factor = %f\n",fsf);
	printf("Lots per trade = %d\n",lotspertrade);
        printf("Purity thresh = %f\n",puritythresh);
	printf("Maximum lots allowed = %d\n",maxlots);
	}
	return(1);
	}




decode_best()            // decode params of best parent chrom
	{
     int x;
	lrate=besteverchrom[0][0]/4000000.0;
	tracelength=besteverchrom[0][1]/(32000);
	if(tracelength == 0)
		tracelength=1;
	for(x=0;x<MAXDIST*8;x++)
		{
		mapscale[x]=besteverchrom[0][31+x]/(32000/gcmapscale);
                dayweight[x]=(float)(besteverchrom[0][31+x]/32766.0);
                }
	lrate2=besteverchrom[0][14]/4000000.0;
	tracelength2=besteverchrom[0][15]/(32000);
	if(tracelength2 == 0)
		tracelength2=1;
	
	lrate3=besteverchrom[0][17]/4000000.0;
	tracelength3=besteverchrom[0][18]/(32000);
	if(tracelength3 == 0)
		tracelength3=1;
	
	lrate4=besteverchrom[0][20]/4000000.0;
	tracelength4=besteverchrom[0][21]/(32000);
	if(tracelength4 == 0)
		tracelength4=1;
	
	flook=besteverchrom[0][3]/1000;
	if(flook == 0)
		flook=1;
	maxhold=besteverchrom[0][4]/(32000/gcmaxhold);
	if(maxhold == 0)
		maxhold=1;
	smaxhold=maxhold; // was besteverchrom[0][23]/(32000/gcsmaxhold);
	if(smaxhold == 0)
		smaxhold=1;
        ft1=besteverchrom[0][24]/1000;
        if(ft1<1) ft1=1;
        ft2=besteverchrom[0][28]/327;
        ft3=besteverchrom[0][29]/327;
        gft2=(float)ft2/20.0;
        gft3=(float)ft3/20.0;

	ft4=besteverchrom[0][30]/5000;
	f2=besteverchrom[0][25]/1000;
	f3=besteverchrom[0][26]/1000;
	f4=besteverchrom[0][27]/1000;
        longthresh=besteverchrom[0][5]/3000000.0;
        if(longthresh<.005)
                longthresh=.005;

	shortthresh=-longthresh;
	maxpass=besteverchrom[0][7]/(32000/gcmaxpass);
	if(maxpass == 0)
		maxpass=1;
	fsf=besteverchrom[0][8]/(32000/gcfsf);
	if(fsf < 1.0)
	fsf=1.0;
	stopthresh=besteverchrom[0][9]/(32000/gcstopthresh);
	if(stopthresh < minstopthresh)
		stopthresh=minstopthresh;
	rthresh=besteverchrom[0][10]/(32000/gcrthresh);
	lotspertrade=besteverchrom[0][11]/(32000/gclotspertrade);
	if(lotspertrade == 0)
		lotspertrade=1;
	maxlots=besteverchrom[0][12]/(32000/gcmaxlots);
	if(maxlots == 0)
		maxlots=1;
	maxreentry=besteverchrom[0][13]/(32000/gcmaxreentry);
	return(1);
	}


decode_bestoos()            // decode params of best oos chrom
	{
     int x;
	lrate=bestoos[0][0]/4000000.0;
	tracelength=bestoos[0][1]/(32000);
	if(tracelength == 0)
		tracelength=1;
	for(x=0;x<MAXDIST*8;x++)
		{
		mapscale[x]=bestoos[0][31+x]/(32000/gcmapscale);
                dayweight[x]=(float)(bestoos[0][31+x]/32766.0);
		}
	lrate2=bestoos[0][14]/4000000.0;
	tracelength2=bestoos[0][15]/(32000);
	if(tracelength2 == 0)
		tracelength2=1;
	
	lrate3=bestoos[0][17]/4000000.0;
	tracelength3=bestoos[0][18]/(32000);
	if(tracelength3 == 0)
		tracelength3=1;
	
	lrate4=bestoos[0][20]/4000000.0;
	tracelength4=bestoos[0][21]/(32000);
	if(tracelength4 == 0)
		tracelength4=1;
	
	flook=bestoos[0][3]/1000;
	if(flook == 0)
		flook=1;
	maxhold=bestoos[0][4]/(32000/gcmaxhold);
	if(maxhold == 0)
		maxhold=1;
	smaxhold=maxhold; // was bestoos[0][23]/(32000/gcsmaxhold);
	if(smaxhold == 0)
		smaxhold=1;
        ft1=bestoos[0][24]/1000;
        if(ft1<1) ft1=1;
        ft2=bestoos[0][28]/327;
        ft3=bestoos[0][29]/327;
        gft2=(float)ft2/20.0;
        gft3=(float)ft3/20.0;

	ft4=bestoos[0][30]/5000;
	f2=bestoos[0][25]/1000;
	f3=bestoos[0][26]/1000;
	f4=bestoos[0][27]/1000;
        longthresh=bestoos[0][5]/3000000.0;
        if(longthresh<.005)
                longthresh=.005;

	shortthresh=-longthresh;
	maxpass=bestoos[0][7]/(32000/gcmaxpass);
	if(maxpass == 0)
		maxpass=1;
	fsf=bestoos[0][8]/(32000/gcfsf);
	if(fsf < 1.0)
	fsf=1.0;
	stopthresh=bestoos[0][9]/(32000/gcstopthresh);
	if(stopthresh < minstopthresh)
		stopthresh=minstopthresh;
	rthresh=bestoos[0][10]/(32000/gcrthresh);
	lotspertrade=bestoos[0][11]/(32000/gclotspertrade);
	if(lotspertrade == 0)
		lotspertrade=1;
	maxlots=bestoos[0][12]/(32000/gcmaxlots);
	if(maxlots == 0)
		maxlots=1;
	maxreentry=bestoos[0][13]/(32000/gcmaxreentry);
	return(1);
	}




init_map()
	{
	int x,y;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			map[x][y]=0.0;
			map2[x][y]=0.0;
			map3[x][y]=0.0;
			}
		}
	return(1);
	}






zero_map()
	{
	int x,y;
        float winmax=-1000.0;
        float lossmax=-1000.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
                        if(map[x][y]>winmax)
                                winmax=map[x][y];
                        if(map2[x][y]>lossmax)
                                lossmax=map2[x][y];
			}
		}
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
                        if(map[x][y] < winmax*.05)
                                map[x][y]=0.0;
                        if(map2[x][y] < lossmax*.05)
                                map2[x][y]=0.0;
			}
		}
	return(1);
	}



fix_maps()
	{
	int x,y;
        for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
                        if(map[x][y]< 5.0)
                                map[x][y]=0.0;
                        if(map2[x][y]< 5.0)
                                map2[x][y]=0.0;
			}
		}
        return(1);  
	}






smooth()
        {
	int x,y;
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        tempmap[x][y]=(map[x][y]+map[x][y-1]+map[x][y+1])/3.0;
			}
		}
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        map[x][y]=tempmap[x][y];
			}
		}
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        tempmap[x][y]=(map2[x][y]+map2[x][y-1]+map2[x][y+1])/3.0;
			}
		}
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        map2[x][y]=tempmap[x][y];
			}
		}
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        tempmap[x][y]=(map3[x][y]+map3[x][y-1]+map3[x][y+1])/3.0;
			}
		}
	for(x=0;x<XSIZE;x++)
		{
                for(y=1;y<YSIZE-1;y++)
			{
                        map3[x][y]=tempmap[x][y];
			}
		}
	return(1);
	}








count_weights()             // count "active" map cells
	{
	int x,y;
	weightcount=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(map3[x][y]!=0.0)
				weightcount+=1.0;
			}
		}
	return(1);
	}



post_map()  // to view ratio's graphically
	{
	int x,y;
        for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
                        if(map[x][y] + map2[x][y] != 0.0)
				map3[x][y]=map[x][y]/(map[x][y]+map2[x][y])-.5;
			}
		}
	return(1);
	}





build_map()
	  {
          int ref,start,day;
          float chg;
          float sum,ave;
          ttp=0;
          twtp=0;
          tltp=0;
	  start=nod-((learn-foldshift)+foldwidth+(virg+foldshift)+hide);
	  if(start < 250)
		start=250;
	  for(ref=start;ref<nod-(virg+hide);ref++)
		{
		if(ref>=nod-(virg+foldshift+foldwidth+hide) && ref<nod-(virg+foldshift+hide))
			continue;  // skip over opt segment
		if(ref>=moosb && ref<=moose)
			continue;  //skip over middle oos segment
		if(ref>=moosb2 && ref<=moose2)
			continue;  //skip over second middle oos segment
                chg=(c[ref+trainflook]/c[ref]-1.0)*100.0;
                globalchg=chg;
                if(chg>=0.0)
                        {
                        twtp+=1;  // increment winning traces counter
                        }
                if(chg<0.0)
                        {
                        tltp+=1;
                        }
                }
          ttp=twtp+tltp;
	  start=nod-((learn-foldshift)+foldwidth+(virg+foldshift)+hide);
	  if(start < 250)
		start=250;
	  for(ref=start;ref<nod-(virg+hide);ref++)
		{
		if(ref>=nod-(virg+foldshift+foldwidth+hide) && ref<nod-(virg+foldshift+hide))
			continue;  // skip over opt segment
		if(ref>=moosb && ref<=moose)
			continue;  //skip over middle oos segment
		if(ref>=moosb2 && ref<=moose2)
			continue;  //skip over second middle oos segment
                chg=(c[ref+trainflook]/c[ref]-1.0)*100.0;
                globalchg=fabs(chg);
                if(chg>=puritythresh)
                        
                        fill_map1(ref);
                        
                if(chg < -puritythresh)
                        fill_map2(ref);  
                }
	  return(1);
	  }







        

fill_map1(ref)  // win, sum 1.0 into cells
	int ref;
	{
	int x,y;
        float chg=1.0;
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c2[ref-x]/c2[ref]-1.0)*mapscale[0] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c3[ref-x]/c3[ref]-1.0)*mapscale[1] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c4[ref-x]/c4[ref]-1.0)*mapscale[2] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c5[ref-x]/c5[ref]-1.0)*mapscale[3] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c6[ref-x]/c6[ref]-1.0)*mapscale[4] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c7[ref-x]/c7[ref]-1.0)*mapscale[5] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c8[ref-x]/c8[ref]-1.0)*mapscale[6] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c9[ref-x]/c9[ref]-1.0)*mapscale[7] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c10[ref-x]/c10[ref]-1.0)*mapscale[8] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c11[ref-x]/c11[ref]-1.0)*mapscale[9] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c12[ref-x]/c12[ref]-1.0)*mapscale[10] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c13[ref-x]/c13[ref]-1.0)*mapscale[11] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c14[ref-x]/c14[ref]-1.0)*mapscale[12] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c15[ref-x]/c15[ref]-1.0)*mapscale[13] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c16[ref-x]/c16[ref]-1.0)*mapscale[14] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c17[ref-x]/c17[ref]-1.0)*mapscale[15] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c18[ref-x]/c18[ref]-1.0)*mapscale[16] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c19[ref-x]/c19[ref]-1.0)*mapscale[17] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c20[ref-x]/c20[ref]-1.0)*mapscale[18] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c21[ref-x]/c21[ref]-1.0)*mapscale[19] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c22[ref-x]/c22[ref]-1.0)*mapscale[20] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c23[ref-x]/c23[ref]-1.0)*mapscale[21] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c24[ref-x]/c24[ref]-1.0)*mapscale[22] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c25[ref-x]/c25[ref]-1.0)*mapscale[23] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+140][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c26[ref-x]/c26[ref]-1.0)*mapscale[24] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c27[ref-x]/c27[ref]-1.0)*mapscale[25] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c28[ref-x]/c28[ref]-1.0)*mapscale[26] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c29[ref-x]/c29[ref]-1.0)*mapscale[27] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c30[ref-x]/c30[ref]-1.0)*mapscale[28] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c31[ref-x]/c31[ref]-1.0)*mapscale[29] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c32[ref-x]/c32[ref]-1.0)*mapscale[30] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c33[ref-x]/c33[ref]-1.0)*mapscale[31] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+140][y]+=chg;
                }


        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c34[ref-x]/c34[ref]-1.0)*mapscale[32] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c35[ref-x]/c35[ref]-1.0)*mapscale[33] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c36[ref-x]/c36[ref]-1.0)*mapscale[34] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c37[ref-x]/c37[ref]-1.0)*mapscale[35] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c38[ref-x]/c38[ref]-1.0)*mapscale[36] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c39[ref-x]/c39[ref]-1.0)*mapscale[37] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c40[ref-x]/c40[ref]-1.0)*mapscale[38] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c41[ref-x]/c41[ref]-1.0)*mapscale[39] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map[x+220][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c42[ref-x]/c42[ref]-1.0)*mapscale[40] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c43[ref-x]/c43[ref]-1.0)*mapscale[41] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c44[ref-x]/c44[ref]-1.0)*mapscale[42] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c45[ref-x]/c45[ref]-1.0)*mapscale[43] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c46[ref-x]/c46[ref]-1.0)*mapscale[44] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c47[ref-x]/c47[ref]-1.0)*mapscale[45] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c48[ref-x]/c48[ref]-1.0)*mapscale[46] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c49[ref-x]/c49[ref]-1.0)*mapscale[47] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map[x+220][y]+=chg;
                }




        //   +++++++++++++++++++++++++

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c50[ref-x]/c50[ref]-1.0)*mapscale[48] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c51[ref-x]/c51[ref]-1.0)*mapscale[49] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c52[ref-x]/c52[ref]-1.0)*mapscale[50] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c53[ref-x]/c53[ref]-1.0)*mapscale[51] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c54[ref-x]/c54[ref]-1.0)*mapscale[52] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c55[ref-x]/c55[ref]-1.0)*mapscale[53] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c56[ref-x]/c56[ref]-1.0)*mapscale[54] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c57[ref-x]/c57[ref]-1.0)*mapscale[55] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c58[ref-x]/c58[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c59[ref-x]/c59[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c60[ref-x]/c60[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c61[ref-x]/c61[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c62[ref-x]/c62[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c63[ref-x]/c63[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c64[ref-x]/c64[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c65[ref-x]/c65[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c66[ref-x]/c66[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c67[ref-x]/c67[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c68[ref-x]/c68[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c69[ref-x]/c69[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c70[ref-x]/c70[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c71[ref-x]/c71[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c72[ref-x]/c72[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c73[ref-x]/c73[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+140][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c74[ref-x]/c74[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c75[ref-x]/c75[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c76[ref-x]/c76[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c77[ref-x]/c77[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c78[ref-x]/c78[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c79[ref-x]/c79[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c80[ref-x]/c80[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c81[ref-x]/c81[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+140][y]+=chg;
                }


        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c82[ref-x]/c82[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c83[ref-x]/c83[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c84[ref-x]/c84[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c85[ref-x]/c85[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c86[ref-x]/c86[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c87[ref-x]/c87[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c88[ref-x]/c88[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c89[ref-x]/c89[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map[x+220][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c90[ref-x]/c90[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c91[ref-x]/c91[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c92[ref-x]/c92[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c93[ref-x]/c93[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c94[ref-x]/c94[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c95[ref-x]/c95[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c96[ref-x]/c96[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c97[ref-x]/c97[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map[x+220][y]+=chg;
                }







        return(1);
        }

 //+++++++++++++++++++++++++++++++



 

fill_map2(ref)  // loss, sum 1.0 into cells
	int ref;
	{
	int x,y;
        float chg=1.0;
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c2[ref-x]/c2[ref]-1.0)*mapscale[0] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c3[ref-x]/c3[ref]-1.0)*mapscale[1] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c4[ref-x]/c4[ref]-1.0)*mapscale[2] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c5[ref-x]/c5[ref]-1.0)*mapscale[3] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c6[ref-x]/c6[ref]-1.0)*mapscale[4] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c7[ref-x]/c7[ref]-1.0)*mapscale[5] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c8[ref-x]/c8[ref]-1.0)*mapscale[6] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c9[ref-x]/c9[ref]-1.0)*mapscale[7] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c10[ref-x]/c10[ref]-1.0)*mapscale[8] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c11[ref-x]/c11[ref]-1.0)*mapscale[9] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c12[ref-x]/c12[ref]-1.0)*mapscale[10] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c13[ref-x]/c13[ref]-1.0)*mapscale[11] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c14[ref-x]/c14[ref]-1.0)*mapscale[12] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c15[ref-x]/c15[ref]-1.0)*mapscale[13] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c16[ref-x]/c16[ref]-1.0)*mapscale[14] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c17[ref-x]/c17[ref]-1.0)*mapscale[15] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c18[ref-x]/c18[ref]-1.0)*mapscale[16] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c19[ref-x]/c19[ref]-1.0)*mapscale[17] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c20[ref-x]/c20[ref]-1.0)*mapscale[18] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c21[ref-x]/c21[ref]-1.0)*mapscale[19] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c22[ref-x]/c22[ref]-1.0)*mapscale[20] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c23[ref-x]/c23[ref]-1.0)*mapscale[21] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c24[ref-x]/c24[ref]-1.0)*mapscale[22] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c25[ref-x]/c25[ref]-1.0)*mapscale[23] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+140][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c26[ref-x]/c26[ref]-1.0)*mapscale[24] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c27[ref-x]/c27[ref]-1.0)*mapscale[25] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c28[ref-x]/c28[ref]-1.0)*mapscale[26] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c29[ref-x]/c29[ref]-1.0)*mapscale[27] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c30[ref-x]/c30[ref]-1.0)*mapscale[28] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c31[ref-x]/c31[ref]-1.0)*mapscale[29] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c32[ref-x]/c32[ref]-1.0)*mapscale[30] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c33[ref-x]/c33[ref]-1.0)*mapscale[31] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+140][y]+=chg;
                }


        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c34[ref-x]/c34[ref]-1.0)*mapscale[32] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c35[ref-x]/c35[ref]-1.0)*mapscale[33] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c36[ref-x]/c36[ref]-1.0)*mapscale[34] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c37[ref-x]/c37[ref]-1.0)*mapscale[35] +CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                map2[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c38[ref-x]/c38[ref]-1.0)*mapscale[36] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c39[ref-x]/c39[ref]-1.0)*mapscale[37] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c40[ref-x]/c40[ref]-1.0)*mapscale[38] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c41[ref-x]/c41[ref]-1.0)*mapscale[39] +CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                map2[x+220][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c42[ref-x]/c42[ref]-1.0)*mapscale[40] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c43[ref-x]/c43[ref]-1.0)*mapscale[41] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c44[ref-x]/c44[ref]-1.0)*mapscale[42] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c45[ref-x]/c45[ref]-1.0)*mapscale[43] +CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                map2[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c46[ref-x]/c46[ref]-1.0)*mapscale[44] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c47[ref-x]/c47[ref]-1.0)*mapscale[45] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c48[ref-x]/c48[ref]-1.0)*mapscale[46] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c49[ref-x]/c49[ref]-1.0)*mapscale[47] +CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                map2[x+220][y]+=chg;
                }




        //   +++++++++++++++++++++++++

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c50[ref-x]/c50[ref]-1.0)*mapscale[48] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c51[ref-x]/c51[ref]-1.0)*mapscale[49] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c52[ref-x]/c52[ref]-1.0)*mapscale[50] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c53[ref-x]/c53[ref]-1.0)*mapscale[51] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c54[ref-x]/c54[ref]-1.0)*mapscale[52] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c55[ref-x]/c55[ref]-1.0)*mapscale[53] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c56[ref-x]/c56[ref]-1.0)*mapscale[54] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c57[ref-x]/c57[ref]-1.0)*mapscale[55] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c58[ref-x]/c58[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c59[ref-x]/c59[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c60[ref-x]/c60[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c61[ref-x]/c61[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+60][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c62[ref-x]/c62[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c63[ref-x]/c63[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+20][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c64[ref-x]/c64[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+40][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c65[ref-x]/c65[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+60][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c66[ref-x]/c66[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c67[ref-x]/c67[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c68[ref-x]/c68[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c69[ref-x]/c69[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c70[ref-x]/c70[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c71[ref-x]/c71[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c72[ref-x]/c72[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c73[ref-x]/c73[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+140][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c74[ref-x]/c74[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c75[ref-x]/c75[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c76[ref-x]/c76[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c77[ref-x]/c77[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+140][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c78[ref-x]/c78[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+80][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c79[ref-x]/c79[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+100][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c80[ref-x]/c80[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+120][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c81[ref-x]/c81[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+140][y]+=chg;
                }


        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c82[ref-x]/c82[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c83[ref-x]/c83[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c84[ref-x]/c84[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c85[ref-x]/c85[ref]-1.0)*mapscale[0] +CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                map2[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c86[ref-x]/c86[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c87[ref-x]/c87[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c88[ref-x]/c88[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c89[ref-x]/c89[ref]-1.0)*mapscale[0] +CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                map2[x+220][y]+=chg;
                }

        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c90[ref-x]/c90[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c91[ref-x]/c91[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c92[ref-x]/c92[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c93[ref-x]/c93[ref]-1.0)*mapscale[0] +CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                map2[x+220][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c94[ref-x]/c94[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+160][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c95[ref-x]/c95[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+180][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c96[ref-x]/c96[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+200][y]+=chg;
                }
        for(x=0;x<gcmaxsamples;x++)
                {
                y=(c97[ref-x]/c97[ref]-1.0)*mapscale[0] +CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                map2[x+220][y]+=chg;
                }


        return(1);
        }

 //+++++++++++++++++++++++++++++++


































c_perfn(ref)
	int ref;
	{
	int x,y;
        float p,n,factor,val;
        float win,loss,pofa,pofb,pofbga;
        globalsum=0.0;
        globalcount=0.0;
        sumnew=0.0;   //global
      //  c_trailstdev(ref);
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c2[ref-x]/c2[ref]-1.0)*mapscale[0]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        pofa=.54; // raw P(A)
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;
                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c3[ref-x]/c3[ref]-1.0)*mapscale[1]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c4[ref-x]/c4[ref]-1.0)*mapscale[2]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c5[ref-x]/c5[ref]-1.0)*mapscale[3]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c6[ref-x]/c6[ref]-1.0)*mapscale[4]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c7[ref-x]/c7[ref]-1.0)*mapscale[5]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c8[ref-x]/c8[ref]-1.0)*mapscale[6]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c9[ref-x]/c9[ref]-1.0)*mapscale[7]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c10[ref-x]/c10[ref]-1.0)*mapscale[8]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c11[ref-x]/c11[ref]-1.0)*mapscale[9]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c12[ref-x]/c12[ref]-1.0)*mapscale[10]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c13[ref-x]/c13[ref]-1.0)*mapscale[11]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c14[ref-x]/c14[ref]-1.0)*mapscale[12]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c15[ref-x]/c15[ref]-1.0)*mapscale[13]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c16[ref-x]/c16[ref]-1.0)*mapscale[14]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c17[ref-x]/c17[ref]-1.0)*mapscale[15]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c18[ref-x]/c18[ref]-1.0)*mapscale[16]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c19[ref-x]/c19[ref]-1.0)*mapscale[17]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c20[ref-x]/c20[ref]-1.0)*mapscale[18]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c21[ref-x]/c21[ref]-1.0)*mapscale[19]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c22[ref-x]/c22[ref]-1.0)*mapscale[20]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c23[ref-x]/c23[ref]-1.0)*mapscale[21]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c24[ref-x]/c24[ref]-1.0)*mapscale[22]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c25[ref-x]/c25[ref]-1.0)*mapscale[23]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c26[ref-x]/c26[ref]-1.0)*mapscale[24]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c27[ref-x]/c27[ref]-1.0)*mapscale[25]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c28[ref-x]/c28[ref]-1.0)*mapscale[26]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c29[ref-x]/c29[ref]-1.0)*mapscale[27]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c30[ref-x]/c30[ref]-1.0)*mapscale[28]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c31[ref-x]/c31[ref]-1.0)*mapscale[29]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c32[ref-x]/c32[ref]-1.0)*mapscale[30]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c33[ref-x]/c33[ref]-1.0)*mapscale[31]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c34[ref-x]/c34[ref]-1.0)*mapscale[32]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c35[ref-x]/c35[ref]-1.0)*mapscale[33]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c36[ref-x]/c36[ref]-1.0)*mapscale[34]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c37[ref-x]/c37[ref]-1.0)*mapscale[35]+CENTER1;
                if(y > CENTER1+49)
                        y=CENTER1+49;
                if( y < CENTER1-49)
                        y=CENTER1-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c38[ref-x]/c38[ref]-1.0)*mapscale[36]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c39[ref-x]/c39[ref]-1.0)*mapscale[37]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c40[ref-x]/c40[ref]-1.0)*mapscale[38]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c41[ref-x]/c41[ref]-1.0)*mapscale[39]+CENTER2;
                if(y > CENTER2+49)
                        y=CENTER2+49;
                if( y < CENTER2-49)
                        y=CENTER2-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c42[ref-x]/c42[ref]-1.0)*mapscale[40]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c43[ref-x]/c43[ref]-1.0)*mapscale[41]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c44[ref-x]/c44[ref]-1.0)*mapscale[42]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c45[ref-x]/c45[ref]-1.0)*mapscale[43]+CENTER3;
                if(y > CENTER3+49)
                        y=CENTER3+49;
                if( y < CENTER3-49)
                        y=CENTER3-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c46[ref-x]/c46[ref]-1.0)*mapscale[44]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c47[ref-x]/c47[ref]-1.0)*mapscale[45]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c48[ref-x]/c48[ref]-1.0)*mapscale[46]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c49[ref-x]/c49[ref]-1.0)*mapscale[47]+CENTER4;
                if(y > CENTER4+49)
                        y=CENTER4+49;
                if( y < CENTER4-49)
                        y=CENTER4-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        //   ++++++++++++++++++++++++++


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c50[ref-x]/c50[ref]-1.0)*mapscale[48]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        pofa=.54; // raw P(A)
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;
                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c51[ref-x]/c51[ref]-1.0)*mapscale[49]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c52[ref-x]/c52[ref]-1.0)*mapscale[50]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c53[ref-x]/c53[ref]-1.0)*mapscale[51]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c54[ref-x]/c54[ref]-1.0)*mapscale[52]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c55[ref-x]/c55[ref]-1.0)*mapscale[53]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c56[ref-x]/c56[ref]-1.0)*mapscale[54]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c57[ref-x]/c57[ref]-1.0)*mapscale[55]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c58[ref-x]/c58[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c59[ref-x]/c59[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c60[ref-x]/c60[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c61[ref-x]/c61[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c62[ref-x]/c62[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x][y];
                loss=map2[x][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c63[ref-x]/c63[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+20][y];
                loss=map2[x+20][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c64[ref-x]/c64[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+40][y];
                loss=map2[x+40][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c65[ref-x]/c65[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+60][y];
                loss=map2[x+60][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c66[ref-x]/c66[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c67[ref-x]/c67[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c68[ref-x]/c68[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c69[ref-x]/c69[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c70[ref-x]/c70[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c71[ref-x]/c71[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c72[ref-x]/c72[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c73[ref-x]/c73[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c74[ref-x]/c74[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c75[ref-x]/c75[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c76[ref-x]/c76[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c77[ref-x]/c77[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c78[ref-x]/c78[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+80][y];
                loss=map2[x+80][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c79[ref-x]/c79[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+100][y];
                loss=map2[x+100][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c80[ref-x]/c80[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+120][y];
                loss=map2[x+120][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c81[ref-x]/c81[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+140][y];
                loss=map2[x+140][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c82[ref-x]/c82[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c83[ref-x]/c83[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c84[ref-x]/c84[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c85[ref-x]/c85[ref]-1.0)*mapscale[0]+CENTER5;
                if(y > CENTER5+49)
                        y=CENTER5+49;
                if( y < CENTER5-49)
                        y=CENTER5-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c86[ref-x]/c86[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c87[ref-x]/c87[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c88[ref-x]/c88[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c89[ref-x]/c89[ref]-1.0)*mapscale[0]+CENTER6;
                if(y > CENTER6+49)
                        y=CENTER6+49;
                if( y < CENTER6-49)
                        y=CENTER6-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }


        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c90[ref-x]/c90[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c91[ref-x]/c91[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c92[ref-x]/c92[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c93[ref-x]/c93[ref]-1.0)*mapscale[0]+CENTER7;
                if(y > CENTER7+49)
                        y=CENTER7+49;
                if( y < CENTER7-49)
                        y=CENTER7-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }

        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c94[ref-x]/c94[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+160][y];
                loss=map2[x+160][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c95[ref-x]/c95[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+180][y];
                loss=map2[x+180][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c96[ref-x]/c96[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+200][y];
                loss=map2[x+200][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }
        for(x=0;x<=gcmaxsamples;x++)
                {
                y=(c97[ref-x]/c97[ref]-1.0)*mapscale[0]+CENTER8;
                if(y > CENTER8+49)
                        y=CENTER8+49;
                if( y < CENTER8-49)
                        y=CENTER8-49;
                win=map[x+220][y];
                loss=map2[x+220][y];
                if((win+loss) >= 1.0 )
                        {
                        
                        pofb=(win+loss)/ttp; // P(B)
                        pofbga=win/twtp;     // P(B|A)
                        val=(pofa*pofbga/pofb); // Bayes applied
                        globalsum+=val;
                        globalcount+=1.0;

                        }
                else
                        sumnew+=1.0;
                }




        if(globalcount != 0.0)
                {
                predraw[ref]=globalsum/globalcount;   // raw .pred
                }
	else
		predraw[ref]=0.0;
	sumnewcells[ref]=sumnew;
	return(1);
	}













calc_fitness_offspring()
	{
	int ref;
	int days=0;
	int genenum;
	int maxeverdd=0;
	int maxddall=-1;
	float returns=0.0;
	float sterlall;
	float count,sum;
	float segfitness;
        float win=0.0;
        float loss=0.0;
	maxeverdd=-10;
	count=0.0;
	sum=0.0;
	if(fold == 1)
		{
		optreturns2=0.0;
		virgreturns2=0.0;
		frontoos[ocount]=0.0;
		moos[ocount]=0.0;
		moos2[ocount]=0.0;
		}
	optreturns2+=((account[nod-((virg+foldshift)+hide)]-account[nod-(hide+(virg+foldshift)+foldwidth)])/(float)(foldwidth)); // pts per day, over opt segment
	virgreturns2+=(account[nod]-account[nod-(virg+hide)])/(float)(virg+hide);  // pts per day, over verification segment
	frontoos[ocount]+=(account[nod-(hide+virg+foldwidth+learn)]-account[simstart])/(float)((nod-(hide+virg+foldwidth+learn))-simstart);
	moos[ocount]+=(account[moose]-account[moosb])/(moose-moosb);
	moos2[ocount]+=(account[moose2]-account[moosb2])/(moose2-moosb2);
	if(mdd20a < maxeverdd)
		maxeverdd=mdd20a;
	if(mdd60a < maxeverdd)
		maxeverdd=mdd60a;
	if(mdd120a < maxeverdd)
		maxeverdd=mdd120a;
	if(mdd20 < maxddall)
		maxddall=mdd20;
	if(mdd60 < maxddall)
		maxddall=mdd60;
	if(mdd120 < maxddall)
		maxddall=mdd120;
	sterlall=(((account[simstop]-account[simstart])/(simstop-simstart)))/-maxddall;
	if(lotcount < mltq )
		sterlall=0.0;
	if(sterlall > bsad)
		{
		bsad=sterlall;
		}
	check_activity();
	if(fold == 1)
		fitness_offspring=0.0;
	for(ref=nod-(hide+virg+foldshift+foldwidth);ref<=nod-(virg+foldshift+hide);ref++)
		{
          if(ref >= moosb2 && ref <= moose2)
			continue; // middle oos segment2
		if(ref >= moosb && ref <= moose)
			continue; // middle oos segment
                if(account[ref]>account[ref-1])   // win
                        win+=1.0;
                else
                        loss+=1.0;
                fitness_offspring+=account[ref]-account[ref-1];
		}
  //      fitness_offspring=win/(win+loss);
	c_prdcontained();
	printf("Offspring fitness=%2.4f;max idle:%d days;weights used=%5.0f\n",fitness_offspring,maxdeadrun,weightcount);
	printf("\n");
        if(fold == 10)
     	{
		vf[ocount]=virgreturns2;
		oosf[ocount]=optreturns2;
		oosfitness_offspring=optreturns2;
		if(fitness_offspring > bestalltime)
			{
			bestalltime=fitness_offspring;
			for(genenum=0;genenum<MAXGENES;genenum++)
				 besteverchrom[0][genenum]=offspring[genenum];
			}
		printf("Best Fitness over Opt. data: %f Best Fitness over All data: %f\n",bestalltime,bsad);
		printf("           Hit 'x' to stop evolution.\n");
		printf("           Hit 't' to toggle graphics.\n");
		printf("           Hit 'p' to pause.........\n");
		printf("           Hit 'v' to view individual trial solutions\n");
		printf("           Hit 's' to adjust return stream graphics scale.\n");
		printf("           Hit 'z' to scale scattergram.\n");
		printf("           Hit 'a' to advance to next random seeding\n");  
		printf("           Hit 'h' to toggle hidden data in/out of view.\n");
		}
	return(1);
	}



calc_fitness_competitor()   // used only during pop initialization and mutation
	{
	int ref;
	int days=0;
	int genenum;
	int maxeverdd=0;
	int maxddall=-1;
	float optreturns;
	float returns=0.0;
	float sterlall;
	float segfitness;
        float win=0.0;
        float loss=0.0;
	maxeverdd=-10;
	if(fold == 1)
		optreturns = 0.0;
	optreturns+=((account[nod-((virg+foldshift)+hide)]-account[nod-(hide+(virg+foldshift)+foldwidth)])/(float)foldwidth); // ave pts per day, won over opt segment
	if(mdd20a < maxeverdd)
		maxeverdd=mdd20a;
	if(mdd60a < maxeverdd)
		maxeverdd=mdd60a;
	if(mdd120a < maxeverdd)
		maxeverdd=mdd120a;
	if(mdd20 < maxddall)
		maxddall=mdd20;
	if(mdd60 < maxddall)
		maxddall=mdd60;
	if(mdd120 < maxddall)
		maxddall=mdd120;
	sterlall=(((account[simstop]-account[simstart])/(simstop-simstart)))/-maxddall;
	if(lotcount < mltq )
		sterlall=0.0;
	if(sterlall > bsad)
		{
		bsad=sterlall;
		}
	check_activity();
	if(fold == 1)
		fitness_competitor=0.0;
	for(ref=nod-(hide+virg+foldshift+foldwidth);ref<=nod-(virg+foldshift+hide);ref++)
		{
		if(ref >= moosb2 && ref <= moose2)
			continue; // middle oos segment2
		if(ref >= moosb && ref <= moose)
			continue; // middle oos segment
                if(account[ref]>account[ref-1])
                        win+=1.0;
                else
                        loss+=1.0;
                fitness_competitor+=account[ref]-account[ref-1];
		}
    //    fitness_competitor=win/(win+loss);
	c_prdcontained();
	printf("Max idle:%d days;weights used=%5.0f\n",maxdeadrun,weightcount);
	printf("\n");
        if(fold == 10)
     	{
		fitness[competitor_ss]=fitness_competitor;
		oosfitness[competitor_ss]=optreturns;
		if(fitness_competitor > bestalltime)
			{
			bestalltime=fitness_competitor;
			for(genenum=0;genenum<MAXGENES;genenum++)
				 besteverchrom[0][genenum]=parent[competitor_ss][genenum];
			}
		printf("Best Fitness over Opt. data: %f Best Fitness over All data: %f\n",bestalltime,bsad);
		}
	return(1);
	}






check_activity()
	{
	int x;
	int same=0;
	maxdeadrun=0;
	for(x=simstart+1;x<nod-1;x++)
		{
		if(account[x] == account[x-1])
			{
			++same;    // ie no trade
			if(same > maxdeadrun)
				maxdeadrun=same;
			}
		else
			same=0;
		}
	return(1);
	}


havesex()
	{
	int mothercomp1;
	int mothercomp2;
	int motherss;
	int fathercomp1;
	int fathercomp2;
	int fatherss;
	int genenum;
	int breakpt;
	breakpt=rand()/(32766/MAXGENES);
	mothercomp1=rand()/(32766/MAXPOPULATION);
	if(mothercomp1 < 0)
		  mothercomp1 = 0;
	if(mothercomp1 > MAXPOPULATION-1)
		  mothercomp1 = MAXPOPULATION-1;
	fathercomp1=rand()/(32766/MAXPOPULATION);
	if(fathercomp1 < 0)
		  fathercomp1 = 0;
	if(fathercomp1 > MAXPOPULATION-1)
		  fathercomp1 = MAXPOPULATION-1;
	mothercomp2=rand()/(32766/MAXPOPULATION);
	if(mothercomp2 < 0)
		  mothercomp2 = 0;
	if(mothercomp2 > MAXPOPULATION-1)
		  mothercomp2 = MAXPOPULATION-1;
	fathercomp2=rand()/(32766/MAXPOPULATION);
	if(fathercomp2 < 0)
		  fathercomp2 = 0;
	if(fathercomp2 > MAXPOPULATION-1)
		  fathercomp2 = MAXPOPULATION-1;
	if(fitness[mothercomp1] >= fitness[mothercomp2])
		motherss=mothercomp1;
	else
		motherss=mothercomp2;
	if(fitness[fathercomp1] >= fitness[fathercomp2])
		fatherss=fathercomp1;
	else
		fatherss=fathercomp2;
	for(genenum=0;genenum<breakpt;genenum++)
		  { //  offspring inherits genes from mother
		  offspring[genenum]=parent[motherss][genenum];
		  }
	for(genenum=breakpt;genenum<MAXGENES;genenum++)
		  { //  offspring inherits genes from father
		  offspring[genenum]=parent[fatherss][genenum];
		  }
	// MUTATE SECTION
     for(genenum=0;genenum<MAXGENES;genenum++)
		  {
		  if(rand() < 32766*mutrate)
				{
				offspring[genenum]+=(rand()-1600);
                                if(genenum==5)
                                        offspring[5]+=20;
				if(offspring[genenum] > 32000)
					 offspring[genenum] = 32000;
				if(offspring[genenum] < 0)
					 offspring[genenum] = 0;
				}
		  }
	return(1);
	}


mutate()  //randomly mutates some citizen
    {     
	 int genenum;
	 mutatedflag=0;
	 competitor_ss=rand()/(32766/MAXPOPULATION);
	 if(competitor_ss < 0)
		  competitor_ss = 0;
	 if(competitor_ss > MAXPOPULATION-1)
		  competitor_ss = MAXPOPULATION-1;
	 if(competitor_ss == best_ss) // don't mutate best solution
		  return(1);
	 for(genenum=0;genenum<MAXGENES;genenum++)
		  {
		  if(rand() < 32766*mutrate)
				{
				mutatedflag=1;
				parent[competitor_ss][genenum]+=(rand()-1600);
				if(parent[competitor_ss][genenum] > 32000)
					 parent[competitor_ss][genenum] = 32000;
				if(parent[competitor_ss][genenum] < 0)
					 parent[competitor_ss][genenum] = 0;
				}
		  }
	 return(1);
	 }


init_pop()
	{
        int genenum;
        for(ss=0;ss<MAXPOPULATION;ss++)
		{
		for(genenum=0;genenum<MAXGENES;genenum++)
			{
                        parent[ss][genenum]=rand();
			}
		}
	return(1);
	}



draw_it()
	{
	char buffer[80];
	int x,y,xnew,ynew,iht,i,j;
	int gap;
        float gthresh;
	float xscale=200.0/XSIZE;
        float yscale=.10;
	int ystart=440;
	int xstart=220;
	float ht;
	int whichmap;
	char string[30];
        post_map();
	count_weights();
        printf("Enter map to draw: 1=Wins, 2=Losses, 3=W/L, 4=W-L, 5=W/Lthresh: ");
	gets(string);
	whichmap=atoi(string);
        if(whichmap==5)
                {
                printf("Enter min cell wins(1.0 to 100.0): ");
                gets(string);
                gthresh=atof(string);
                }
	_setcolor(15);
	_moveto(xstart,ystart);
	for(j=YSIZE-1;j>0;j--)
		{
                xnew=xstart+j*.5;
                ynew=ystart-(j*.5);
		_moveto(xnew,ynew);
		for(i=0;i<XSIZE;i++)
			{
                        ht=0.0;
			if(whichmap == 1)
				ht=map[i][j]*yscale*htscale;
			if(whichmap == 2)
				ht=map2[i][j]*yscale*htscale;
                        if(whichmap == 3)
                                ht=map3[i][j]*yscale*htscale*100.0;
			if(whichmap == 4)
				ht=(map[i][j]-map2[i][j])*yscale*htscale;
                        if(whichmap == 5)
                                {
                                if((map[i][j]) >= gthresh)
                                      ht=(map[i][j]-map2[i][j])*yscale*htscale;  
                                else
                                      ht=0.0;
                                }
			if(i == XSIZE-1 && j == YSIZE-1)
				ht=0.0;
			iht=ht;
			x=xnew-(i*xscale);
			y=ynew-iht;
			color=g_color(ht);
                        if(whichmap == 3 || whichmap == 4 || whichmap == 5)
				color=g2_color(ht);
			_setcolor(color);
			_lineto(x,y);
			}
		}
        _setcolor(YELLOW);
        _moveto(110,30); 
	_outgtext(istream2);
        _moveto(110,40);
	_outgtext(istream3);
        _moveto(110,50);
	_outgtext(istream4);
        _moveto(110,60);
	_outgtext(istream5);
        _moveto(110,70); 
	_outgtext(istream6);
        _moveto(110,80);
	_outgtext(istream7);
        _moveto(110,90);
	_outgtext(istream8);
        _moveto(110,100);
        _outgtext(istream9);
        _moveto(110,110); 
        _outgtext(istream21);
        _moveto(110,120);
        _outgtext(istream22);
        _moveto(110,130);
        _outgtext(istream23);
        _moveto(110,140);
        _outgtext(istream24);
        _moveto(110,150); 
        _outgtext(istream25);
        _moveto(110,160);
        _outgtext(istream26);
        _moveto(110,170);
        _outgtext(istream27);
        _moveto(110,180);
        _outgtext(istream28);   

        _moveto(520,160); 
        _outgtext(istream29);
        _moveto(520,170);
        _outgtext(istream30);
        _moveto(520,180);
        _outgtext(istream31);
        _moveto(520,190);
        _outgtext(istream32);
        _moveto(520,200); 
        _outgtext(istream33);
        _moveto(520,210);
        _outgtext(istream34);
        _moveto(520,220);
        _outgtext(istream35);
        _moveto(520,230);
        _outgtext(istream36);
        _moveto(520,240); 
        _outgtext(istream37);
        _moveto(520,250);
        _outgtext(istream38);
        _moveto(520,260);
        _outgtext(istream39);
        _moveto(520,270);
        _outgtext(istream40);
        _moveto(520,280); 
        _outgtext(istream41);
        _moveto(520,290);
        _outgtext(istream42);
        _moveto(520,300);
        _outgtext(istream43);
        _moveto(520,310);
        _outgtext(istream44);   

        _moveto(520,320);
        _outgtext(istream45);
        _moveto(520,330);
        _outgtext(istream46);
        _moveto(520,340);
        _outgtext(istream47);
        _moveto(520,350);
        _outgtext(istream48);
        _moveto(520,360);
        _outgtext(istream49);
        _moveto(520,370);
        _outgtext(istream50);
        _moveto(520,380);
        _outgtext(istream51);
        _moveto(520,390);
        _outgtext(istream52);
        _moveto(520,400);
        _outgtext(istream53);
        _moveto(520,410);
        _outgtext(istream54);
        _moveto(520,420);
        _outgtext(istream55);
        _moveto(520,430);
        _outgtext(istream56);
        _moveto(520,440);
        _outgtext(istream57);
        _moveto(520,450);
        _outgtext(istream58);
        _moveto(520,460);
        _outgtext(istream59);
        _moveto(520,470);
        _outgtext(istream60);




	return(1);
	}

draw_it2()
	{
	char buffer[80];
	int x,y,xnew,ynew,iht,i,j;
	int gap;
	float xscale=200.0/XSIZE;
        float yscale=.10;
        float gthresh;
	int ystart=440;
	int xstart=220;
	float ht;
	int whichmap;
	char string[30];
        post_map();
	count_weights();
        printf("Enter map to draw: 1=Wins, 2=Losses, 3=W/L, 4=W-L, 5=W/L thresh: ");
	gets(string);
	whichmap=atoi(string);
        if(whichmap==5)
                {
                printf("Enter minimum cell wins (1.0 to 100.0): ");
                gets(string);
                gthresh=atof(string);
                }
	_setcolor(15);
	_moveto(xstart,ystart);
	for(j=YSIZE-1;j>0;j--)
		{
                xnew=xstart+j*.5;
                ynew=ystart-(j*.5);
		_moveto(xnew,ynew);
		for(i=0;i<XSIZE;i++)
			{
                        ht=0.0;
			if(whichmap == 1)
				ht=map[i][j]*yscale*htscale;
			if(whichmap == 2)
				ht=map2[i][j]*yscale*htscale;
                        if(whichmap == 3)
                                ht=map3[i][j]*yscale*htscale*100.0;
			if(whichmap == 4)
				ht=(map[i][j]-map2[i][j])*yscale*htscale;
                        if(whichmap == 5)
                                {
                                if((map[i][j]) >= gthresh)
                                      ht=(map[i][j]-map2[i][j])*yscale*htscale;  
                                else
                                      ht=0.0;
                                }
                        if(i == XSIZE-1 && j == YSIZE-1)
				ht=0.0;
			iht=ht;
			x=xnew-(i*xscale);
			y=ynew-iht;
			color=g_color(ht);
			if(whichmap == 3 || whichmap == 4)
				color=g2_color(ht);
			_setcolor(color);
			_lineto(x,y);
			}
		}
        _setcolor(YELLOW);
        _moveto(110,30); 
	_outgtext(istream2);
        _moveto(110,40);
	_outgtext(istream3);
        _moveto(110,50);
	_outgtext(istream4);
        _moveto(110,60);
	_outgtext(istream5);
        _moveto(110,70); 
	_outgtext(istream6);
        _moveto(110,80);
	_outgtext(istream7);
        _moveto(110,90);
	_outgtext(istream8);
        _moveto(110,100);
        _outgtext(istream9);
        _moveto(110,110); 
        _outgtext(istream21);
        _moveto(110,120);
        _outgtext(istream22);
        _moveto(110,130);
        _outgtext(istream23);
        _moveto(110,140);
        _outgtext(istream24);
        _moveto(110,150); 
        _outgtext(istream25);
        _moveto(110,160);
        _outgtext(istream26);
        _moveto(110,170);
        _outgtext(istream27);
        _moveto(110,180);
        _outgtext(istream28);   
        _moveto(520,160); 
        _outgtext(istream29);
        _moveto(520,170);
        _outgtext(istream30);
        _moveto(520,180);
        _outgtext(istream31);
        _moveto(520,190);
        _outgtext(istream32);
        _moveto(520,200); 
        _outgtext(istream33);
        _moveto(520,210);
        _outgtext(istream34);
        _moveto(520,220);
        _outgtext(istream35);
        _moveto(520,230);
        _outgtext(istream36);
        _moveto(520,240); 
        _outgtext(istream37);
        _moveto(520,250);
        _outgtext(istream38);
        _moveto(520,260);
        _outgtext(istream39);
        _moveto(520,270);
        _outgtext(istream40);
        _moveto(520,280); 
        _outgtext(istream41);
        _moveto(520,290);
        _outgtext(istream42);
        _moveto(520,300);
        _outgtext(istream43);
        _moveto(520,310);
        _outgtext(istream44);   

        _moveto(520,320);
        _outgtext(istream45);
        _moveto(520,330);
        _outgtext(istream46);
        _moveto(520,340);
        _outgtext(istream47);
        _moveto(520,350);
        _outgtext(istream48);
        _moveto(520,360);
        _outgtext(istream49);
        _moveto(520,370);
        _outgtext(istream50);
        _moveto(520,380);
        _outgtext(istream51);
        _moveto(520,390);
        _outgtext(istream52);
        _moveto(520,400);
        _outgtext(istream53);
        _moveto(520,410);
        _outgtext(istream54);
        _moveto(520,420);
        _outgtext(istream55);
        _moveto(520,430);
        _outgtext(istream56);
        _moveto(520,440);
        _outgtext(istream57);
        _moveto(520,450);
        _outgtext(istream58);
        _moveto(520,460);
        _outgtext(istream59);
        _moveto(520,470);
        _outgtext(istream60);





	gets(string);
	return(1);
	}




g2_color(ht)
     float ht;
     {
     if(ht == 0)
		return(15);
	if(ht < -1)
		return(12);
	if(ht >= -1 && ht < 0)
		return(4);
	if(ht > 0 && ht <= 1)
		return(2);
	if(ht > 1) 
		return(10);
	return(0);
	}






g_color(ht)
     float ht;
     {
     if(ht == 0)
		return(15);
	if(ht > 0 && ht <= 2)
		return(2);
	if(ht > 2 && ht < 4)
		return(3);
	if(ht > 4 && ht < 6)
		return(4);
	if(ht > 6 && ht < 8)
		return(5);
	if(ht > 8 && ht < 10)
		return(6);
	if(ht > 10 && ht < 12)
		return(7);
	if(ht > 12 && ht < 14)
		return(8);
	if(ht > 14 && ht < 16)
		return(9);
	if(ht > 16 && ht < 18)
		return(10);
	if(ht > 18 && ht < 20)
		return(11);
	if(ht > 20 && ht < 22)
		return(12);
	if(ht > 22 && ht < 24)
		return(13);
	if(ht > 24 )
		return(14);
	return(0);
  	}


input_pop()
	{
	char string[30];
	int genenum;
	int x,y;
	float tmp;
	long ltmp;
	float ftmp;
	genenum=0;
	clrscr();
	system("dir *.pop");
	printf("\n\t\t\tEnter population filename: ");
	gets(string);
	prd=fopen(string,"r");
	if(prd == NULL)
		{
		printf("Can't open %s\n",string);
		delay(2000);
		return(1);
		}
	fscanf(prd,"%s\n",&istream1);
	fscanf(prd,"%s\n",&istream2);
	fscanf(prd,"%s\n",&istream3);
	fscanf(prd,"%s\n",&istream4);
	fscanf(prd,"%s\n",&istream5);
	fscanf(prd,"%s\n",&istream6);
	fscanf(prd,"%s\n",&istream7);
	fscanf(prd,"%s\n",&istream8);
	fscanf(prd,"%s\n",&istream9);
	fscanf(prd,"%ld\n",&ocount);
	fscanf(prd,"%d\n",&targtype);
	fscanf(prd,"%f\n",&bsad);
	fscanf(prd,"%f\n",&bestalltime);
	fscanf(prd,"%ld\n",&ltmp); // read gcmaxhold
	gcmaxhold=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read gcsmaxhold
	gcsmaxhold=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read gcmaxpass
	gcmaxpass=ltmp;
	fscanf(prd,"%f\n",&ftmp);  // read gcfsf
	gcfsf=ftmp;
	fscanf(prd,"%f\n",&ftmp);  // read gcstopthresh
	gcstopthresh=ftmp;
	fscanf(prd,"%f\n",&ftmp);  // read gcrthresh
	gcrthresh=ftmp;
	fscanf(prd,"%ld\n",&ltmp); // read gclotspertrade
	gclotspertrade=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read gcmaxlots
	gcmaxlots=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read gcmaxreentry
	gcmaxreentry=ltmp;
        fscanf(prd,"%f\n",&ftmp); // read puritythresh
        puritythresh=ftmp;
	fscanf(prd,"%ld\n",&ltmp); // read gcmapscale
	gcmapscale=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read virg
	virg=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read evoptdays
	evoptdays=ltmp;
	fscanf(prd,"%ld\n",&ltmp); // read tradertype
	tradertype=ltmp;
	fscanf(prd,"%f\n",&ftmp);  // read minstopthresh
	minstopthresh=ftmp;
	fscanf(prd,"%ld\n",&ltmp); // read nospreadflag
	nospreadflag=ltmp;
	fscanf(prd,"%ld\n",&ltmp);  // read trailing
	trailing=ltmp;
	fscanf(prd,"%d\n",&virg);
	fscanf(prd,"%d\n",&evoptdays);
	fscanf(prd,"%d\n",&gcmaxhold);
	fscanf(prd,"%ld\n",&gcsmaxhold);
	fscanf(prd,"%d\n",&gcmaxpass);
	fscanf(prd,"%d\n",&startgen);
	fscanf(prd,"%d\n",&startss);
	fscanf(prd,"%d\n",&tradertype);
	fscanf(prd,"%d\n",&maaapg);
	fscanf(prd,"%d\n",&max20);
	fscanf(prd,"%d\n",&max60);
	fscanf(prd,"%d\n",&max120);
	fscanf(prd,"%d\n",&max250);
	fscanf(prd,"%f\n",&ipc);
	fscanf(prd,"%f\n",&matpc);
	fscanf(prd,"%f\n",&opc);
	fscanf(prd,"%d\n",&seed);
	fscanf(prd,"%f\n",&minstopthresh);
	fscanf(prd,"%d\n",&trailing);
	fscanf(prd,"%d\n",&nospreadflag);
	for(ss=0;ss<MAXPOPULATION;ss++)
        {
		  fscanf(prd,"%f ",&ftmp);
		  fitness[ss]=ftmp;
        for(genenum=0;genenum<MAXGENES;genenum++)
            {
				fscanf(prd,"%ld ",&ltmp);
				parent[ss][genenum]=ltmp;
				}
		  fscanf(prd,"\n");
		  }
	fclose(prd);
	return(1);
	}


write_pop()
	{
	char string[30];
	int genenum=0;
	int x,y;
	long temp;
	float tmp;
	long ltmp;
	clrscr();
	system("dir *.pop");
	printf("\n\t\t\tEnter population filename: ");
	gets(string);
	prd=fopen(string,"w");
	if(prd == NULL)
		{
		printf("Can't open %s\n",string);
		delay(2000);
		return(1);
		}
	fprintf(prd,"%s\n",istream1);
	fprintf(prd,"%s\n",istream2);
	fprintf(prd,"%s\n",istream3);
	fprintf(prd,"%s\n",istream4);
	fprintf(prd,"%s\n",istream5);
	fprintf(prd,"%s\n",istream6);
	fprintf(prd,"%s\n",istream7);
	fprintf(prd,"%s\n",istream8);
	fprintf(prd,"%s\n",istream9);
	fprintf(prd,"%ld\n",ocount);
	fprintf(prd,"%d\n",targtype);
	fprintf(prd,"%f\n",bsad);
	fprintf(prd,"%f\n",bestalltime);
	fprintf(prd,"%ld\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%ld\n",gcmaxpass);
	fprintf(prd,"%f\n",gcfsf);
	fprintf(prd,"%f\n",gcstopthresh);
	fprintf(prd,"%f\n",gcrthresh);
	fprintf(prd,"%ld\n",gclotspertrade);
	fprintf(prd,"%ld\n",gcmaxlots);
	fprintf(prd,"%ld\n",gcmaxreentry);
        fprintf(prd,"%f\n",puritythresh);
	fprintf(prd,"%ld\n",gcmapscale);
	fprintf(prd,"%ld\n",virg);
	fprintf(prd,"%ld\n",evoptdays);
	fprintf(prd,"%ld\n",tradertype);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%ld\n",nospreadflag);
	fprintf(prd,"%ld\n",trailing);
	fprintf(prd,"%d\n",virg);
	fprintf(prd,"%d\n",evoptdays);
	fprintf(prd,"%d\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%d\n",gcmaxpass);
	fprintf(prd,"%d\n",startgen);
	fprintf(prd,"%d\n",startss);
	fprintf(prd,"%d\n",tradertype);
	fprintf(prd,"%d\n",maaapg);
	fprintf(prd,"%d\n",max20);
	fprintf(prd,"%d\n",max60);
	fprintf(prd,"%d\n",max120);
	fprintf(prd,"%d\n",max250);
	fprintf(prd,"%f\n",ipc);
	fprintf(prd,"%f\n",matpc);
	fprintf(prd,"%f\n",opc);
	fprintf(prd,"%d\n",seed);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%d\n",trailing);
	fprintf(prd,"%d\n",nospreadflag);
	for(ss=0;ss<MAXPOPULATION;ss++)
		  {
		  fprintf(prd,"%f ",fitness[ss]);
		  for(genenum=0;genenum<MAXGENES;genenum++)
				{
				fprintf(prd,"%ld ",parent[ss][genenum]);
				}
		  fprintf(prd,"\n");
		  }
	fclose(prd);
	clrscr();
	return(1);
	}


write_batchpop()
	{
	char string[40];
	int genenum=0;
	int x,y;
	long temp;
	float tmp;
	long ltmp;
	clrscr();
	itoa(mapnamecount,string,10);
	strcat(string,".pop");
	prd=fopen(string,"w");
	if(prd == NULL)
		{
		printf("Can't open %s\n",string);
		delay(2000);
		return(1);
		}
	fprintf(prd,"%s\n",istream1);
	fprintf(prd,"%s\n",istream2);
	fprintf(prd,"%s\n",istream3);
	fprintf(prd,"%s\n",istream4);
	fprintf(prd,"%s\n",istream5);
	fprintf(prd,"%s\n",istream6);
	fprintf(prd,"%s\n",istream7);
	fprintf(prd,"%s\n",istream8);
	fprintf(prd,"%s\n",istream9);
	fprintf(prd,"%ld\n",ocount);
	fprintf(prd,"%d\n",targtype);
	fprintf(prd,"%f\n",bsad);
	fprintf(prd,"%f\n",bestalltime);
	fprintf(prd,"%ld\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%ld\n",gcmaxpass);
	fprintf(prd,"%f\n",gcfsf);
	fprintf(prd,"%f\n",gcstopthresh);
	fprintf(prd,"%f\n",gcrthresh);
	fprintf(prd,"%ld\n",gclotspertrade);
	fprintf(prd,"%ld\n",gcmaxlots);
	fprintf(prd,"%ld\n",gcmaxreentry);
        fprintf(prd,"%f\n",puritythresh);
	fprintf(prd,"%ld\n",gcmapscale);
	fprintf(prd,"%ld\n",virg);
	fprintf(prd,"%ld\n",evoptdays);
	fprintf(prd,"%ld\n",tradertype);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%ld\n",nospreadflag);
	fprintf(prd,"%ld\n",trailing);
	fprintf(prd,"%d\n",virg);
	fprintf(prd,"%d\n",evoptdays);
	fprintf(prd,"%d\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%d\n",gcmaxpass);
	fprintf(prd,"%d\n",startgen);
	fprintf(prd,"%d\n",startss);
	fprintf(prd,"%d\n",tradertype);
	fprintf(prd,"%d\n",maaapg);
	fprintf(prd,"%d\n",max20);
	fprintf(prd,"%d\n",max60);
	fprintf(prd,"%d\n",max120);
	fprintf(prd,"%d\n",max250);
	fprintf(prd,"%f\n",ipc);
	fprintf(prd,"%f\n",matpc);
	fprintf(prd,"%f\n",opc);
	fprintf(prd,"%d\n",seed);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%d\n",trailing);
	fprintf(prd,"%d\n",nospreadflag);
	for(ss=0;ss<MAXPOPULATION;ss++)
		  {
		  fprintf(prd,"%f ",fitness[ss]);
		  for(genenum=0;genenum<MAXGENES;genenum++)
				{
				fprintf(prd,"%ld ",parent[ss][genenum]);
				}
		  fprintf(prd,"\n");
		  }
	fclose(prd);
	clrscr();
	return(1);
	}








read_map()
	{
	int x,y,ref,oldmode;
	char string[40];
	float tmp;
	float tmpcount;
	long ltmp;
	float count=0.0;
	float mark=.00001;
	float mark2=.00003;
	float bosmm=.00002;
          fn[0]=22.0;
          fn[1]=21.0;
          fn[2]=20.0;
          fn[3]=19.0;
          fn[4]=18.0;
          fn[5]=17.0;
          fn[6]=16.0;
          fn[7]=15.0;
          fn[8]=14.0;
          fn[9]=13.0;
          fn[10]=12.0;
          fn[11]=11.0;
          fn[12]=10.0;
          fn[13]=9.0;
          fn[14]=8.0;
          fn[15]=7.0;
          fn[16]=6.0;
          fn[17]=5.0;
          fn[18]=4.0;
          fn[19]=3.0;
          fn[20]=2.0;
          fn[21]=1.0;

        init_map();
	if(manualmode)
		{
          clrscr();
		system("dir *.map");
		printf("\n\t\t\tEnter map filename: ");
		gets(string);
		strcpy(imap,string);
		}
	prd=fopen(imap,"r");
	if(prd == NULL)
		{
		printf("Can't open %s\n",string);
		delay(2000);
		return(1);
		}
	ss=0;
	hidetoggle=1; // make visible
	fscanf(prd,"%s\n",&string);
	fscanf(prd,"%s\n",&istream1);
	fscanf(prd,"%s\n",&istream2);
	fscanf(prd,"%s\n",&istream3);
	fscanf(prd,"%s\n",&istream4);
	fscanf(prd,"%s\n",&istream5);
	fscanf(prd,"%s\n",&istream6);
	fscanf(prd,"%s\n",&istream7);
	fscanf(prd,"%s\n",&istream8);
	fscanf(prd,"%s\n",&istream9);
        fscanf(prd,"%s\n",&istream21);
        fscanf(prd,"%s\n",&istream22);
        fscanf(prd,"%s\n",&istream23);
        fscanf(prd,"%s\n",&istream24);
        fscanf(prd,"%s\n",&istream25);
        fscanf(prd,"%s\n",&istream26);
        fscanf(prd,"%s\n",&istream27);
        fscanf(prd,"%s\n",&istream28);
        fscanf(prd,"%s\n",&istream29);
        fscanf(prd,"%s\n",&istream30);
        fscanf(prd,"%s\n",&istream31);
        fscanf(prd,"%s\n",&istream32);
        fscanf(prd,"%s\n",&istream33);
        fscanf(prd,"%s\n",&istream34);
        fscanf(prd,"%s\n",&istream35);
        fscanf(prd,"%s\n",&istream36);
        fscanf(prd,"%s\n",&istream37);
        fscanf(prd,"%s\n",&istream38);
        fscanf(prd,"%s\n",&istream39);
        fscanf(prd,"%s\n",&istream40);
        fscanf(prd,"%s\n",&istream41);
        fscanf(prd,"%s\n",&istream42);
        fscanf(prd,"%s\n",&istream43);
        fscanf(prd,"%s\n",&istream44);

        fscanf(prd,"%s\n",&istream45);
        fscanf(prd,"%s\n",&istream46);
        fscanf(prd,"%s\n",&istream47);
        fscanf(prd,"%s\n",&istream48);
        fscanf(prd,"%s\n",&istream49);
        fscanf(prd,"%s\n",&istream50);
        fscanf(prd,"%s\n",&istream51);
        fscanf(prd,"%s\n",&istream52);
        fscanf(prd,"%s\n",&istream53);
        fscanf(prd,"%s\n",&istream54);
        fscanf(prd,"%s\n",&istream55);
        fscanf(prd,"%s\n",&istream56);
        fscanf(prd,"%s\n",&istream57);
        fscanf(prd,"%s\n",&istream58);
        fscanf(prd,"%s\n",&istream59);
        fscanf(prd,"%s\n",&istream60);

        fscanf(prd,"%s\n",&istream61);
        fscanf(prd,"%s\n",&istream62);
        fscanf(prd,"%s\n",&istream63);
        fscanf(prd,"%s\n",&istream64);
        fscanf(prd,"%s\n",&istream65);
        fscanf(prd,"%s\n",&istream66);
        fscanf(prd,"%s\n",&istream67);
        fscanf(prd,"%s\n",&istream68);
        fscanf(prd,"%s\n",&istream69);
        fscanf(prd,"%s\n",&istream70);
        fscanf(prd,"%s\n",&istream71);
        fscanf(prd,"%s\n",&istream72);
        fscanf(prd,"%s\n",&istream73);
        fscanf(prd,"%s\n",&istream74);
        fscanf(prd,"%s\n",&istream75);
        fscanf(prd,"%s\n",&istream76);
        fscanf(prd,"%s\n",&istream77);
        fscanf(prd,"%s\n",&istream78);
        fscanf(prd,"%s\n",&istream79);
        fscanf(prd,"%s\n",&istream80);
        fscanf(prd,"%s\n",&istream81);
        fscanf(prd,"%s\n",&istream82);
        fscanf(prd,"%s\n",&istream83);
        fscanf(prd,"%s\n",&istream84);
        fscanf(prd,"%s\n",&istream85);
        fscanf(prd,"%s\n",&istream86);
        fscanf(prd,"%s\n",&istream87);
        fscanf(prd,"%s\n",&istream88);
        fscanf(prd,"%s\n",&istream89);
        fscanf(prd,"%s\n",&istream90);
        fscanf(prd,"%s\n",&istream91);
        fscanf(prd,"%s\n",&istream92);
        fscanf(prd,"%s\n",&istream93);
        fscanf(prd,"%s\n",&istream94);
        fscanf(prd,"%s\n",&istream95);
        fscanf(prd,"%s\n",&istream96);
        fscanf(prd,"%s\n",&istream97);
        fscanf(prd,"%s\n",&istream98);
        fscanf(prd,"%s\n",&istream99);
        fscanf(prd,"%s\n",&istream100);
        fscanf(prd,"%s\n",&istream101);
        fscanf(prd,"%s\n",&istream102);
        fscanf(prd,"%s\n",&istream103);
        fscanf(prd,"%s\n",&istream104);
        fscanf(prd,"%s\n",&istream105);
        fscanf(prd,"%s\n",&istream106);
        fscanf(prd,"%s\n",&istream107);
        fscanf(prd,"%s\n",&istream108);









        fscanf(prd,"%d\n",&ttp);
        fscanf(prd,"%d\n",&twtp);
        fscanf(prd,"%d\n",&tltp);

	fscanf(prd,"%d\n",&hide);
	fscanf(prd,"%f\n",&scatterscale);
	fscanf(prd,"%f\n",&rss);
	fscanf(prd,"%d\n",&learn);
	fscanf(prd,"%d\n",&targtype);
	fscanf(prd,"%f\n",&bsad);
	fscanf(prd,"%f\n",&bestalltime);
	fscanf(prd,"%f\n",&mltq);
	fscanf(prd,"%d\n",&fittype);
	fscanf(prd,"%f\n",&mutrate);
	fscanf(prd,"%f\n",&maxweights);
	fscanf(prd,"%d\n",&ft1);
	fscanf(prd,"%d\n",&ft2);
	fscanf(prd,"%d\n",&ft3);
	fscanf(prd,"%d\n",&ft4);
	fscanf(prd,"%d\n",&f2);
	fscanf(prd,"%d\n",&f3);
	fscanf(prd,"%d\n",&f4);
	fscanf(prd,"%d\n",&flook);
	fscanf(prd,"%d\n",&virg);
	fscanf(prd,"%d\n",&evoptdays);
	fscanf(prd,"%d\n",&tracelength);
	fscanf(prd,"%f\n",&lrate);
	fscanf(prd,"%d\n",&tracelength2);
	fscanf(prd,"%f\n",&lrate2);
	fscanf(prd,"%d\n",&tracelength3);
	fscanf(prd,"%f\n",&lrate3);
	fscanf(prd,"%d\n",&tracelength4);
	fscanf(prd,"%f\n",&lrate4);
	fscanf(prd,"%d\n",&maxhold);
	fscanf(prd,"%d\n",&smaxhold);
	fscanf(prd,"%d\n",&gcmaxhold);
	fscanf(prd,"%ld\n",&gcsmaxhold);
	fscanf(prd,"%d\n",&maxlots);
	fscanf(prd,"%f\n",&longthresh);
	fscanf(prd,"%f\n",&shortthresh);
	fscanf(prd,"%d\n",&maxpass);
	fscanf(prd,"%f\n",&fsf);
	fscanf(prd,"%f\n",&stopthresh);
	fscanf(prd,"%f\n",&rthresh);
	fscanf(prd,"%d\n",&lotspertrade);
	fscanf(prd,"%d\n",&maxlots);
	fscanf(prd,"%d\n",&maxreentry);
	fscanf(prd,"%d\n",&gcmaxpass);
	fscanf(prd,"%f\n",&gcfsf);
	fscanf(prd,"%f\n",&gcstopthresh);
	fscanf(prd,"%f\n",&gcrthresh);
	fscanf(prd,"%d\n",&gclotspertrade);
	fscanf(prd,"%d\n",&gcmaxlots);
	fscanf(prd,"%d\n",&gcmaxreentry);
        fscanf(prd,"%f\n",&puritythresh);
	fscanf(prd,"%d\n",&gcmapscale);
	fscanf(prd,"%d\n",&gcmaxsamples);
	fscanf(prd,"%d\n",&gcmaxhist);
	fscanf(prd,"%d\n",&startgen);
	fscanf(prd,"%d\n",&startss);
	fscanf(prd,"%d\n",&tradertype);
	fscanf(prd,"%d\n",&maaapg);
	fscanf(prd,"%d\n",&max20);
	fscanf(prd,"%d\n",&max60);
	fscanf(prd,"%d\n",&max120);
	fscanf(prd,"%d\n",&max250);
	fscanf(prd,"%f\n",&ipc);
	fscanf(prd,"%f\n",&matpc);
	fscanf(prd,"%f\n",&opc);
	fscanf(prd,"%d\n",&seed);
	fscanf(prd,"%f\n",&minstopthresh);
	fscanf(prd,"%d\n",&trailing);
	fscanf(prd,"%d\n",&nospreadflag);
	fscanf(prd,"%f\n",&oosfitness[ss]);
	for(x=0;x<MAXDIST*8;x++)
		{
		fscanf(prd,"%d\n",&mapscale[x]);
                fscanf(prd,"%d\n",&dayweight[x]);
		}
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(count == 0.0)
				{
				fscanf(prd,"%f\n",&tmp);
				if(tmp == mark)  // found zero's marker
					{
					fscanf(prd,"%f\n",&tmpcount); // read in count
					count=tmpcount-1;
					map[x][y]=0.0;
					continue;
					}
				if(tmp != mark)
					{
					map[x][y]=tmp;
                         continue;
					}
				}
			if(count > 0.0)
				{
				map[x][y]=0.0;
				count=count-1.0;
				}
			}
		}
	for(x=0;x<1000;x++)
		{
		fscanf(prd,"%f\n",&tmp);
		if(tmp == bosmm)
			break;
		}
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(count == 0.0)
				{
				fscanf(prd,"%f\n",&tmp);
				if(tmp == mark)  // found zero's marker
					{
					fscanf(prd,"%f\n",&tmpcount); // read count
					count=tmpcount-1;
					map2[x][y]=0.0;
                         continue;
					}
				if(tmp != mark)
					{
					map2[x][y]=tmp;  // legit value
					continue;
					}
				}
			if(count > 0.0)
				{
				map2[x][y]=0.0;
				count=count-1.0;
				}
			}
		}
	for(x=0;x<1000;x++) // get past 0's to resync
		{
		fscanf(prd,"%f\n",&tmp);
		if(tmp == mark2)
			{
			break;
               }
		}
	fscanf(prd,"%d\n",&ocount);
	for(x=1;x<ocount;x++)
		{
		fscanf(prd,"%f\n",&tmp);
		vf[x]=tmp;
		}	
     for(x=1;x<ocount;x++)
		{
		fscanf(prd,"%f\n",&tmp);
          oosf[x]=tmp;
		}	
	fclose(prd);
	oldmode=manualmode;
	manualmode=0;
	rd_prices();
	rd_coorprices1();
	rd_coorprices2();
	rd_coorprices3();
	rd_coorprices4();
	rd_coorprices5();
	rd_coorprices6();
	rd_coorprices7();
	rd_coorprices8();
        rd_coorprices9();
        rd_coorprices10();
        rd_coorprices11();
        rd_coorprices12();
        rd_coorprices13();
        rd_coorprices14();
        rd_coorprices15();
        rd_coorprices16();
        rd_coorprices17();
        rd_coorprices18();
        rd_coorprices19();
        rd_coorprices20();
        rd_coorprices21();
        rd_coorprices22();
        rd_coorprices23();
        rd_coorprices24();
        rd_coorprices25();
        rd_coorprices26();
        rd_coorprices27();
        rd_coorprices28();
        rd_coorprices29();
        rd_coorprices30();
        rd_coorprices31();
        rd_coorprices32();
        rd_coorprices33();
        rd_coorprices34();
        rd_coorprices35();
        rd_coorprices36();
        rd_coorprices37();
        rd_coorprices38();
        rd_coorprices39();
        rd_coorprices40();
        rd_coorprices41();
        rd_coorprices42();
        rd_coorprices43();
        rd_coorprices44();
        rd_coorprices45();
        rd_coorprices46();
        rd_coorprices47();
        rd_coorprices48();
        rd_coorprices49();
        rd_coorprices50();
        rd_coorprices51();
        rd_coorprices52();
        rd_coorprices53();
        rd_coorprices54();
        rd_coorprices55();
        rd_coorprices56();
        rd_coorprices57();
        rd_coorprices58();
        rd_coorprices59();
        rd_coorprices60();
        rd_coorprices61();
        rd_coorprices62();
        rd_coorprices63();
        rd_coorprices64();
        rd_coorprices65();
        rd_coorprices66();
        rd_coorprices67();
        rd_coorprices68();
        rd_coorprices69();
        rd_coorprices70();
        rd_coorprices71();
        rd_coorprices72();
        rd_coorprices73();
        rd_coorprices74();
        rd_coorprices75();
        rd_coorprices76();
        rd_coorprices77();
        rd_coorprices78();
        rd_coorprices79();
        rd_coorprices80();
        rd_coorprices81();
        rd_coorprices82();
        rd_coorprices83();
        rd_coorprices84();
        rd_coorprices85();
        rd_coorprices86();
        rd_coorprices87();
        rd_coorprices88();
        rd_coorprices89();
        rd_coorprices90();
        rd_coorprices91();
        rd_coorprices92();
        rd_coorprices93();
        rd_coorprices94();
        rd_coorprices95();
        rd_coorprices96();



	manualmode=oldmode;
	for(ref=250;ref<=nod;ref++)
	  c_perfn(ref);
	normalize();
	return(1);
	}








write_map()
	{
	int x,y;
	char string[30];
	float tmp;
	float zero=0.0;
	long ltmp;
	float count=0.0;
	float mark=.00001;
	float mark2=.00003;
	float bosmm=.00002;
	system("dir *.map");
	printf("\n\t\t\tEnter .map filename: ");
	gets(string);
	prd=fopen(string,"w");
        fprintf(prd,"%s\n","BAYES96X.exe");
	fprintf(prd,"%s\n",istream1);
	fprintf(prd,"%s\n",istream2);
	fprintf(prd,"%s\n",istream3);
	fprintf(prd,"%s\n",istream4);
	fprintf(prd,"%s\n",istream5);
	fprintf(prd,"%s\n",istream6);
	fprintf(prd,"%s\n",istream7);
	fprintf(prd,"%s\n",istream8);
	fprintf(prd,"%s\n",istream9);
        fprintf(prd,"%s\n",istream21);
        fprintf(prd,"%s\n",istream22);
        fprintf(prd,"%s\n",istream23);
        fprintf(prd,"%s\n",istream24);
        fprintf(prd,"%s\n",istream25);
        fprintf(prd,"%s\n",istream26);
        fprintf(prd,"%s\n",istream27);
        fprintf(prd,"%s\n",istream28);

        fprintf(prd,"%s\n",istream29);
        fprintf(prd,"%s\n",istream30);
        fprintf(prd,"%s\n",istream31);
        fprintf(prd,"%s\n",istream32);
        fprintf(prd,"%s\n",istream33);
        fprintf(prd,"%s\n",istream34);
        fprintf(prd,"%s\n",istream35);
        fprintf(prd,"%s\n",istream36);
        fprintf(prd,"%s\n",istream37);
        fprintf(prd,"%s\n",istream38);
        fprintf(prd,"%s\n",istream39);
        fprintf(prd,"%s\n",istream40);
        fprintf(prd,"%s\n",istream41);
        fprintf(prd,"%s\n",istream42);
        fprintf(prd,"%s\n",istream43);
        fprintf(prd,"%s\n",istream44);


        fprintf(prd,"%s\n",istream45);
        fprintf(prd,"%s\n",istream46);
        fprintf(prd,"%s\n",istream47);
        fprintf(prd,"%s\n",istream48);
        fprintf(prd,"%s\n",istream49);
        fprintf(prd,"%s\n",istream50);
        fprintf(prd,"%s\n",istream51);
        fprintf(prd,"%s\n",istream52);
        fprintf(prd,"%s\n",istream53);
        fprintf(prd,"%s\n",istream54);
        fprintf(prd,"%s\n",istream55);
        fprintf(prd,"%s\n",istream56);
        fprintf(prd,"%s\n",istream57);
        fprintf(prd,"%s\n",istream58);
        fprintf(prd,"%s\n",istream59);
        fprintf(prd,"%s\n",istream60);


        fprintf(prd,"%s\n",istream61);
        fprintf(prd,"%s\n",istream62);
        fprintf(prd,"%s\n",istream63);
        fprintf(prd,"%s\n",istream64);
        fprintf(prd,"%s\n",istream65);
        fprintf(prd,"%s\n",istream66);
        fprintf(prd,"%s\n",istream67);
        fprintf(prd,"%s\n",istream68);
        fprintf(prd,"%s\n",istream69);
        fprintf(prd,"%s\n",istream70);
        fprintf(prd,"%s\n",istream71);
        fprintf(prd,"%s\n",istream72);
        fprintf(prd,"%s\n",istream73);
        fprintf(prd,"%s\n",istream74);
        fprintf(prd,"%s\n",istream75);
        fprintf(prd,"%s\n",istream76);
        fprintf(prd,"%s\n",istream77);
        fprintf(prd,"%s\n",istream78);
        fprintf(prd,"%s\n",istream79);
        fprintf(prd,"%s\n",istream80);
        fprintf(prd,"%s\n",istream81);
        fprintf(prd,"%s\n",istream82);
        fprintf(prd,"%s\n",istream83);
        fprintf(prd,"%s\n",istream84);
        fprintf(prd,"%s\n",istream85);
        fprintf(prd,"%s\n",istream86);
        fprintf(prd,"%s\n",istream87);
        fprintf(prd,"%s\n",istream88);
        fprintf(prd,"%s\n",istream89);
        fprintf(prd,"%s\n",istream90);
        fprintf(prd,"%s\n",istream91);
        fprintf(prd,"%s\n",istream92);
        fprintf(prd,"%s\n",istream93);
        fprintf(prd,"%s\n",istream94);
        fprintf(prd,"%s\n",istream95);
        fprintf(prd,"%s\n",istream96);
        fprintf(prd,"%s\n",istream97);
        fprintf(prd,"%s\n",istream98);
        fprintf(prd,"%s\n",istream99);
        fprintf(prd,"%s\n",istream100);
        fprintf(prd,"%s\n",istream101);
        fprintf(prd,"%s\n",istream102);
        fprintf(prd,"%s\n",istream103);
        fprintf(prd,"%s\n",istream104);
        fprintf(prd,"%s\n",istream105);
        fprintf(prd,"%s\n",istream106);
        fprintf(prd,"%s\n",istream107);
        fprintf(prd,"%s\n",istream108);



        fprintf(prd,"%d\n",ttp);
        fprintf(prd,"%d\n",twtp);
        fprintf(prd,"%d\n",tltp);
	fprintf(prd,"%d\n",hide);
	fprintf(prd,"%f\n",scatterscale);
	fprintf(prd,"%f\n",rss);
	fprintf(prd,"%d\n",learn);
	fprintf(prd,"%d\n",targtype);
	fprintf(prd,"%f\n",bsad);
	fprintf(prd,"%f\n",bestalltime);
	fprintf(prd,"%f\n",mltq);
	fprintf(prd,"%d\n",fittype);
	fprintf(prd,"%f\n",mutrate);
	fprintf(prd,"%f\n",maxweights);
	fprintf(prd,"%d\n",ft1);
	fprintf(prd,"%d\n",ft2);
	fprintf(prd,"%d\n",ft3);
	fprintf(prd,"%d\n",ft4);
	fprintf(prd,"%d\n",f2);
	fprintf(prd,"%d\n",f3);
	fprintf(prd,"%d\n",f4);
	fprintf(prd,"%d\n",flook);
	fprintf(prd,"%d\n",virg);
	fprintf(prd,"%d\n",evoptdays);
	fprintf(prd,"%d\n",tracelength);
	fprintf(prd,"%f\n",lrate);
	fprintf(prd,"%d\n",tracelength2);
	fprintf(prd,"%f\n",lrate2);
	fprintf(prd,"%d\n",tracelength3);
	fprintf(prd,"%f\n",lrate3);
	fprintf(prd,"%d\n",tracelength4);
	fprintf(prd,"%f\n",lrate4);
	fprintf(prd,"%d\n",maxhold);
	fprintf(prd,"%d\n",smaxhold);
	fprintf(prd,"%d\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%d\n",maxlots);
	fprintf(prd,"%f\n",longthresh);
	fprintf(prd,"%f\n",shortthresh);
	fprintf(prd,"%d\n",maxpass);
	fprintf(prd,"%f\n",fsf);
	fprintf(prd,"%f\n",stopthresh);
	fprintf(prd,"%f\n",rthresh);
	fprintf(prd,"%d\n",lotspertrade);
	fprintf(prd,"%d\n",maxlots);
	fprintf(prd,"%d\n",maxreentry);
	fprintf(prd,"%d\n",gcmaxpass);
	fprintf(prd,"%f\n",gcfsf);
	fprintf(prd,"%f\n",gcstopthresh);
	fprintf(prd,"%f\n",gcrthresh);
	fprintf(prd,"%d\n",gclotspertrade);
	fprintf(prd,"%d\n",gcmaxlots);
	fprintf(prd,"%d\n",gcmaxreentry);
        fprintf(prd,"%f\n",puritythresh);
	fprintf(prd,"%d\n",gcmapscale);
	fprintf(prd,"%d\n",gcmaxsamples);
        fprintf(prd,"%d\n",gcmaxhist);
	fprintf(prd,"%d\n",startgen);
	fprintf(prd,"%d\n",startss);
	fprintf(prd,"%d\n",tradertype);
	fprintf(prd,"%d\n",maaapg);
	fprintf(prd,"%d\n",max20);
	fprintf(prd,"%d\n",max60);
	fprintf(prd,"%d\n",max120);
	fprintf(prd,"%d\n",max250);
	fprintf(prd,"%f\n",ipc);
	fprintf(prd,"%f\n",matpc);
	fprintf(prd,"%f\n",opc);
	fprintf(prd,"%d\n",seed);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%d\n",trailing);
	fprintf(prd,"%d\n",nospreadflag);
	fprintf(prd,"%f\n",oosfitness[ss]);
	for(x=0;x<MAXDIST*8;x++)
		{
		fprintf(prd,"%d\n",mapscale[x]);
                fprintf(prd,"%d\n",dayweight[x]);
		}
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(x == XSIZE-1 && y == YSIZE-1)
				{
				fprintf(prd,"%f\n",mark);
				fprintf(prd,"%f\n",count);
				}
			if(map[x][y] == 0.0)
				{
				count=count+1.0;
				}
			if(map[x][y] != 0.0)
				{
				if(count > 0.0)
					{
					fprintf(prd,"%f\n",mark);
					fprintf(prd,"%f\n",count);
					count=0.0;
					}
				if(count == 0.0)
					{
					tmp=map[x][y];
					fprintf(prd,"%f\n",tmp);
					}
				}
			}
		}
	for(x=0;x<100;x++)
		fprintf(prd,"%f\n",zero);   // print pad
	fprintf(prd,"%f\n",bosmm);     // print beginning of seconf map marker
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(x == XSIZE-1 && y == YSIZE-1)
				{
				fprintf(prd,"%f\n",mark);
				fprintf(prd,"%f\n",count);
				}
			if(map2[x][y] == 0.0)
				{
				count=count+1.0;
				}
			if(map2[x][y] != 0.0)
				{
				if(count > 0.0)
					{
					fprintf(prd,"%f\n",mark);
					fprintf(prd,"%f\n",count);
					count=0.0;
					}
				if(count == 0.0)
					{
					tmp=map2[x][y];
					fprintf(prd,"%f\n",tmp);
					}
				}
			}
		}
     for(x=0;x<100;x++)
		fprintf(prd,"%f\n",zero);   // print pad
	fprintf(prd,"%f\n",mark2); 
	fprintf(prd,"%d\n",ocount);
	for(x=1;x<ocount;x++)
		{
		tmp=vf[x];
		fprintf(prd,"%f\n",tmp);
		}	
     for(x=1;x<ocount;x++)
		{
		tmp=oosf[x];
		fprintf(prd,"%f\n",tmp);
		}	
	fclose(prd);
	return(1);
	}


write_OLIVE()
	{
	int x,y;
        char ans[40];
	char string[60];
	char string2[60];
	float tmp;
	float zero=0.0;
	float mark=.00001;
	float mark2=.00003;
	float bosmm=.00002;
	long ltmp;
	int ians;
	float count=0.0;
	itoa(mapnamecount,string,10);
	printf("Current default path = %s\n",mappath);
	printf("Enter <2> to change it, or just return to use default path: ");
	gets(ans);
	ians=atoi(ans);
	if(ians == 2)
		{
		printf("Enter new map path: ");
		gets(mappath);
		}
	strcat(string,".map");
	strcpy(string2,mappath);
	strcat(string2,string);
	prd=fopen(string2,"w");
        if(prd == NULL)
                {
                printf("Can't open file/directory. Make sure subdir exists.\n");
                delay(5000);
                return(1);
                }
	printf("\n\n\tWriting map named: %s\n",string2);
	delay(500);
        fprintf(prd,"%s\n","BAYES96X.exe");
	fprintf(prd,"%s\n",istream1);
	fprintf(prd,"%s\n",istream2);
	fprintf(prd,"%s\n",istream3);
	fprintf(prd,"%s\n",istream4);
	fprintf(prd,"%s\n",istream5);
	fprintf(prd,"%s\n",istream6);
	fprintf(prd,"%s\n",istream7);
	fprintf(prd,"%s\n",istream8);
	fprintf(prd,"%s\n",istream9);
        fprintf(prd,"%s\n",istream21);
        fprintf(prd,"%s\n",istream22);
        fprintf(prd,"%s\n",istream23);
        fprintf(prd,"%s\n",istream24);
        fprintf(prd,"%s\n",istream25);
        fprintf(prd,"%s\n",istream26);
        fprintf(prd,"%s\n",istream27);
        fprintf(prd,"%s\n",istream28);

        fprintf(prd,"%s\n",istream29);
        fprintf(prd,"%s\n",istream30);
        fprintf(prd,"%s\n",istream31);
        fprintf(prd,"%s\n",istream32);
        fprintf(prd,"%s\n",istream33);
        fprintf(prd,"%s\n",istream34);
        fprintf(prd,"%s\n",istream35);
        fprintf(prd,"%s\n",istream36);
        fprintf(prd,"%s\n",istream37);
        fprintf(prd,"%s\n",istream38);
        fprintf(prd,"%s\n",istream39);
        fprintf(prd,"%s\n",istream40);
        fprintf(prd,"%s\n",istream41);
        fprintf(prd,"%s\n",istream42);
        fprintf(prd,"%s\n",istream43);
        fprintf(prd,"%s\n",istream44);

        fprintf(prd,"%s\n",istream45);
        fprintf(prd,"%s\n",istream46);
        fprintf(prd,"%s\n",istream47);
        fprintf(prd,"%s\n",istream48);
        fprintf(prd,"%s\n",istream49);
        fprintf(prd,"%s\n",istream50);
        fprintf(prd,"%s\n",istream51);
        fprintf(prd,"%s\n",istream52);
        fprintf(prd,"%s\n",istream53);
        fprintf(prd,"%s\n",istream54);
        fprintf(prd,"%s\n",istream55);
        fprintf(prd,"%s\n",istream56);
        fprintf(prd,"%s\n",istream57);
        fprintf(prd,"%s\n",istream58);
        fprintf(prd,"%s\n",istream59);
        fprintf(prd,"%s\n",istream60);
        fprintf(prd,"%s\n",istream61);
        fprintf(prd,"%s\n",istream62);
        fprintf(prd,"%s\n",istream63);
        fprintf(prd,"%s\n",istream64);
        fprintf(prd,"%s\n",istream65);
        fprintf(prd,"%s\n",istream66);
        fprintf(prd,"%s\n",istream67);
        fprintf(prd,"%s\n",istream68);
        fprintf(prd,"%s\n",istream69);
        fprintf(prd,"%s\n",istream70);
        fprintf(prd,"%s\n",istream71);
        fprintf(prd,"%s\n",istream72);
        fprintf(prd,"%s\n",istream73);
        fprintf(prd,"%s\n",istream74);
        fprintf(prd,"%s\n",istream75);
        fprintf(prd,"%s\n",istream76);
        fprintf(prd,"%s\n",istream77);
        fprintf(prd,"%s\n",istream78);
        fprintf(prd,"%s\n",istream79);
        fprintf(prd,"%s\n",istream80);
        fprintf(prd,"%s\n",istream81);
        fprintf(prd,"%s\n",istream82);
        fprintf(prd,"%s\n",istream83);
        fprintf(prd,"%s\n",istream84);
        fprintf(prd,"%s\n",istream85);
        fprintf(prd,"%s\n",istream86);
        fprintf(prd,"%s\n",istream87);
        fprintf(prd,"%s\n",istream88);
        fprintf(prd,"%s\n",istream89);
        fprintf(prd,"%s\n",istream90);
        fprintf(prd,"%s\n",istream91);
        fprintf(prd,"%s\n",istream92);
        fprintf(prd,"%s\n",istream93);
        fprintf(prd,"%s\n",istream94);
        fprintf(prd,"%s\n",istream95);
        fprintf(prd,"%s\n",istream96);
        fprintf(prd,"%s\n",istream97);
        fprintf(prd,"%s\n",istream98);
        fprintf(prd,"%s\n",istream99);
        fprintf(prd,"%s\n",istream100);
        fprintf(prd,"%s\n",istream101);
        fprintf(prd,"%s\n",istream102);
        fprintf(prd,"%s\n",istream103);
        fprintf(prd,"%s\n",istream104);
        fprintf(prd,"%s\n",istream105);
        fprintf(prd,"%s\n",istream106);
        fprintf(prd,"%s\n",istream107);
        fprintf(prd,"%s\n",istream108);


        fprintf(prd,"%d\n",ttp);
        fprintf(prd,"%d\n",twtp);
        fprintf(prd,"%d\n",tltp);
	fprintf(prd,"%d\n",hide);
	fprintf(prd,"%f\n",scatterscale);
	fprintf(prd,"%f\n",rss);
	fprintf(prd,"%d\n",learn);
	fprintf(prd,"%d\n",targtype);
	fprintf(prd,"%f\n",bsad);
	fprintf(prd,"%f\n",bestalltime);
	fprintf(prd,"%f\n",mltq);
	fprintf(prd,"%d\n",fittype);
	fprintf(prd,"%f\n",
        mutrate);
	fprintf(prd,"%f\n",maxweights);
	fprintf(prd,"%d\n",ft1);
	fprintf(prd,"%d\n",ft2);
	fprintf(prd,"%d\n",ft3);
	fprintf(prd,"%d\n",ft4);
	fprintf(prd,"%d\n",f2);
	fprintf(prd,"%d\n",f3);
	fprintf(prd,"%d\n",f4);
	fprintf(prd,"%d\n",flook);
	fprintf(prd,"%d\n",virg);
	fprintf(prd,"%d\n",evoptdays);
	fprintf(prd,"%d\n",tracelength);
	fprintf(prd,"%f\n",lrate);
	fprintf(prd,"%d\n",tracelength2);
	fprintf(prd,"%f\n",lrate2);
	fprintf(prd,"%d\n",tracelength3);
	fprintf(prd,"%f\n",lrate3);
	fprintf(prd,"%d\n",tracelength4);
	fprintf(prd,"%f\n",lrate4);
	fprintf(prd,"%d\n",maxhold);
	fprintf(prd,"%d\n",smaxhold);
	fprintf(prd,"%d\n",gcmaxhold);
	fprintf(prd,"%ld\n",gcsmaxhold);
	fprintf(prd,"%d\n",maxlots);
	fprintf(prd,"%f\n",longthresh);
	fprintf(prd,"%f\n",shortthresh);
	fprintf(prd,"%d\n",maxpass);
	fprintf(prd,"%f\n",fsf);
	fprintf(prd,"%f\n",stopthresh);
	fprintf(prd,"%f\n",rthresh);
	fprintf(prd,"%d\n",lotspertrade);
	fprintf(prd,"%d\n",maxlots);
	fprintf(prd,"%d\n",maxreentry);
	fprintf(prd,"%d\n",gcmaxpass);
	fprintf(prd,"%f\n",gcfsf);
	fprintf(prd,"%f\n",gcstopthresh);
	fprintf(prd,"%f\n",gcrthresh);
	fprintf(prd,"%d\n",gclotspertrade);
	fprintf(prd,"%d\n",gcmaxlots);
	fprintf(prd,"%d\n",gcmaxreentry);
        fprintf(prd,"%f\n",puritythresh);
	fprintf(prd,"%d\n",gcmapscale);
	fprintf(prd,"%d\n",gcmaxsamples);
	fprintf(prd,"%d\n",gcmaxhist);
	fprintf(prd,"%d\n",startgen);
	fprintf(prd,"%d\n",startss);
	fprintf(prd,"%d\n",tradertype);
	fprintf(prd,"%d\n",maaapg);
	fprintf(prd,"%d\n",max20);
	fprintf(prd,"%d\n",max60);
	fprintf(prd,"%d\n",max120);
	fprintf(prd,"%d\n",max250);
	fprintf(prd,"%f\n",ipc);
	fprintf(prd,"%f\n",matpc);
	fprintf(prd,"%f\n",opc);
	fprintf(prd,"%d\n",seed);
	fprintf(prd,"%f\n",minstopthresh);
	fprintf(prd,"%d\n",trailing);
	fprintf(prd,"%d\n",nospreadflag);
	oosfitness[ss]=1.0;
	fprintf(prd,"%f\n",oosfitness[ss]);
	for(x=0;x<MAXDIST*8;x++)
		{
		fprintf(prd,"%d\n",mapscale[x]);
                fprintf(prd,"%d\n",dayweight[x]);
		}
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(x == XSIZE-1 && y == YSIZE-1)
				{
				fprintf(prd,"%f\n",mark);
				fprintf(prd,"%f\n",count);
				}
			if(map[x][y] == 0.0)
				{
				count=count+1.0;
				}
			if(map[x][y] != 0.0)
				{
				if(count > 0.0)
					{
					fprintf(prd,"%f\n",mark);
					fprintf(prd,"%f\n",count);
					count=0.0;
					}
				 if(count == 0.0)
					{
					tmp=map[x][y];
					fprintf(prd,"%f\n",tmp);
					}
				}
			}
		}
	for(x=0;x<100;x++)
		fprintf(prd,"%f\n",zero);   // print pad
	fprintf(prd,"%f\n",bosmm);     // print beginning of seconf map marker
	count=0.0;
	for(x=0;x<XSIZE;x++)
		{
		for(y=0;y<YSIZE;y++)
			{
			if(x == XSIZE-1 && y == YSIZE-1)
				{
				fprintf(prd,"%f\n",mark);
				fprintf(prd,"%f\n",count);
				}
			if(map2[x][y] == 0.0)
				{
				count=count+1.0;
				}
			if(map2[x][y] != 0.0)
				{
				if(count > 0.0)
					{
					fprintf(prd,"%f\n",mark);
					fprintf(prd,"%f\n",count);
					count=0.0;
					}
				if(count == 0.0)
					{
					tmp=map2[x][y];
					fprintf(prd,"%f\n",tmp);
					}
				}
			}
		}
	for(x=0;x<100;x++)
		fprintf(prd,"%f\n",zero);   // print pad
	fprintf(prd,"%f\n",mark2); 
	fprintf(prd,"%d\n",ocount);
	for(x=1;x<ocount;x++)
		{
		tmp=vf[x];
		fprintf(prd,"%f\n",tmp);
		}	
     for(x=1;x<ocount;x++)
		{
		tmp=oosf[x];
		fprintf(prd,"%f\n",tmp);
		}	
	fclose(prd);
	return(1);
	}











wrtpred()
	{
	long ref;
	char string[30];
	int pt;
	if(manualmode)
		{
	//	printf("\n\t\tEnter .prd type (1 for raw, 2 for 50th percentile,\n");
	//	printf("3 for upper percentile, 4 for lower percentile): ");
	//	gets(string);
		pt=1;
		printf("\n\t\t\tEnter .prd filename: ");
		gets(string);
		strcpy(ostream,string);
		}
	printf("nod=%d\n",nod);
//	delay(1000);
	prd=fopen(ostream,"w");
        for(ref=500;ref<=nod;ref++)
		{
		if(pt == 1 || manualmode == 0)
			fprintf(prd,"%f\n",pred[ref]);
		}
	fclose(prd);
	return(1);
	}


		 /******        THE END        *******/
